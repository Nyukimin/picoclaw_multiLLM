# 実装仕様_06（Go版）：workerディスパッチャ / logger / loop controller

このファイルは route -> worker 呼び出し、success/failログ、materials収集までを Go で定義する。

---

## 1) `pkg/workers/dispatch.go`

```go
package workers

import (
	"context"
	"fmt"

	"github.com/sipeed/picoclaw/pkg/llm"
)

type Deps struct {
	ReasonClient llm.Client
	CodeClient   llm.Client
	ReasonModel  string
	CodeModel    string
	ReasonTOms   int
	CodeTOms     int
}

type RunResult struct {
	OK      bool
	Output  WorkerOutput
	ErrText string
}

func RunByRoute(ctx context.Context, route Route, base WorkerInput, deps Deps) RunResult {
	in := base
	in.Route = route

	var out WorkerOutput
	switch route {
	case RoutePlan:
		out = PlanWorker(ctx, deps.ReasonClient, in, deps.ReasonModel, deps.ReasonTOms)
	case RouteAnalyze:
		out = AnalyzeWorker(ctx, deps.ReasonClient, in, deps.ReasonModel, deps.ReasonTOms)
	case RouteOps:
		out = OpsWorker(ctx, deps.ReasonClient, in, deps.ReasonModel, deps.ReasonTOms)
	case RouteResearch:
		out = ResearchWorker(ctx, deps.ReasonClient, in, deps.ReasonModel, deps.ReasonTOms)
	case RouteCode:
		out = CodeWorker(ctx, deps.CodeClient, in, deps.CodeModel, deps.CodeTOms)
	case RouteChat:
		// CHATはワーカー非必須。空素材を返して会話LLMへ。
		out = WorkerOutput{Result: map[string]any{"note": "no worker for CHAT"}, NeedsNextLoop: false, Why: "chat direct", Risk: RiskLow}
	default:
		return RunResult{OK: false, ErrText: fmt.Sprintf("unsupported route: %s", route)}
	}

	return RunResult{OK: true, Output: out}
}
```

---

## 2) `pkg/infra/logger.go`

```go
package infra

import (
	"encoding/json"
	"io"
	"os"
	"sync"
	"time"
)

type Level string

const (
	Debug Level = "debug"
	Info  Level = "info"
	Warn  Level = "warn"
	Error Level = "error"
)

type Event struct {
	TS      string         `json:"ts"`
	Level   Level          `json:"level"`
	Message string         `json:"message"`
	Fields  map[string]any `json:"fields,omitempty"`
}

type Logger struct {
	mu    sync.Mutex
	level Level
	w     io.Writer
}

func NewLogger(level Level, w io.Writer) *Logger {
	if w == nil {
		w = os.Stdout
	}
	return &Logger{level: level, w: w}
}

func (l *Logger) Log(level Level, msg string, fields map[string]any) {
	l.mu.Lock()
	defer l.mu.Unlock()
	ev := Event{TS: time.Now().Format(time.RFC3339), Level: level, Message: msg, Fields: fields}
	b, _ := json.Marshal(ev)
	_, _ = l.w.Write(append(b, '\n'))
}
```

---

## 3) `pkg/loop/controller.go`

```go
package loop

import (
	"context"
	"time"

	"github.com/sipeed/picoclaw/pkg/infra"
	"github.com/sipeed/picoclaw/pkg/materials"
	"github.com/sipeed/picoclaw/pkg/workers"
)

type Config struct {
	MaxLoops    int
	MaxMillis   int
	AllowRerouteOnce bool
}

type Result struct {
	FinalRoute workers.Route
	Materials  []materials.Item
	Loops      int
	StopReason string // done|max_loops|timeout|worker_fail
}

func Run(ctx context.Context, turnID, sessionID string, primary workers.Route, input workers.WorkerInput, deps workers.Deps, cfg Config, log *infra.Logger) Result {
	start := time.Now()
	route := primary
	loops := 0
	rerouted := false
	collected := make([]materials.Item, 0, cfg.MaxLoops)

	for loops < cfg.MaxLoops {
		if time.Since(start).Milliseconds() >= int64(cfg.MaxMillis) {
			return Result{FinalRoute: route, Materials: collected, Loops: loops, StopReason: "timeout"}
		}
		loops++

		res := workers.RunByRoute(ctx, route, input, deps)
		if !res.OK {
			log.Log(infra.Error, "worker.fail", map[string]any{"turn_id": turnID, "route": route, "error": res.ErrText})
			return Result{FinalRoute: route, Materials: collected, Loops: loops, StopReason: "worker_fail"}
		}

		out := res.Output
		log.Log(infra.Info, "worker.success", map[string]any{
			"turn_id": turnID, "session_id": sessionID, "route": route,
			"needs_next_loop": out.NeedsNextLoop, "risk": out.Risk, "confidence": out.Confidence,
		})

		collected = append(collected, materials.Item{
			Route:  route,
			Worker: string(route),
			Result: out.Result,
			Meta: map[string]any{
				"confidence": out.Confidence,
				"risk":       out.Risk,
				"why":        out.Why,
			},
		})

		if !out.NeedsNextLoop {
			return Result{FinalRoute: route, Materials: collected, Loops: loops, StopReason: "done"}
		}

		if cfg.AllowRerouteOnce && !rerouted && out.Fit != nil && !*out.Fit && out.SuggestedRoute != "" {
			route = out.SuggestedRoute
			rerouted = true
			continue
		}

		// 再ルートしない場合は同route継続
	}

	return Result{FinalRoute: route, Materials: collected, Loops: loops, StopReason: "max_loops"}
}
```

---

## 4) 使用例

```go
log := infra.NewLogger(infra.Info, nil)
res := loop.Run(ctx, turnID, sessionID, decision.PrimaryRoute, workerInput, deps, loop.Config{
	MaxLoops: 3,
	MaxMillis: 25000,
	AllowRerouteOnce: true,
}, log)
```

---

## 5) 実装メモ

* `worker.fail` は会話LLMへの素材を最小化して終了
* `risk=high` の場合は LoopController でユーザー確認へ分岐
* 再ルートは最大1回まで（無限ループ防止）
