まだ出してない。ここで **コピペ用**に出すね。
前提：さっきの `planWorker/codeWorker/runWorkerLLM` 形式を踏襲して、**route→worker関数の束ね**と、**LoopController側の呼び出し＋success/failログ**までを一気に揃える。

---

## 1) `src/workers/index.ts`（route→workerディスパッチャ）

```ts
// src/workers/index.ts
import type { LLMClient } from "../llm/llmClient";
import type { Route, WorkerInput, WorkerOutput } from "../types/worker";

import { planWorker } from "./planWorker";
import { codeWorker } from "./codeWorker";

// TODO: 同じ雛形で作ったら import して足す
// import { analyzeWorker } from "./analyzeWorker";
// import { opsWorker } from "./opsWorker";
// import { researchWorker } from "./researchWorker";

export type WorkerDeps = {
  // ローカル推論LLM（Ollama）
  reasonClient: LLMClient;
  reasonModel: string;
  reasonTimeoutMs: number;

  // クラウドコードLLM（1本）
  cloudClient: LLMClient;
  cloudModel: string;
  cloudTimeoutMs: number;
};

export type WorkerRunResult =
  | { ok: true; output: WorkerOutput; used: { route: Route; model: string; timeoutMs: number } }
  | { ok: false; error: string; used: { route: Route; model?: string; timeoutMs?: number } };

function assertRoute(input: WorkerInput, expected: Route) {
  if (input.route !== expected) {
    // バグ混入を早期検知（routeは呼び出し側がセットする設計）
    throw new Error(`WorkerInput.route mismatch: expected=${expected} got=${input.route}`);
  }
}

export async function runWorkerByRoute(args: {
  route: Route;
  inputBase: Omit<WorkerInput, "route">; // 呼び出し側で route を差し替える
  deps: WorkerDeps;
}): Promise<WorkerRunResult> {
  const { route, inputBase, deps } = args;

  const input: WorkerInput = { ...inputBase, route };

  try {
    switch (route) {
      case "PLAN": {
        assertRoute(input, "PLAN");
        const output = await planWorker({
          input,
          client: deps.reasonClient,
          model: deps.reasonModel,
          timeoutMs: deps.reasonTimeoutMs
        });
        return { ok: true, output, used: { route, model: deps.reasonModel, timeoutMs: deps.reasonTimeoutMs } };
      }

      case "CODE": {
        assertRoute(input, "CODE");
        const output = await codeWorker({
          input,
          client: deps.cloudClient,
          model: deps.cloudModel,
          timeoutMs: deps.cloudTimeoutMs
        });
        return { ok: true, output, used: { route, model: deps.cloudModel, timeoutMs: deps.cloudTimeoutMs } };
      }

      // TODO: 以下は同じ形で差し込む
      // case "ANALYZE": ...
      // case "OPS": ...
      // case "RESEARCH": ...
      // case "CHAT": ... (通常はワーカー呼ばずにスキップ)

      case "CHAT":
      case "ANALYZE":
      case "OPS":
      case "RESEARCH":
      default: {
        return { ok: false, error: `worker_not_implemented for route=${route}`, used: { route } };
      }
    }
  } catch (e: any) {
    return { ok: false, error: String(e?.message ?? e), used: { route } };
  }
}
```

---

## 2) `src/infra/logger.ts`（最小ロガー：JSONL想定）

> 既に logger があるなら置き換えればOK。
> 重要なのは「1ターンID」「ステップ」「ok/fail」「route」「理由」が残ること。

```ts
// src/infra/logger.ts
export type LogLevel = "debug" | "info" | "warn" | "error";

export type LogEvent = {
  ts: string;
  level: LogLevel;
  event: string;
  turn_id?: string;
  session_id?: string;

  route?: string;
  source?: string;

  ok?: boolean;
  reason?: string;

  // 追加情報
  data?: any;
};

export function nowIso(): string {
  return new Date().toISOString();
}

export class Logger {
  constructor(private readonly minLevel: LogLevel = "info") {}

  private allow(level: LogLevel): boolean {
    const order: Record<LogLevel, number> = { debug: 10, info: 20, warn: 30, error: 40 };
    return order[level] >= order[this.minLevel];
  }

  log(ev: LogEvent) {
    if (!this.allow(ev.level)) return;
    const payload = { ...ev, ts: ev.ts ?? nowIso() };
    // JSONLとして stdout に出す（systemd/journald想定）
    // ファイルにしたい場合はここで appendFile
    console.log(JSON.stringify(payload));
  }

  debug(event: string, x: Omit<LogEvent, "level" | "event"> = {}) {
    this.log({ level: "debug", event, ...x, ts: nowIso() });
  }
  info(event: string, x: Omit<LogEvent, "level" | "event"> = {}) {
    this.log({ level: "info", event, ...x, ts: nowIso() });
  }
  warn(event: string, x: Omit<LogEvent, "level" | "event"> = {}) {
    this.log({ level: "warn", event, ...x, ts: nowIso() });
  }
  error(event: string, x: Omit<LogEvent, "level" | "event"> = {}) {
    this.log({ level: "error", event, ...x, ts: nowIso() });
  }
}
```

---

## 3) `src/core/loopController.ts`（ワーカー呼び出し＋success/failログ＋materials収集）

> ここは「ループ管理の最終決定者」。
>
> * `maxLoops / maxMillis` 厳守
> * reroute は最大1回
> * success/fail を log
> * `materials` は後で `prepareMaterialsForChatLLM` に渡す

```ts
// src/core/loopController.ts
import type { Route, WorkerInput, WorkerOutput } from "../types/worker";
import type { MaterialItem } from "./materials";
import type { WorkerDeps } from "../workers";
import { runWorkerByRoute } from "../workers";
import { Logger } from "../infra/logger";

export type LoopConfig = {
  maxLoops: number;
  maxMillis: number;
  allowAutoRerouteOnce: boolean;
};

export type LoopResult = {
  finalRoute: Route;
  materials: MaterialItem[];
  // 次の判断でユーザー確認が必要なら、会話LLMへ素材として渡す
  stopReason: "done" | "risk_high" | "worker_fail" | "timeout" | "max_loops";
  rerouted: boolean;
};

function nowMs(): number {
  return Date.now();
}

function within(startMs: number, maxMillis: number): boolean {
  return nowMs() - startMs < maxMillis;
}

/**
 * 次ルートの固定ヒューリスティック（最初はこれでOK）
 * - 仕様の通り：ANALYZE/OPS/RESEARCH -> PLAN, PLAN -> CHAT, CODE -> OPS or CHAT
 */
function chooseNextRouteHeuristic(cur: Route, w: WorkerOutput): Route {
  // workerが fit=false で suggested_route を出しているなら、呼び出し側で reroute 判定する
  switch (cur) {
    case "ANALYZE":
    case "OPS":
    case "RESEARCH":
      return "PLAN";
    case "PLAN":
      return "CHAT";
    case "CODE":
      // コード提示の後は手順/適用が必要になりやすい
      return "OPS";
    default:
      return "CHAT";
  }
}

export async function runLoopController(args: {
  turnId: string;
  sessionId: string;

  primaryRoute: Route;
  inputBase: Omit<WorkerInput, "route">; // routeは都度差し替え
  deps: WorkerDeps;
  loop: LoopConfig;
  logger: Logger;
}): Promise<LoopResult> {
  const { turnId, sessionId, deps, loop, logger } = args;

  const start = nowMs();
  let loops = 0;
  let rerouted = false;

  const materials: MaterialItem[] = [];

  let route: Route = args.primaryRoute;

  logger.info("loop_start", {
    turn_id: turnId,
    session_id: sessionId,
    route,
    data: { maxLoops: loop.maxLoops, maxMillis: loop.maxMillis }
  });

  while (loops < loop.maxLoops && within(start, loop.maxMillis)) {
    // CHAT は通常ワーカー無しで終了（素材が不要な場合）
    if (route === "CHAT") {
      logger.info("loop_stop_chat", { turn_id: turnId, session_id: sessionId, route, ok: true });
      return { finalRoute: route, materials, stopReason: "done", rerouted };
    }

    logger.info("worker_call", { turn_id: turnId, session_id: sessionId, route });

    const res = await runWorkerByRoute({
      route,
      inputBase: args.inputBase,
      deps
    });

    if (!res.ok) {
      logger.warn("worker_fail", {
        turn_id: turnId,
        session_id: sessionId,
        route,
        ok: false,
        reason: res.error,
        data: { used: res.used }
      });

      materials.push({
        route,
        meta: {
          result: { error: res.error },
          needs_next_loop: false,
          why: "worker実行失敗",
          next_actions: [],
          questions_for_user: [],
          confidence: 0,
          risk: "medium",
          fit: false,
          suggested_route: "CHAT"
        },
        error: res.error
      });

      return { finalRoute: route, materials, stopReason: "worker_fail", rerouted };
    }

    const w = res.output;

    logger.info("worker_ok", {
      turn_id: turnId,
      session_id: sessionId,
      route,
      ok: true,
      data: {
        used: res.used,
        risk: w.risk,
        confidence: w.confidence,
        needs_next_loop: w.needs_next_loop,
        fit: w.fit,
        suggested_route: w.suggested_route
      }
    });

    materials.push({ route, meta: w, result: w.result });

    // risk==high はユーザー確認へ（ここで止める）
    if (w.risk === "high") {
      logger.warn("loop_stop_risk_high", {
        turn_id: turnId,
        session_id: sessionId,
        route,
        ok: true,
        reason: "risk==high"
      });
      return { finalRoute: route, materials, stopReason: "risk_high", rerouted };
    }

    // 次ループ不要なら終了
    if (!w.needs_next_loop) {
      logger.info("loop_stop_done", { turn_id: turnId, session_id: sessionId, route, ok: true });
      return { finalRoute: route, materials, stopReason: "done", rerouted };
    }

    // 自動再ルート（最大1回）
    if (loop.allowAutoRerouteOnce && !rerouted && w.fit === false) {
      const sr = w.suggested_route;
      const allowed: Route[] = ["CHAT", "PLAN", "ANALYZE", "OPS", "RESEARCH", "CODE"];
      if (allowed.includes(sr)) {
        logger.info("loop_reroute", {
          turn_id: turnId,
          session_id: sessionId,
          route,
          ok: true,
          reason: `fit=false -> suggested_route=${sr}`
        });
        route = sr;
        rerouted = true;
        loops += 1;
        continue;
      }
    }

    // 通常の次ループ：固定ヒューリスティック
    const next = chooseNextRouteHeuristic(route, w);
    logger.info("loop_next", {
      turn_id: turnId,
      session_id: sessionId,
      route,
      ok: true,
      data: { next }
    });

    route = next;
    loops += 1;
  }

  // ループ打ち切り（時間 or 回数）
  const stopReason: LoopResult["stopReason"] = loops >= loop.maxLoops ? "max_loops" : "timeout";
  logger.warn("loop_stop_limit", {
    turn_id: turnId,
    session_id: sessionId,
    route,
    ok: true,
    reason: stopReason,
    data: { loops, elapsedMs: nowMs() - start }
  });

  return { finalRoute: route, materials, stopReason, rerouted };
}
```

---

## 4) Orchestrator 側の呼び出し例（最短）

> これで「Routerで決めた primaryRoute を LoopController に渡す」流れが繋がる。

```ts
import { runLoopController } from "./loopController";
import { Logger } from "../infra/logger";

const logger = new Logger("info");

const loopRes = await runLoopController({
  turnId,
  sessionId: input.session.session_id,
  primaryRoute: decision.primary_route,
  inputBase: {
    // WorkerInput から route を除いたものを詰める
    session: input.session,
    user_text: input.user_text,
    context: input.context,
    flags: input.flags,
    limits: input.limits,
    security: input.security,
    tooling: input.tooling
  },
  deps: {
    reasonClient,
    reasonModel: process.env.OLLAMA_REASON_MODEL ?? "qwen3-thinking-q4",
    reasonTimeoutMs: 12000,

    cloudClient,
    cloudModel: process.env.CLOUD_CODE_MODEL ?? "your-cloud-model",
    cloudTimeoutMs: 20000
  },
  loop: {
    maxLoops: 3,
    maxMillis: 25000,
    allowAutoRerouteOnce: true
  },
  logger
});

// loopRes.materials を prepareMaterialsForChatLLM(...) に渡す
```

---

これで「ディスパッチャ」と「LoopController側（success/failログ＋materials収集）」はコピペで揃った。
次は、`analyzeWorker/opsWorker/researchWorker` を同じ型で足すだけで、ルーティング設計がそのまま動線になる。
