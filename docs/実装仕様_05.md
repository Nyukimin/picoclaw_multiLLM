# 実装仕様_05（Go版）：materials整形（壊れにくく・溢れにくく）

> アーカイブ扱い: 本ファイルは互換参照用（更新停止）。内容は v2 へ再配置済みです。  
> 参照: `docs/実装仕様_v2_05_ワーカー.md` / `docs/実装仕様_v2_06_セキュリティ.md` / 正本 `docs/実装仕様_v2_統合版.md`

目的:

* 会話LLMに渡す素材をサイズ制御する
* 長文は要約/切り詰めで安定化
* diffは「一覧 + 要点 + 部分diff」に縮約

---

## 1) `pkg/materials/policy.go`

```go
package materials

import "github.com/sipeed/picoclaw/pkg/workers"

type Policy struct {
	MaxTotalChars        int
	MaxItemChars         int
	MaxDiffChars         int
	MaxDiffLines         int
	MaxItems             int
	RoutePriority        map[workers.Route]int
	EnableSummarize      bool
	SummarizeTargetChars int
}

func DefaultPolicy() Policy {
	return Policy{
		MaxTotalChars:        14000,
		MaxItemChars:         4500,
		MaxDiffChars:         3500,
		MaxDiffLines:         200,
		MaxItems:             8,
		EnableSummarize:      true,
		SummarizeTargetChars: 700,
		RoutePriority: map[workers.Route]int{
			workers.RouteCode:     100,
			workers.RouteAnalyze:  90,
			workers.RoutePlan:     80,
			workers.RouteOps:      70,
			workers.RouteResearch: 60,
			workers.RouteChat:     50,
		},
	}
}
```

---

## 2) `pkg/materials/builder.go`

```go
package materials

import (
	"encoding/json"
	"fmt"
	"regexp"
	"sort"
	"strings"

	"github.com/sipeed/picoclaw/pkg/workers"
)

type Item struct {
	Route  workers.Route
	Worker string
	Result any
	Meta   map[string]any
}

type Prepared struct {
	MaterialsText string
	Brief         []string
	Dropped       []string
	TotalChars    int
}

type Summarizer interface {
	Summarize(text string, maxChars int, kind string) (string, error)
}

type Redactor func(string) string

func MakeSimpleRedactor(patterns []string) Redactor {
	compiled := make([]*regexp.Regexp, 0, len(patterns))
	for _, p := range patterns {
		re, err := regexp.Compile(regexp.QuoteMeta(p) + `[^\s"']*`)
		if err == nil {
			compiled = append(compiled, re)
		}
	}
	return func(s string) string {
		out := s
		for _, re := range compiled {
			out = re.ReplaceAllString(out, "[REDACTED]")
		}
		return out
	}
}

func toText(v any) string {
	switch t := v.(type) {
	case string:
		return t
	default:
		b, _ := json.MarshalIndent(v, "", "  ")
		return string(b)
	}
}

func diffFileList(diff string) []string {
	re := regexp.MustCompile(`(?m)^diff --git a/(.+?) b/(.+?)$`)
	m := re.FindAllStringSubmatch(diff, -1)
	out := make([]string, 0, len(m))
	for _, x := range m {
		if len(x) >= 3 {
			out = append(out, x[2])
		}
	}
	return out
}

func truncateByLinesAndChars(s string, maxLines, maxChars int) (string, bool) {
	lines := strings.Split(s, "\n")
	truncated := false
	if len(lines) > maxLines {
		lines = lines[:maxLines]
		truncated = true
	}
	t := strings.Join(lines, "\n")
	if len(t) > maxChars {
		t = t[:maxChars]
		truncated = true
	}
	return t, truncated
}

func render(item Item, p Policy, summarizer Summarizer, redactor Redactor) (text string, truncated bool) {
	raw := redactor(toText(item.Result))

		if strings.Contains(raw, "diff --git") {
		files := diffFileList(raw)
		body, tr := truncateByLinesAndChars(raw, p.MaxDiffLines, p.MaxDiffChars)
		summary := ""
		if p.EnableSummarize && summarizer != nil {
			if s, err := summarizer.Summarize(raw, p.SummarizeTargetChars, "diff"); err == nil {
				summary = s
			}
		}
		header := fmt.Sprintf("files=%d", len(files))
		if len(files) > 0 {
			header += " [" + strings.Join(files, ", ") + "]"
		}
		if summary != "" {
			return fmt.Sprintf("%s\nDiffSummary:\n%s\nDiffSnippet:\n%s", header, summary, body), true
		}
		return fmt.Sprintf("%s\nDiffSnippet:\n%s", header, body), tr
	}

	if len(raw) > p.MaxItemChars {
		if p.EnableSummarize && summarizer != nil {
			if s, err := summarizer.Summarize(raw, p.SummarizeTargetChars, "generic"); err == nil && s != "" {
				return s, true
			}
		}
		return raw[:p.MaxItemChars], true
	}
	return raw, false
}

func Prepare(items []Item, policy Policy, summarizer Summarizer, redactor Redactor) Prepared {
	if redactor == nil {
		redactor = func(s string) string { return s }
	}
	if policy.MaxItems <= 0 {
		policy.MaxItems = 8
	}

	sort.Slice(items, func(i, j int) bool {
		return policy.RoutePriority[items[i].Route] > policy.RoutePriority[items[j].Route]
	})

	out := Prepared{Brief: []string{}, Dropped: []string{}}
	blocks := make([]string, 0, len(items))

	for idx, it := range items {
		if idx >= policy.MaxItems {
			out.Dropped = append(out.Dropped, fmt.Sprintf("%s: over max items", it.Worker))
			continue
		}
		r, tr := render(it, policy, summarizer, redactor)
		block := fmt.Sprintf("[%s/%s]\n%s", it.Route, it.Worker, r)
		size := len(block) + 2
		if out.TotalChars+size > policy.MaxTotalChars {
			out.Dropped = append(out.Dropped, fmt.Sprintf("%s: over total chars", it.Worker))
			continue
		}
		out.TotalChars += size
		blocks = append(blocks, block)
		brief := fmt.Sprintf("%s/%s chars=%d", it.Route, it.Worker, len(r))
		if tr {
			brief += " truncated=true"
		}
		out.Brief = append(out.Brief, brief)
	}

	out.MaterialsText = strings.Join(blocks, "\n\n")
	return out
}

func BuildMaterialsSystemNote(materialsText string) string {
	if strings.TrimSpace(materialsText) == "" {
		return ""
	}
	return "# Materials\n以下はワーカー素材。矛盾があれば明示し、断定を避けること。\n\n" + materialsText
}
```

---

## 3) `pkg/llm/summarizer.go`（任意）

```go
package llm

import (
	"context"
	"strings"
)

type Summarizer struct {
	Client  Client
	Model   string
	Timeout int
}

func (s Summarizer) Summarize(text string, maxChars int, kind string) (string, error) {
	raw, err := s.Client.Generate(context.Background(), GenerateOptions{
		Model: s.Model,
		Messages: []Message{
			{Role: "system", Content: "あなたは要約器。事実のみ。"},
			{Role: "user", Content: text},
		},
		TimeoutMs: s.Timeout,
	})
	if err != nil {
		return "", err
	}
	out := strings.TrimSpace(raw)
	if len(out) > maxChars {
		out = out[:maxChars]
	}
	return out, nil
}
```

---

## 4) 使用例

```go
policy := materials.DefaultPolicy()
redactor := materials.MakeSimpleRedactor([]string{"xoxb-", "xapp-", "sk-", "AKIA"})
prepared := materials.Prepare(items, policy, llmSummarizer, redactor)
materialsNote := materials.BuildMaterialsSystemNote(prepared.MaterialsText)
```
