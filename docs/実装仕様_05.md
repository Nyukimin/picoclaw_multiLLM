了解、れん。ここは **「会話LLMに渡す materials を“壊れにくく・溢れにくく”整形する」**ための、コピペ可能な実装セットを出すね。
ポイントは3つだけ：

* **サイズ制限**：総量・1アイテム・diff を別で上限管理
* **要約**：長いものは（任意で）推論LLMに要約させて縮める
* **diff扱い**：巨大diffは「ファイル一覧＋要点＋部分diff」に落とす

---

## 1) `src/core/materialsPolicy.ts`（ポリシー定義）

```ts
// src/core/materialsPolicy.ts
import type { Route } from "../types/worker";

export type MaterialsPolicy = {
  // materials全体の上限（会話LLMに入れる総文字数）
  maxTotalChars: number;

  // 各materialの上限（diff以外）
  maxItemChars: number;

  // diff専用上限
  maxDiffChars: number;
  maxDiffLines: number;

  // 長文を要約する閾値
  summarizeThresholdChars: number;

  // 重要度：溢れたら低優先を落とす
  routePriority: Record<Route, number>;

  // "result" が object のときの stringify 上限
  maxJsonChars: number;

  // truncation 表示
  truncationMarker: string;
};

export const defaultMaterialsPolicy: MaterialsPolicy = {
  maxTotalChars: 16000,
  maxItemChars: 3500,

  maxDiffChars: 7000,
  maxDiffLines: 220,

  summarizeThresholdChars: 2800,

  routePriority: {
    CODE: 100,
    OPS: 90,
    ANALYZE: 80,
    PLAN: 70,
    RESEARCH: 60,
    CHAT: 50
  },

  maxJsonChars: 6000,
  truncationMarker: "\n...(truncated)\n"
};
```

---

## 2) `src/core/materials.ts`（整形ロジック本体）

```ts
// src/core/materials.ts
import type { WorkerInput, WorkerOutput, Route } from "../types/worker";
import type { MaterialsPolicy } from "./materialsPolicy";
import { defaultMaterialsPolicy } from "./materialsPolicy";

/**
 * LoopControllerが集めた「素材」1単位
 * - meta は WorkerOutput（needs_next_loop等）を保持
 * - result は meta.result と同じでもOK（使いやすい方で）
 */
export type MaterialItem = {
  route: Route;
  meta: WorkerOutput;
  // 失敗時などのメモ
  error?: string;
  // そのまま表示する用（任意）
  result?: any;
};

export type PreparedMaterials = {
  // 会話LLMにそのまま入れるテキスト（推奨）
  materialsText: string;

  // 追加で渡したい構造（任意）
  materialsBrief: Array<{
    route: Route;
    risk: string;
    confidence: number;
    needs_next_loop: boolean;
  }>;

  // materialsTextに入れられなかった（落とした）要素
  dropped: Array<{ route: Route; reason: string }>;
};

export type Summarizer = (args: {
  text: string;
  maxChars: number;
  kind: "generic" | "diff" | "json";
}) => Promise<string>;

export type Redactor = (text: string) => string;

export function makeSimpleRedactor(patterns: string[] = []): Redactor {
  // 文字列パターンを単純置換（本格的にやるならregex対応へ）
  return (text: string) => {
    let t = text ?? "";
    for (const p of patterns) {
      if (!p) continue;
      // token prefix みたいなものは "***" 置換
      t = t.split(p).join("***");
    }
    // PEMキーらしきブロックは丸ごと潰す
    t = t.replace(/-----BEGIN[\s\S]*?-----END[\s\S]*?-----/g, "***");
    return t;
  };
}

/** object をそれっぽく短く stringify（巨大化を防ぐ） */
function safeStringify(obj: any, maxChars: number, marker: string): string {
  try {
    const s = JSON.stringify(obj, null, 2);
    if (s.length <= maxChars) return s;
    return s.slice(0, maxChars) + marker;
  } catch {
    return String(obj);
  }
}

/** diffっぽさ検知 */
function extractUnifiedDiffFromResult(result: any): string | null {
  if (!result) return null;
  if (typeof result === "string") {
    if (result.includes("diff --git") || result.includes("@@ ")) return result;
    return null;
  }
  if (typeof result === "object") {
    if (typeof result.patch_unified === "string" && result.patch_unified.trim().length > 0) {
      return result.patch_unified;
    }
    // files の中に diff を持たせる実装もあり得るので保険
    if (Array.isArray(result.files)) {
      const maybe = result.files.find((f: any) => typeof f?.patch_unified === "string");
      if (maybe?.patch_unified) return maybe.patch_unified;
    }
  }
  return null;
}

/** diffからファイル一覧を抜く（雑でOK。精度より頑丈さ） */
function diffFileList(diff: string): string[] {
  const files: string[] = [];
  const re = /^diff --git a\/(.+?) b\/(.+?)$/gm;
  let m: RegExpExecArray | null;
  while ((m = re.exec(diff)) !== null) {
    const a = m[1];
    const b = m[2];
    files.push(b || a);
    if (files.length >= 50) break;
  }
  return files;
}

/** diffの行数ざっくり増減カウント（+/-行） */
function diffStat(diff: string): { plus: number; minus: number } {
  let plus = 0;
  let minus = 0;
  const lines = diff.split("\n");
  for (const line of lines) {
    if (line.startsWith("+++ ") || line.startsWith("--- ")) continue;
    if (line.startsWith("+")) plus++;
    else if (line.startsWith("-")) minus++;
  }
  return { plus, minus };
}

/**
 * unified diff を上限に収める
 * - まず行数カット
 * - 次に文字数カット
 */
function truncateDiff(diff: string, policy: MaterialsPolicy): { text: string; truncated: boolean } {
  let truncated = false;

  const lines = diff.split("\n");
  if (lines.length > policy.maxDiffLines) {
    truncated = true;
    diff = lines.slice(0, policy.maxDiffLines).join("\n") + policy.truncationMarker;
  }

  if (diff.length > policy.maxDiffChars) {
    truncated = true;
    diff = diff.slice(0, policy.maxDiffChars) + policy.truncationMarker;
  }

  return { text: diff, truncated };
}

/** diffを「ダイジェスト＋一部」へ落とす */
async function digestDiff(args: {
  diff: string;
  policy: MaterialsPolicy;
  summarizer?: Summarizer;
}): Promise<{ text: string; truncated: boolean }> {
  const { diff, policy, summarizer } = args;

  const files = diffFileList(diff);
  const st = diffStat(diff);

  // まず diff 本体を切る
  const t = truncateDiff(diff, policy);

  // 長いなら要約（任意）
  let summary = "";
  if (summarizer && diff.length > policy.summarizeThresholdChars) {
    try {
      summary = await summarizer({
        text: diff,
        maxChars: Math.min(900, policy.maxItemChars),
        kind: "diff"
      });
    } catch {
      summary = "";
    }
  }

  const header =
    `DiffDigest:\n` +
    `- files(${files.length}): ${files.slice(0, 10).join(", ")}${files.length > 10 ? " ..." : ""}\n` +
    `- approx: +${st.plus} / -${st.minus}\n`;

  const summaryBlock = summary ? `DiffSummary:\n${summary}\n` : "";

  const body = `DiffSnippet:\n${t.text}`;

  return { text: header + summaryBlock + body, truncated: t.truncated || !!summary };
}

/**
 * result を materials に載せる “表示テキスト” にする
 * - diff は特別扱い
 * - object は safeStringify
 * - string は長さ制限＆必要なら要約
 */
async function renderResult(args: {
  input: WorkerInput;
  item: MaterialItem;
  policy: MaterialsPolicy;
  summarizer?: Summarizer;
  redactor: Redactor;
}): Promise<{ text: string; truncated: boolean }> {
  const { input, item, policy, summarizer, redactor } = args;
  const meta = item.meta;
  const rawResult = item.result ?? meta.result;

  // diff
  const diff = extractUnifiedDiffFromResult(rawResult);
  if (diff) {
    const dig = await digestDiff({ diff, policy, summarizer });
    return { text: redactor(dig.text), truncated: dig.truncated };
  }

  // non-diff
  let text: string;
  if (typeof rawResult === "string") text = rawResult;
  else text = safeStringify(rawResult, policy.maxJsonChars, policy.truncationMarker);

  text = redactor(text);

  let truncated = false;

  // 長すぎるなら要約（任意）
  if (summarizer && text.length > policy.summarizeThresholdChars) {
    try {
      const summarized = await summarizer({
        text,
        maxChars: Math.min(policy.maxItemChars, 1200),
        kind: typeof rawResult === "string" ? "generic" : "json"
      });
      text = redactor(summarized);
      truncated = true; // 要約したら “圧縮した” 扱いにしておく
    } catch {
      // 要約失敗時は切る
    }
  }

  // それでも長いなら切る
  if (text.length > policy.maxItemChars) {
    truncated = true;
    text = text.slice(0, policy.maxItemChars) + policy.truncationMarker;
  }

  return { text, truncated };
}

/** material 1本を会話LLM向けのブロックにする（内部用） */
function formatMaterialBlock(args: {
  item: MaterialItem;
  rendered: { text: string; truncated: boolean };
}): string {
  const { item, rendered } = args;
  const m = item.meta;

  const metaLine =
    `meta: risk=${m.risk} conf=${m.confidence.toFixed(2)} needs_next_loop=${m.needs_next_loop}` +
    (m.fit === false ? ` fit=false suggested=${m.suggested_route}` : "") +
    (item.error ? ` error=${item.error}` : "") +
    (rendered.truncated ? ` truncated=true` : "");

  return [
    `=== MATERIAL[${item.route}] ===`,
    metaLine,
    rendered.text.trim(),
    `=== /MATERIAL ===`
  ].join("\n");
}

/**
 * 重要度順に並べて、maxTotalChars に収める
 * - 溢れたら「低優先」から落とす
 * - 落とした理由も返す
 */
export async function prepareMaterialsForChatLLM(args: {
  input: WorkerInput;
  items: MaterialItem[];
  policy?: MaterialsPolicy;
  summarizer?: Summarizer;   // 任意（推論LLMで実装）
  redactor?: Redactor;       // 任意（未指定ならsecurity.redact_patternsから作る）
}): Promise<PreparedMaterials> {
  const policy = args.policy ?? defaultMaterialsPolicy;

  const redactor =
    args.redactor ??
    makeSimpleRedactor(args.input.security?.redact_patterns ?? args.input.security?.redact_patterns ?? []);

  // priority でソート（高いほど先）
  const sorted = [...args.items].sort((a, b) => {
    const pa = policy.routePriority[a.route] ?? 0;
    const pb = policy.routePriority[b.route] ?? 0;
    // 同点なら “後からのもの” を優先しがち（最後のループが新しい想定）
    return pb - pa;
  });

  const blocks: string[] = [];
  const brief: PreparedMaterials["materialsBrief"] = [];
  const dropped: PreparedMaterials["dropped"] = [];

  let total = 0;

  // まず全件レンダリング（ただし総量制限で落とす）
  for (const item of sorted) {
    const rendered = await renderResult({
      input: args.input,
      item,
      policy,
      summarizer: args.summarizer,
      redactor
    });

    const block = formatMaterialBlock({ item, rendered });
    const size = block.length + 2;

    // 入らない場合は落とす（低優先から順に来てるのでこの時点では落とすしかない）
    if (total + size > policy.maxTotalChars) {
      dropped.push({ route: item.route, reason: "maxTotalChars exceeded" });
      continue;
    }

    blocks.push(block);
    total += size;

    brief.push({
      route: item.route,
      risk: item.meta.risk,
      confidence: item.meta.confidence,
      needs_next_loop: item.meta.needs_next_loop
    });
  }

  const materialsText = blocks.join("\n\n");

  return {
    materialsText,
    materialsBrief: brief,
    dropped
  };
}

/**
 * 会話LLM に渡す messages を作るときの “materials message” の推奨フォーマット
 * - 会話LLMへは「内部素材」であることを明示
 * - ユーザーに見せる文章は会話LLMが生成する
 */
export function buildMaterialsSystemNote(materialsText: string): string {
  return [
    "You are the chat-facing model. The following MATERIAL blocks are internal working materials from background workers.",
    "Rules:",
    "- Do NOT expose internal markers like 'MATERIAL' to the user.",
    "- Do NOT mention cloud/local routing or internal model names unless the user explicitly asks.",
    "- Use materials as evidence. If something is truncated or uncertain, say so briefly.",
    "- Prefer concise, actionable output.",
    "",
    materialsText
  ].join("\n");
}
```

---

## 3) `src/llm/summarizer.ts`（要約を推論LLMに投げる：任意）

> これを使うと「長すぎるresult」や「巨大diff」を、**会話LLMに入れる前に圧縮**できる。
> 使わないなら `summarizer` を渡さなければOK（単純truncateだけで動く）。

```ts
// src/llm/summarizer.ts
import type { LLMClient } from "./llmClient";

export function makeSummarizer(params: {
  client: LLMClient;     // 推論LLM（Ollama）
  model: string;
  timeoutMs: number;
}) {
  return async (args: { text: string; maxChars: number; kind: "generic" | "diff" | "json" }) => {
    const kindHint =
      args.kind === "diff"
        ? "This is a unified diff. Summarize changes: files, intent, risky parts."
        : args.kind === "json"
        ? "This is JSON-like structured output. Summarize key fields and decisions."
        : "This is general text. Summarize key points and next steps.";

    const system = [
      "You are a strict summarizer for internal materials compression.",
      "Output plain text only (no JSON).",
      `Max length: ${args.maxChars} chars.`,
      "No speculation. Keep only actionable facts.",
      kindHint
    ].join("\n");

    const user = args.text;

    const raw = await params.client.generate({
      model: params.model,
      messages: [
        { role: "system", content: system },
        { role: "user", content: user }
      ],
      timeoutMs: params.timeoutMs,
      temperature: 0.0
    });

    // ざっくり安全：maxChars を強制
    const s = (raw ?? "").trim();
    return s.length <= args.maxChars ? s : s.slice(0, args.maxChars);
  };
}
```

---

## 4) 使い方（Orchestrator 側の最小例）

```ts
import { prepareMaterialsForChatLLM, buildMaterialsSystemNote } from "../core/materials";
import { makeSummarizer } from "../llm/summarizer";

// items: LoopControllerが集めた MaterialItem[]
// reasonClient: 推論LLM用クライアント（Ollama）
// chatClient: 会話LLM用クライアント（Ollama等）

const summarizer = makeSummarizer({
  client: reasonClient,
  model: process.env.OLLAMA_REASON_MODEL ?? "qwen3-thinking-q4",
  timeoutMs: 8000
});

const prepared = await prepareMaterialsForChatLLM({
  input,
  items,
  summarizer // 要らなければ外す
});

const materialsSystemNote = buildMaterialsSystemNote(prepared.materialsText);

// chatClient.generate(...) の messages に入れる例
const chatRaw = await chatClient.generate({
  model: process.env.OLLAMA_CHAT_MODEL ?? "qwen2.5:7b",
  messages: [
    { role: "system", content: materialsSystemNote },
    { role: "user", content: input.user_text }
  ],
  timeoutMs: 12000,
  temperature: 0.4
});
```

---

## 5) ルール（コードの挙動まとめ：仕様として読める形）

* **diff**：`patch_unified` もしくは `diff --git` を検知 →
  `files/±行数` のダイジェスト＋（必要なら）要約＋部分diff
* **非diff**：

  * string：要約（任意）→ `maxItemChars` でtruncate
  * object：`JSON.stringify`（`maxJsonChars` まで）→要約（任意）→truncate
* **総量**：`maxTotalChars` を超えたら **低優先からdrop**（CODE/OPS優先）
* **秘匿**：`redact_patterns` と PEMブロックは常に `***` 化（最低限）

---

このまま進めるなら、次は「会話LLMに渡す system prompt（人格・宣言・素材の使い方・“何をするか”だけ言う）」を、れんの会話ルールに合わせて固定化するのが一番効く。
