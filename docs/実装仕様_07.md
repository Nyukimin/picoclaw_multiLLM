了解、れん。その設計、かなり筋がいい。
ポイントは「**固定（人格）**」と「**可変（運用ルール・宣言・素材の使い方）**」を分離して、可変側は **システムが組み立てる**、ここに寄せるのが安定する。

注意点を1つだけ先に言うね。
**会話LLM自身が system prompt を“書き換える”ことはできない**（API的に system はアプリ側が渡すもの）。
だから「指示によって適宜会話LLMが加筆する」は、実装としてはこう解釈すると綺麗：

* **会話LLMは“加筆案（patch提案）”を出す**（メタ出力）
* **採用・永続化・次ターン適用はシステムがやる**（明示コマンド or allowlistで）

この形だと、人格が勝手に崩れないし、再現性も出る。

---

# 提案する構造（ファイル化＋レイヤ）

## 1) ファイル構成（例）

```
/prompts
  /chat
    persona.md                 # 個性・口調・一人称/二人称など（固定）
    policy.md                  # 素材の扱い/宣言/禁止事項（固定）
    overlays/
      default.md               # いつも付ける軽い補足（任意）
      slack.md                 # Slack向け差分（任意）
      line.md                  # LINE向け差分（任意）
      local_only.md            # /local 時の追加制約（任意）
      route_code.md            # CODE時の追加制約（任意）
      route_ops.md             # OPS時…
```

* `persona.md` は“個性”だけ（ここが最重要の固定資産）
* `policy.md` は“運用ルール”だけ（素材の使い方・宣言・内部情報の隠し方）
* overlay は「条件付きで付ける小片」。差分管理がしやすい

## 2) system messages のレイヤ順（推奨）

会話LLMに渡す system は、**1個の巨大テキストに連結**でもいいけど、デバッグしやすさ的には「複数 system message」を推す。

順番はこれが堅い：

1. persona（個性）
2. policy（素材の扱い・禁止事項・宣言規則）
3. overlay（channel/route/local_only など条件付き）
4. materials note（`buildMaterialsSystemNote(...)` で作る内部素材）

宣言（「コーディングするね。」等）は **LLMに任せずシステムが先頭へ確定挿入**が安全。
（LLMに渡しても省略される事故がある）

---

# コピペ：PromptManager（読み込み＋組み立て）

## `src/core/promptManager.ts`

```ts
// src/core/promptManager.ts
import fs from "fs";
import path from "path";

export type ChannelKind = "slack" | "line";
export type Route = "CHAT" | "PLAN" | "ANALYZE" | "OPS" | "RESEARCH" | "CODE";

export type PromptPaths = {
  baseDir: string; // e.g. /prompts/chat
  personaFile: string; // persona.md
  policyFile: string;  // policy.md
  overlaysDir: string; // overlays/
};

export type PromptBuildContext = {
  channel: ChannelKind;
  route: Route;
  local_only: boolean;
};

export type BuiltSystemPrompts = {
  // system message の配列（上から順に）
  systemMessages: string[];
};

function readText(filePath: string): string {
  return fs.readFileSync(filePath, "utf8");
}

function tryReadText(filePath: string): string | null {
  try {
    if (!fs.existsSync(filePath)) return null;
    return readText(filePath);
  } catch {
    return null;
  }
}

function overlayFileName(ctx: PromptBuildContext): string[] {
  // 付けたい overlay を順番に列挙（存在しなければ無視される）
  const list: string[] = [];
  list.push("default.md");
  list.push(`${ctx.channel}.md`);
  if (ctx.local_only) list.push("local_only.md");
  list.push(`route_${ctx.route.toLowerCase()}.md`);
  return list;
}

export class PromptManager {
  private cache = new Map<string, string>();
  constructor(private readonly paths: PromptPaths) {}

  // 変更多いならキャッシュ、不要なら毎回readでもOK
  private loadCached(absPath: string): string {
    const hit = this.cache.get(absPath);
    if (hit != null) return hit;
    const txt = readText(absPath);
    this.cache.set(absPath, txt);
    return txt;
  }

  // ホットリロードしたい場合
  clearCache() {
    this.cache.clear();
  }

  buildSystemPrompts(ctx: PromptBuildContext): BuiltSystemPrompts {
    const base = this.paths.baseDir;

    const persona = this.loadCached(path.join(base, this.paths.personaFile));
    const policy = this.loadCached(path.join(base, this.paths.policyFile));

    const overlays: string[] = [];
    const names = overlayFileName(ctx);
    for (const n of names) {
      const p = path.join(base, this.paths.overlaysDir, n);
      const t = tryReadText(p);
      if (t) overlays.push(t);
    }

    const systemMessages = [
      `# persona\n${persona}`,
      `# policy\n${policy}`,
      ...(overlays.length ? [`# overlays\n${overlays.join("\n\n")}`] : [])
    ];

    return { systemMessages };
  }
}
```

---

# コピペ：宣言の確定挿入（LLMに任せない）

宣言は「ルート切替時だけ1行」って仕様だったから、**Orchestrator側で reply の先頭に連結**が一番事故らない。

## `src/core/declaration.ts`

```ts
// src/core/declaration.ts
import type { Route } from "../types/worker";

const map: Record<Route, string | null> = {
  CODE: "コーディングするね。",
  ANALYZE: "整理して分析するね。",
  PLAN: "段取りを組むね。",
  OPS: "手順で案内するね。",
  RESEARCH: "調べてまとめるね。",
  CHAT: null
};

export function buildDeclaration(prev: Route | null, cur: Route): string {
  if (!prev || prev !== cur) return map[cur] ?? "";
  return "";
}

// 会話LLMの出力に確定で足す
export function prependDeclaration(declaration: string, finalText: string): string {
  if (!declaration) return finalText;
  // 同じ宣言をLLMが書いちゃった時の重複防止（雑でOK）
  if (finalText.startsWith(declaration)) return finalText;
  return `${declaration}\n${finalText}`;
}
```

---

# 「会話LLMが加筆する」を安全に実現する方法（おすすめ）

れんの意図は「個性はファイルで固定しつつ、状況に合わせて“ちょい足し”したい」だと思う。
その場合は、LLMに system を直接いじらせず、次のどちらかが堅い。

## A) overlay をシステムが選ぶ（推奨）

* `/tone polite` みたいな明示コマンドで overlay を差し替える
* ルートや channel で自動 overlay を付ける（さっきの実装）

## B) LLMは “patch提案” を返す（採用はシステム）

会話LLMの出力に **メタJSON** を混ぜる設計にして、

* `prompt_patch_proposal: { overlay_to_enable: "...", reason: "..." }`

みたいに提案させる。
採用は **明示コマンドが来た時だけ**、とかにすれば人格が暴走しない。

---

# 最後に：この設計で守れること

* **人格（persona.md）が壊れない**
* **素材の扱い（policy.md）が統一される**
* 「何をするか」宣言は **システム確定**で省略事故がなくなる
* “加筆”は overlay / patch提案で **変更履歴が残る**

次の一手としては、`persona.md` と `policy.md` の **叩き台（コピペ版）**をこっちで出して、れんの会話ルールに合わせて固定化するのが速い。
