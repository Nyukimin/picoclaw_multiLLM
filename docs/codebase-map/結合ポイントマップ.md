---
generated_at: 2026-02-28T17:40:00+09:00
run_id: run_20260228_170007
phase: 1
step: "7"
profile: picoclaw_multiLLM
artifact: integration_map
---

# モジュール結合ポイントマップ

## 概要

PicoClaw は階層化アーキテクチャを採用し、基盤層（infra）、ドメイン層（session/providers/approval）、制御層（agent）、拡張層（mcp）が明確に分離されている。データフローは主に Agent Loop を中心に構成され、セッション永続化、LLM 呼び出し、承認フロー、ログ出力が各モジュール間で連携する。

## 関連ドキュメント

- プロファイル: codebase-analysis-profile.yaml
- 各モジュール解析: modules/*.md

---

## アーキテクチャ階層図

```
┌────────────────────────────────────────────────────────────┐
│ インターフェース層                                          │
│  ├─ channels (LINE/Slack/Telegram)                         │
│  └─ bus (メッセージバス)                                   │
└────────────────────────────────────────────────────────────┘
                         ↓ リクエスト受信
┌────────────────────────────────────────────────────────────┐
│ 制御層 (agent)                                              │
│  ├─ router      - ルーティング決定（明示コマンド→辞書→分類器）│
│  ├─ loop        - エージェントループ（LLM呼び出し・承認管理）  │
│  ├─ context     - コンテキスト構築（システムプロンプト）      │
│  └─ classifier  - LLMベース分類器                           │
└────────────────────────────────────────────────────────────┘
       ↓ LLM呼び出し    ↓ セッション管理    ↓ 承認フロー
┌────────────────────────────────────────────────────────────┐
│ ドメイン層                                                  │
│  ├─ providers  - LLM統合（Ollama/Claude/OpenAI/DeepSeek）   │
│  ├─ session    - セッション管理（日次カットオーバー）        │
│  └─ approval   - 承認フロー（job_id追跡・Auto-Approve）     │
└────────────────────────────────────────────────────────────┘
                         ↓ ログ・設定
┌────────────────────────────────────────────────────────────┐
│ 基盤層 (infra)                                              │
│  ├─ logger     - 構造化ログ（全モジュールで使用）           │
│  └─ config     - 設定管理（起動時読み込み）                 │
└────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────┐
│ 拡張層                                                      │
│  └─ mcp        - MCP統合（Chrome DevTools Protocol）        │
│                  ※Phase 5-B 完了、Phase 5-C 未着手          │
└────────────────────────────────────────────────────────────┘
```

---

## モジュール間依存関係マトリクス

### 凡例
- **→**: 呼び出し（依存）
- **⇄**: 双方向参照
- **[*]**: 全モジュールから使用

### 依存関係サマリー

| 依存元モジュール | 依存先モジュール | 結合度 | 結合ポイント |
|------------------|------------------|--------|-------------|
| **core** (cmd/picoclaw/main.go) | agent, providers, logger, config | 強 | エントリポイント、サービス初期化 |
| **agent/loop** | session, providers, approval, logger, config, mcp | 強 | エージェントループの中心ハブ |
| **agent/router** | session, logger, config | 中 | ルーティング決定、フラグ参照 |
| **agent/context** | logger | 弱 | システムプロンプト構築 |
| **agent/classifier** | providers, logger, config | 中 | LLM ベース分類器 |
| **providers** | config, auth, logger | 強 | LLM プロバイダー設定・認証 |
| **session** | providers | 弱 | Message 型定義（providers.Message） |
| **approval** | - | なし | 標準ライブラリのみ |
| **mcp** | - | なし | 標準ライブラリのみ |
| **logger** [*] | - | なし | 全モジュールから使用される基盤 |
| **config** [*] | - | なし | 起動時に読み込まれる設定 |

---

## 主要な結合ポイント詳細

### 1. Agent Loop → Session（セッション管理）

**結合ポイント**: `AgentLoop.sessionManager *session.Manager`

**呼び出しパターン**:
- `GetOrCreate(channel, chatID)` - セッション取得または作成
- `AddMessage(key, role, content)` - メッセージ履歴追加
- `GetFlags(key)` / `SetFlags(key, flags)` - セッションフラグ管理
- `Save(key)` - セッション永続化
- `ResetSession(key)` - 日次カットオーバー時のリセット

**データフロー**:
```
リクエスト受信 → GetOrCreate → メッセージ履歴取得
              ↓
         LLM 呼び出し
              ↓
         AddMessage → Save → JSON 永続化
              ↓
    日次カットオーバー（04:00 JST）
              ↓
    SaveDailyNoteForDate → ResetSession
```

**重要な落とし穴**:
- ResetSession は Messages/Summary をクリアするが、**Flags は保持**
- 04:00 JST より前の活動は「前日」扱い（`GetLogicalDate`）

---

### 2. Agent Loop → Providers（LLM 呼び出し）

**結合ポイント**: `AgentLoop` 内で `providers.CreateProvider()` による動的生成

**ルート別プロバイダー切り替え**:
| ルート | プロバイダー | モデル例 |
|--------|-------------|---------|
| CHAT | Ollama | ollama/chat-v1:latest |
| WORKER | Ollama | ollama/worker-v1:latest |
| CODE1 | DeepSeek | deepseek-chat |
| CODE2 | OpenAI | gpt-4 |
| CODE3 | Claude API | claude-sonnet-4.5 |

**呼び出しパターン**:
- `provider.Chat(ctx, messages, tools)` - LLM 呼び出し
- `OllamaProvider` のみ: `keep_alive: -1` で常駐化

**データフロー**:
```
ルート決定（router.go） → CreateProvider（ルート別）
                        ↓
                   LLM 呼び出し（provider.Chat）
                        ↓
                   応答受信・ツール実行
                        ↓
                   session.AddMessage → 永続化
```

**重要な落とし穴**:
- Ollama MaxContext 制約（8192 超過時クラッシュ）
- タイムアウト後も Ollama 側が処理継続する可能性

---

### 3. Agent Loop → Approval（承認フロー）

**結合ポイント**: `AgentLoop.approvalMgr *approval.Manager`

**呼び出しパターン**:
- `CreateJob(plan, patch, risk)` - Coder3 出力後のジョブ作成
- `GetJob(jobID)` - 承認コマンド処理時のジョブ取得
- `Approve(jobID)` / `Deny(jobID)` - `/approve`, `/deny` コマンド処理

**データフロー**:
```
Coder3 (CODE3 ルート) → plan/patch/risk 生成
                       ↓
                  CreateJob（job_id 発行）
                       ↓
                  session.SetFlags(PendingApprovalJobID)
                       ↓
                  承認要求メッセージ生成
                       ↓
     ユーザーが /approve または /deny
                       ↓
     Approve/Deny（ステータス更新）
                       ↓
     Worker 実行委譲（※未実装）
```

**重要な落とし穴**:
- **Auto-Approve は未実装**（コード定義のみ）
- 破壊的操作の自動検出なし（LLM の `risk` フィールドに依存）
- In-Memory 実装（プロセス再起動でジョブ情報消失）

---

### 4. Agent Router → Session（ルーティング判定）

**結合ポイント**: `Router` が `session.GetFlags()` でフラグ参照

**呼び出しパターン**:
- `GetFlags(key)` - LocalOnly, PrevPrimaryRoute フラグ取得
- `SetFlags(key, flags)` - フラグ更新（`/local` コマンド処理）

**データフロー**:
```
ルーティング判定 → GetFlags(LocalOnly)
                 ↓
         /local モード時は CODE ルートを拒否
                 ↓
         GetFlags(PrevPrimaryRoute)
                 ↓
         前回ルートを参考に再ルーティング判定
```

**重要な落とし穴**:
- `/local` モード時は CODE ルートが強制的に CHAT にフォールバック

---

### 5. Providers → Config/Auth/Logger（横断的依存）

**結合ポイント**: 全 LLM プロバイダーが共通して依存

**呼び出しパターン**:
- **config**: `GetProviderConfig(provider)` - API キー、API Base、モデル設定取得
- **auth**: `GetCredential(account)`, `RefreshAccessToken()` - OAuth トークン管理
- **logger**: `InfoCF`, `WarnCF`, `ErrorCF` - 構造化ログ出力

**データフロー**:
```
CreateProvider → config.GetProviderConfig
               ↓
          API キー・API Base 取得
               ↓
          OAuth 使用時: auth.GetCredential
               ↓
          provider.Chat 呼び出し
               ↓
          logger.InfoCF（LLM 呼び出しログ）
```

---

### 6. MCP → Agent Loop（未統合）

**結合ポイント**: `AgentLoop.mcpClient *mcp.Client`

**現在のステータス**:
- ✅ **完了**: MCP クライアント初期化（`cfg.MCP.Chrome.Enabled == true` 時）
- ⚠️ **未完了**: 実際のブラウザ操作実行ロジック

**計画されているデータフロー**（Phase 5-C）:
```
Coder3 → uses_browser: true 設定
       ↓
  CreateJob（UsesBrowser フラグ）
       ↓
  承認要求（ブラウザ操作の警告表示）
       ↓
  承認後 → Worker が patch パース
       ↓
  mcpClient.ChromeNavigate/Click/Screenshot
       ↓
  実行結果ログ記録
```

**重要な落とし穴**:
- 外部依存（Win11 の mcp-chrome-bridge が停止すると機能全体が使用不可）
- タイムアウト固定（config.TimeoutSec が実際には使われていない）

---

## 循環依存の回避

PicoClaw では以下の設計原則により循環依存を回避しています：

1. **基盤層（logger, config）は他パッケージに依存しない**
   - logger, config は標準ライブラリのみで完結
   - 全モジュールから参照されるが、逆参照なし

2. **ドメイン層（session, providers, approval）は基盤層のみに依存**
   - approval は標準ライブラリのみ
   - session は providers.Message 型のみ参照（弱結合）
   - providers は config, auth, logger のみ参照

3. **制御層（agent）はドメイン層と基盤層に依存**
   - agent が全体のハブとして機能
   - ドメイン層モジュールは agent を参照しない

---

## 変更時の影響度マトリクス

| モジュール | 影響範囲 | 影響度 | 注意事項 |
|-----------|---------|--------|----------|
| **logger** | 全モジュール | 高 | ログイベント種別追加時は全モジュールで使用可能 |
| **config** | 全モジュール | 高 | 設定構造体変更時はデフォルト値・バリデーション更新必須 |
| **session** | agent/loop, agent/router, channels | 中 | SessionFlags 追加時は agent/loop で処理ロジック追加 |
| **providers** | agent/loop, agent/classifier | 中 | プロバイダー追加時は CreateProvider で分岐追加 |
| **approval** | agent/loop | 中 | Auto-Approve 実装時は Chrome 操作を対象外にすること |
| **agent** | 全体 | 高 | ルート定数追加時は 5 箇所更新必須 |
| **mcp** | agent/loop | 低（現状） | Phase 5-C 実装後は中程度に上昇 |

---

## 今後の統合予定

### Phase 5-C: MCP 実行ロジック統合

1. Coder3 が `uses_browser: true` を設定する仕組み実装
2. Worker が patch から Chrome コマンドをパースする実装
3. mcpClient 呼び出しと実行結果ログ記録
4. Chrome 操作の Auto-Approve 対象外化（強制承認）

### Phase X: Auto-Approve 実装

1. Scope/TTL 判定ロジック実装
2. Chrome 操作の例外処理（強制承認）
3. 承認履歴の永続化（in-memory → DB/ファイル）

### Phase Y: 承認後の Worker 実行委譲

1. Coder3 の plan/patch を Worker に渡す機構
2. Worker による patch 適用（ファイル編集・コマンド実行）
3. 実行結果の Chat へのフィードバック

---

## 補足: ログイベント種別と結合ポイント

| イベント種別 | 発生モジュール | ログ出力箇所 |
|-------------|--------------|------------|
| `router.decision` | agent/router | ルーティング決定時 |
| `classifier.error` | agent/classifier | 分類器エラー時 |
| `worker.success` / `worker.fail` | agent/loop | Worker 実行結果 |
| `approval.requested` | agent/loop | Coder3 出力後 |
| `approval.granted` / `approval.denied` | agent/loop | 承認コマンド処理後 |
| `approval.auto_approved` | agent/loop | Auto-Approve 時（未実装） |
| `coder.plan_generated` | agent/loop | Coder による plan/patch 生成 |
| `loop.cutover` | agent/loop | 日次カットオーバー実行時 |

---

## Phase 2 で発見された追加情報

### core モジュール（※Phase 2 で追加）
- **Skills 管理**: GitHub からのスキルインストール、ビルトインスキルコピー
- **Watchdog 設定**: 外部監視プロセス用の設定（実装仕様に記載なし）
- **embed.FS 依存**: ワークスペーステンプレートのバイナリ埋め込み（`go generate` 必須）

### agent モジュール（※Phase 2 で追加）
- **45 種類のログイベント**: router.decision, classifier.error, worker.*, loop.*, approval.*, coder.* など網羅
- **RouteApprove/RouteDeny**: 承認コマンド専用ルート（実装済み）
- **設計書との乖離 5 項目**: Worker 実行委譲、Auto-Approve、再ルーティング、会話LLM提案IF、WorkerInput/Output スキーマ（いずれも未実装）

### approval モジュール（※Phase 2 で追加）
- **cost_hint フィールド未実装**: Coder3 仕様では定義されているが、Job 構造体に存在しない
- **Auto-Approve 完全未実装**: Phase 4-6 で実装予定（実装プラン通り）

### mcp モジュール（※Phase 2 で追加）
- **タイムアウト固定**: `config.MCP.Chrome.TimeoutSec` が未使用、30 秒固定

### infra モジュール（※Phase 2 で追加）
- **マスキング機構の不在確認**: API キー等の自動マスキングは未実装（実装位置確認済み）
- **Caller 情報取得**: `runtime.Caller(2)` でログ出力元を取得
