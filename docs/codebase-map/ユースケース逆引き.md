---
generated_at: 2026-02-28T17:45:00+09:00
run_id: run_20260228_170007
phase: 1
step: "8"
profile: picoclaw_multiLLM
artifact: usecase_reference
---

# ユースケース逆引きリファレンス

## 概要

PicoClaw の 5 つの主要ユースケースを、実装コードに逆引きしてマッピング。各ユースケースのトリガー、処理フロー、関与するモジュール・関数を明示し、変更時の影響範囲を把握可能にする。

## 関連ドキュメント

- プロファイル: codebase-analysis-profile.yaml
- 結合ポイントマップ: 結合ポイントマップ.md
- 各モジュール解析: modules/*.md

---

## UC1: LINE/Slack からの指示受信 → ルーティング → LLM 実行 → 応答返却

### トリガー
- LINE/Slack からユーザーメッセージ受信（Gateway モード）
- `pkg/channels/line/handler.go` または `pkg/channels/slack/handler.go`

### 処理フロー

```
1. メッセージ受信
   ├─ channels/line/handler.go: HandleWebhook()
   └─ bus.Publish(MessageReceived)

2. メッセージバス配信
   └─ pkg/bus/bus.go: messageRouter()
      → agent/loop.go: AgentLoop.HandleMessage()

3. セッション取得/作成
   └─ session.Manager.GetOrCreate(channel, chatID)
      → session.Session{Messages, Flags, ...}

4. ルーティング決定
   ├─ agent/router.go: DetermineRoute()
   │  ├─ 明示コマンド判定（/code, /chat 等）
   │  ├─ ルール辞書マッチング
   │  ├─ 分類器呼び出し（agent/classifier.go）
   │  └─ フォールバック（CHAT）
   └─ 決定ルート（CHAT/WORKER/CODE1/CODE2/CODE3）

5. コンテキスト構築
   └─ agent/context.go: BuildSystemPrompt()
      ├─ ルート別ブートストラップファイル読み込み
      │  └─ CHAT → CHAT_PERSONA.md（最優先）
      ├─ rules/README.md
      ├─ tools 定義
      └─ 長期記憶（MEMORY.md）

6. LLM 呼び出し
   ├─ providers.CreateProvider(ルート別設定)
   │  ├─ CHAT → OllamaProvider (chat-v1)
   │  ├─ CODE3 → AnthropicProvider (claude-sonnet-4.5)
   │  └─ 他ルート → 対応プロバイダー
   └─ provider.Chat(ctx, messages, tools)

7. 応答受信・ツール実行
   ├─ LLM 応答を取得
   ├─ ツール呼び出しがあれば実行
   │  └─ pkg/tools/executor.go
   └─ 最終応答生成

8. セッション永続化
   ├─ session.AddMessage(role=assistant, content)
   └─ session.Save(key)
      → {storage}/<channel>_<chatID>.json

9. 応答返却
   └─ bus.Publish(SendMessage)
      → channels/line/handler.go: sendReply()
```

### 関与するモジュール・関数

| モジュール | ファイル | 関数/メソッド | 役割 |
|-----------|---------|-------------|------|
| **channels/line** | handler.go | HandleWebhook() | LINE メッセージ受信 |
| **bus** | bus.go | Publish(), messageRouter() | メッセージバス配信 |
| **agent** | loop.go | AgentLoop.HandleMessage() | メイン処理ループ |
| **session** | manager.go | GetOrCreate(), AddMessage(), Save() | セッション管理 |
| **agent** | router.go | DetermineRoute() | ルーティング決定 |
| **agent** | classifier.go | ClassifyInput() | LLM ベース分類器 |
| **agent** | context.go | BuildSystemPrompt() | コンテキスト構築 |
| **providers** | provider.go | CreateProvider(), Chat() | LLM プロバイダー |
| **tools** | executor.go | ExecuteTool() | ツール実行 |
| **logger** | logger.go | InfoCF(), WarnCF() | 構造化ログ |

### 変更影響範囲

- **新チャネル追加**: `pkg/channels/<new>/handler.go` 追加、bus メッセージ型定義
- **新ルート追加**: router.go, context.go, providers.CreateProvider で分岐追加
- **新ツール追加**: tools/ にツール実装、context.go で ToolDefinition 追加

---

## UC2: Coder3 による plan/patch 生成 → 承認要求 → 承認後に Worker が実行

### トリガー
- CODE3 ルートでの LLM 呼び出し（Coder3: Claude API）
- `/code3` 明示コマンドまたは分類器による CODE3 判定

### 処理フロー

```
1. CODE3 ルート決定
   └─ router.DetermineRoute() → CODE3

2. Coder3 呼び出し
   ├─ providers.CreateProvider("anthropic", "claude-sonnet-4.5")
   └─ provider.Chat() → LLM 応答

3. plan/patch/risk の解析
   ├─ agent/loop.go: 応答テキストをパース
   │  ├─ plan: 実装計画（Markdown）
   │  ├─ patch: 差分（unified diff 形式）
   │  └─ risk: リスク情報（JSON）
   └─ 破壊的操作の判定（risk フィールド）

4. 承認ジョブ作成
   ├─ approval.Manager.CreateJob(plan, patch, risk)
   │  └─ job_id 発行（YYYYMMDD-HHMMSS-xxxxxxxx）
   ├─ approval.Job{
   │     ID: job_id,
   │     Status: StatusPending,
   │     Plan: plan,
   │     Patch: patch,
   │     Risk: risk,
   │     UsesBrowser: false,  # ※未実装
   │     CreatedAt: time.Now()
   │  }
   └─ logger.LogApprovalRequested(job_id, plan)

5. セッションフラグ設定
   └─ session.SetFlags(PendingApprovalJobID: job_id)

6. 承認要求メッセージ生成
   ├─ approval.FormatApprovalRequest(job)
   └─ メッセージ返却（/approve <job_id> または /deny <job_id> を提示）

7. ユーザー承認コマンド受信
   ├─ `/approve <job_id>` または `/deny <job_id>`
   └─ agent/loop.go: HandleMessage()
      → 承認コマンド検出

8. 承認処理
   ├─ approval.Manager.Approve(job_id)
   │  └─ Job.Status = StatusGranted
   ├─ session.SetFlags(PendingApprovalJobID: "")
   └─ logger.LogApprovalGranted(job_id)

9. Worker 実行委譲（※未実装）
   ├─ plan/patch を Worker に渡す
   ├─ Worker が patch 適用（ファイル編集・コマンド実行）
   └─ 実行結果を Chat にフィードバック
```

### 関与するモジュール・関数

| モジュール | ファイル | 関数/メソッド | 役割 |
|-----------|---------|-------------|------|
| **agent** | router.go | DetermineRoute() | CODE3 ルート決定 |
| **providers** | anthropic_provider.go | Chat() | Claude API 呼び出し |
| **agent** | loop.go | （plan/patch パース） | Coder3 出力解析 |
| **approval** | manager.go | CreateJob(), Approve(), Deny() | 承認フロー管理 |
| **approval** | job.go | GenerateJobID() | job_id 発行 |
| **approval** | message.go | FormatApprovalRequest() | 承認要求メッセージ |
| **session** | manager.go | SetFlags(PendingApprovalJobID) | 承認待ちフラグ |
| **logger** | logger.go | LogApprovalRequested(), LogApprovalGranted() | 承認ログ |

### 現在の実装状況

- ✅ **実装済み**: job_id 発行、承認ジョブ作成、承認/拒否処理
- ⚠️ **未実装**:
  - Coder3 の plan/patch パースロジック
  - UsesBrowser フラグの自動設定
  - 承認後の Worker 実行委譲
  - Worker による patch 適用

### 変更影響範囲

- **Auto-Approve 実装時**: approval/manager.go に Scope/TTL 判定追加
- **Worker 実行委譲実装時**: agent/loop.go に Worker 呼び出しロジック追加

---

## UC3: Auto-Approve モード ON → Scope/TTL 内で自動承認 → 即時 OFF

### トリガー
- ユーザーが `/auto-approve scope=read ttl=3600` コマンド送信
- または Chat が自動判断で Auto-Approve 提案

### 処理フロー（計画）

```
1. Auto-Approve コマンド受信
   └─ agent/loop.go: HandleMessage()
      → `/auto-approve` 検出

2. Auto-Approve 設定
   ├─ パラメータ解析（scope, ttl）
   │  ├─ scope: read, write, execute
   │  └─ ttl: 有効期限（秒）
   ├─ approval.Manager.EnableAutoApprove(scope, ttl)
   │  └─ AutoApproveConfig{
   │        Enabled: true,
   │        Scope: scope,
   │        ExpiresAt: time.Now().Add(ttl * time.Second)
   │     }
   └─ logger.InfoCF("Auto-Approve enabled", scope, ttl)

3. 承認ジョブ作成時の自動承認
   ├─ approval.Manager.CreateJob(plan, patch, risk)
   │  ├─ Scope 判定（risk.scope が許可範囲内か）
   │  ├─ TTL 判定（ExpiresAt > time.Now()）
   │  ├─ Chrome 操作は対象外（UsesBrowser == true → 強制承認）
   │  └─ 条件満たす場合:
   │     ├─ Job.Status = StatusAutoApproved
   │     ├─ logger.LogApprovalAutoApproved(job_id)
   │     └─ Worker 実行委譲（即座に実行）
   └─ 条件満たさない場合:
      └─ 通常の承認フロー（UC2）

4. 即時 OFF
   ├─ `/auto-approve off` コマンド受信
   └─ approval.Manager.DisableAutoApprove()
      └─ AutoApproveConfig.Enabled = false
```

### 関与するモジュール・関数（計画）

| モジュール | ファイル | 関数/メソッド | 役割 |
|-----------|---------|-------------|------|
| **agent** | loop.go | （/auto-approve コマンド処理） | Auto-Approve 制御 |
| **approval** | manager.go | EnableAutoApprove(), DisableAutoApprove() | Auto-Approve 設定 |
| **approval** | manager.go | CreateJob() → Scope/TTL 判定 | 自動承認判定 |
| **logger** | logger.go | LogApprovalAutoApproved() | 自動承認ログ |

### 現在の実装状況

- ❌ **未実装**: Auto-Approve 機能全体
- ✅ **定義済み**: `StatusAutoApproved` 定数（approval/job.go）

### 変更影響範囲

- **Auto-Approve 実装時**: approval/manager.go, agent/loop.go, logger/logger.go

---

## UC4: Ollama ヘルスチェック → モデル常駐確認 → 異常時再起動

### トリガー
- LLM 呼び出し前のヘルスチェック（agent/loop.go）
- 定期ヘルスチェック（pkg/heartbeat/）

### 処理フロー

```
1. ヘルスチェック実行
   └─ agent/loop.go: LLM 呼び出し前
      → health.OllamaCheck(cfg.Providers.Ollama.BaseURL)

2. Ollama サーバーステータス確認
   ├─ GET {BaseURL}/api/tags
   │  └─ モデル一覧取得
   └─ health.OllamaModelsCheck(cfg, tags)

3. 常駐モデル確認
   ├─ chat-v1:latest の existence チェック
   ├─ worker-v1:latest の existence チェック
   └─ MaxContext 制約チェック（8192 以下）

4. 異常検出時
   ├─ Ollama サーバー未起動
   │  └─ logger.ErrorCF("Ollama not running")
   │     → Ollama 再起動コマンド実行
   │        └─ config.OllamaRestartCommand
   │           （例: systemctl --user restart ollama）
   │
   ├─ モデル未ロード
   │  └─ logger.WarnCF("Model not loaded")
   │     → Ollama モデルロード
   │        └─ POST {BaseURL}/api/generate
   │           {"model": "chat-v1", "keep_alive": -1}
   │
   └─ MaxContext 超過
      └─ logger.ErrorCF("MaxContext exceeded")
         → 設定ファイル修正を促す

5. リトライ
   ├─ 再起動後、再度ヘルスチェック
   └─ 3回失敗でエラー返却
```

### 関与するモジュール・関数

| モジュール | ファイル | 関数/メソッド | 役割 |
|-----------|---------|-------------|------|
| **agent** | loop.go | （LLM 呼び出し前ヘルスチェック） | ヘルスチェック起動 |
| **health** | checks.go | OllamaCheck(), OllamaModelsCheck() | Ollama 監視 |
| **providers** | ollama_provider.go | （keep_alive: -1 設定） | モデル常駐化 |
| **config** | config.go | OllamaRestartCommand | 再起動コマンド設定 |
| **logger** | logger.go | ErrorCF(), WarnCF() | ヘルスチェックログ |

### 変更影響範囲

- **新モデル追加時**: health/checks.go に existence チェック追加
- **MaxContext 制約変更時**: health/checks.go の閾値更新

---

## UC5: 日次カットオーバー → セッションメモリリセット → 新セッション開始

### トリガー
- 毎日 04:00 JST を境界とした日次カットオーバー（agent/loop.go）
- セッション最終更新時刻が境界を超えた際に実行

### 処理フロー

```
1. カットオーバー判定
   └─ agent/loop.go: maybeDailyCutover(sessionKey)
      ├─ session.GetUpdatedTime(key)
      │  └─ 最終更新時刻取得
      ├─ GetLogicalDate(updatedTime)
      │  └─ 04:00 JST より前は「前日」扱い
      └─ lastLogicalDate != todayLogicalDate
         → カットオーバー実行

2. 日次ノート保存
   └─ agent/memory.go: SaveDailyNoteForDate(date, session)
      ├─ 出力先: workspace/memory/YYYYMM/YYYYMMDD.md
      ├─ Obsidian 形式（Markdown）
      │  ├─ タイトル: YYYY-MM-DD
      │  ├─ タグ: #daily, #picoclaw
      │  └─ 会話サマリー: session.Summary
      ├─ メッセージ履歴: session.Messages
      └─ logger.InfoCF("Daily cutover", date)

3. セッションリセット
   └─ session.Manager.ResetSession(key)
      ├─ session.Messages = []  # クリア
      ├─ session.Summary = ""   # クリア
      └─ session.Flags は保持（LocalOnly 等）

4. 新セッション開始
   ├─ 次のメッセージ受信時
   └─ session.GetOrCreate(channel, chatID)
      → 空の履歴から再開
```

### 関与するモジュール・関数

| モジュール | ファイル | 関数/メソッド | 役割 |
|-----------|---------|-------------|------|
| **agent** | loop.go | maybeDailyCutover() | カットオーバー判定 |
| **agent** | memory.go | SaveDailyNoteForDate(), GetLogicalDate() | 日次ノート保存 |
| **session** | manager.go | GetUpdatedTime(), ResetSession() | セッション管理 |
| **logger** | logger.go | InfoCF() | カットオーバーログ |

### 重要な挙動

- **04:00 JST 境界**: 03:59 までの活動は「前日」扱い
- **Flags 保持**: ResetSession は Messages/Summary をクリアするが、Flags は保持
- **Obsidian 連携**: 日次ノートは Obsidian で閲覧可能な Markdown 形式

### 変更影響範囲

- **タイムゾーン変更時**: agent/memory.go の `Asia/Tokyo` を修正
- **アーカイブ形式変更時**: SaveDailyNoteForDate() のテンプレート修正

---

## ユースケース間の関係性

```
UC1（基本フロー）
  ├─ UC2（承認フロー）: CODE3 ルート時に分岐
  ├─ UC3（Auto-Approve）: UC2 の自動化
  ├─ UC4（ヘルスチェック）: UC1 の前提条件（LLM 呼び出し前）
  └─ UC5（カットオーバー）: UC1 の後処理（日次境界）
```

---

## 次の一手: ユースケース実装完了のために

1. **UC2 の完成**: Coder3 plan/patch パースと Worker 実行委譲
2. **UC3 の実装**: Auto-Approve の Scope/TTL 判定ロジック
3. **UC4 の強化**: Ollama 以外の LLM プロバイダーのヘルスチェック
4. **UC5 の拡張**: カットオーバー時刻の設定可能化（ハードコード解消）
5. **MCP 統合（UC6 候補）**: Chrome 操作の承認フロー統合

---

## Phase 2 で検証された実装詳細

### UC2: Coder3 承認フロー（※Phase 2 で追加）
- **cost_hint フィールド**: 未実装（Job 構造体に存在しない）
- **Auto-Approve**: Phase 4-6 で実装予定（現時点では完全未実装）
- **Worker 実行委譲**: 未実装（承認後のフローは手動実行）

### UC4: Ollama ヘルスチェック（※Phase 2 で追加）
- **Ollama 判定ロジック**: `:11434`, `localhost:11434`, `127.0.0.1:11434` を検出
- **タイムアウト**: HTTP タイムアウト 120 秒（`http_provider.go` L54）

### UC5: 日次カットオーバー（※Phase 2 で追加）
- **GetCutoverBoundary**: 04:00 JST 境界の計算（実装確認済み）
- **GetLogicalDate**: 04:00 JST より前は「前日」扱い（実装確認済み）
- **ResetSession の実装**: `manager.go` L310-323、Flags 保持を確認
