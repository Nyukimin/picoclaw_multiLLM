# 実装仕様_01（Go版）：PicoClaw 後段ルーティング拡張（Router / LoopController / Workers）

## 0. 実装ゴール

* 入口（LINE/Slack）から来た1メッセージを、**システムが** 1つの `primary_route` に分類する
* 必要時のみワーカー（推論/コード/リサーチ）を呼び、最終返信文は **会話LLMのみ** が生成する
* ループは LoopController が管理し、回数・時間・`/local` 制約を守る
* ルート切替時だけ 1 行宣言を返し、同一路線では宣言を省略する

---

## 1. モジュール分割（Go）

```text
/cmd/picoclaw
  main.go

/pkg/orchestrator
  service.go          # 1ターン司令塔

/pkg/router
  router.go           # command -> rules -> classifier -> fallback
  rules.go            # ルール読み込み・評価
  evidence.go         # CODE強証拠判定

/pkg/loop
  controller.go       # ループ制御・再ルート

/pkg/workers
  types.go            # WorkerInput/Output
  plan_worker.go
  analyze_worker.go
  ops_worker.go
  research_worker.go
  code_worker.go
  runner.go           # JSON抽出/検証込みの共通実行

/pkg/llm
  client.go           # OpenAI互換インタフェース
  ollama_client.go
  cloud_client.go
  prompts.go

/pkg/prompt
  manager.go          # system prompt 組み立て
  declaration.go      # ルート切替宣言

/pkg/materials
  policy.go
  builder.go

/pkg/security
  sanitizer.go        # マスク/クラウド送信前除外

/pkg/memory
  store.go            # short_memory + recent_turns

/pkg/infra
  logger.go
  time.go
```

責務境界:

* `orchestrator`: 受信 -> ルーティング -> ループ実行 -> 最終整形 -> 返信
* `router`: 分岐決定のみ（副作用を持たない）
* `loop/controller`: 継続/停止/再ルートの最終決定
* `workers/*`: route別素材生成（ユーザー向け最終文は作らない）

---

## 2. 設定（config.json）

```json
{
  "routing": {
    "classifier": {
      "enabled": true,
      "min_confidence": 0.6,
      "min_confidence_for_code": 0.8
    },
    "fallback_route": "CHAT"
  },
  "loop": {
    "max_loops": 3,
    "max_millis": 25000,
    "allow_auto_reroute_once": true,
    "allow_chat_propose_reroute_once": true
  },
  "security": {
    "redact_patterns": ["xoxb-", "xapp-", "sk-", "AKIA", "-----BEGIN"],
    "cloud_allowed_routes": ["CODE"]
  },
  "timeouts": {
    "ollama_ms": 12000,
    "cloud_ms": 20000
  }
}
```

環境変数（例）:

* `PICOCLAW_OLLAMA_BASE_URL=http://localhost:11434/v1`
* `PICOCLAW_OLLAMA_CHAT_MODEL=qwen2.5:7b`
* `PICOCLAW_OLLAMA_REASON_MODEL=qwen3-thinking-q4`
* `PICOCLAW_CLOUD_CODE_API_KEY=...`
* `PICOCLAW_CLOUD_CODE_BASE_URL=...`

---

## 3. データ構造

### 3.1 入力（Adapter -> Orchestrator）

```go
type InputMessage struct {
    Channel    string                 `json:"channel"`    // slack|line
    SessionID  string                 `json:"session_id"`
    UserText   string                 `json:"user_text"`
    Raw        map[string]any         `json:"raw,omitempty"`
    ReceivedAt time.Time              `json:"received_at"`
}
```

### 3.2 ルーティング決定（Router -> LoopController）

```go
type RoutingDecision struct {
    PrimaryRoute string   `json:"primary_route"` // CHAT|PLAN|ANALYZE|OPS|RESEARCH|CODE
    Source       string   `json:"source"`        // command|rules|classifier|fallback
    Confidence   float64  `json:"confidence"`
    Reason       string   `json:"reason"`
    Evidence     []string `json:"evidence,omitempty"`
    Flags        struct {
        LocalOnly bool `json:"local_only"`
    } `json:"flags"`
}
```

### 3.3 ワーカー戻り値（Worker -> LoopController）

```go
type WorkerOutput struct {
    Result           any      `json:"result"`
    NeedsNextLoop    bool     `json:"needs_next_loop"`
    Why              string   `json:"why"`
    NextActions      []string `json:"next_actions"`
    QuestionsForUser []string `json:"questions_for_user"`
    Confidence       float64  `json:"confidence"`
    Risk             string   `json:"risk"` // low|medium|high
    Fit              *bool    `json:"fit,omitempty"`
    SuggestedRoute   string   `json:"suggested_route,omitempty"`
}
```

---

## 4. 1ターン処理フロー

1. Adapter が `InputMessage` を作成
2. Orchestrator がセッション状態（flags/memory/prev_route）をロード
3. Router が `RoutingDecision` を決定（command -> rules -> classifier -> fallback）
4. LoopController が Worker を実行し `materials` を蓄積
5. route切替時のみ declaration を生成
6. 会話LLMに `user_text + materials + memory + declaration` を渡して最終文を生成
7. short_memory/prev_route を保存
8. 返信送信

---

## 5. Router 実装

### 5.1 明示コマンド

対応:

* `/code /analyze /plan /ops /research /chat`
* `/local`（クラウド禁止）
* `/cloud`（local解除）

仕様:

* 行頭コマンドのみ有効
* 本文に含まれる擬似コマンドは無視
* `local_only=true` 中の `/code` は拒否し、解除方法のみ案内

### 5.2 ルール辞書

* 優先度降順で評価
* 同priorityは定義順
* 最初の一致ルールで確定

ルール例:

```json
{
  "name": "CODE_DIFF",
  "route": "CODE",
  "priority": 900,
  "patterns": ["diff --git", "^\\+\\+\\+ ", "^--- ", "^@@ "]
}
```

### 5.3 CODE強証拠

以下のいずれか:

* unified diff
* コードブロック
* まとまったスタックトレース
* 具体ファイル名/拡張子（`go.mod`, `Dockerfile`, `*.go`, `*.py`, `*.service`, `*.yaml` など）

### 5.4 分類器呼び出し

* 辞書で確定しない場合のみ実行
* 1入力につき1回まで
* JSONのみ受理: `route/confidence/reason/evidence`
* 失敗時は CHAT にフォールバック

---

## 6. LoopController

停止条件:

* `loops >= max_loops`
* 経過時間 `>= max_millis`
* `risk=high` かつ追加確認が必要
* ワーカー出力パース失敗

再ルート条件（最大1回）:

* `fit=false` かつ `suggested_route` 有効
* 会話LLMが未達提案を返し、システムが採択

---

## 7. 会話LLM最終整形

入力:

* `short_memory`
* `recent_turns`
* `declaration`（必要時）
* `materials`
* `user_text`

出力制約:

* ユーザー返信本文のみ
* ルーティング内部事情/機密情報を出さない

---

## 8. セキュリティ

* `CODE` 以外はクラウド送信禁止
* `local_only` 中は常にクラウド呼び出し拒否
* マスク対象（トークン/秘密鍵/個人情報）は LLM 入力前に除去
* ログにはマスク後データのみ保存

---

## 9. ログ最小項目

* `input_text_hash`（必要なら原文別保管）
* `initial_route`, `final_route`
* `classifier_route`, `classifier_confidence`
* `worker_calls`, `needs_next_loop`, `risk`, `fit`
* `reroute_used`, `stop_reason`
* `error_reason`（parse/timeout/forbidden など）

---

## 10. テスト観点

* command優先（注入耐性）
* CODE誤爆防止（強証拠なしでCODE不可）
* classifier壊れ入力時のCHATフォールバック
* `local_only` でのCODE拒否
* reroute最大1回
* max_loops/max_millis で確実停止
