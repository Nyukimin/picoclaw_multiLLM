# 実装仕様（修正版・全文）：PicoClaw 後段ルーティング拡張（Router / LoopController / Workers）

## 0. 実装ゴール

* 入口（LINE/Slack）から来た1メッセージを、**システムが** 1つの `primary_route` に分類し、必要ならワーカー（推論/コード/リサーチ）を呼び、最終の返信文は **会話LLMのみ** が生成して返す。
* ループ（複数ワーカー呼び出し）は **LoopController** が管理し、最大回数・停止条件・安全制約（`/local` 等）を必ず守る。
* ユーザーへの可視化は最小限にし、**routeが切り替わった時だけ**「今なにをするか」を1行宣言する（同一route継続中は宣言しない）。

### 0.1 呼び順（このスレッドの結論で固定）

* **会話LLMは最終整形のみ**（ルーティング前に“会話LLMを先に呼んで一次応答を作る”はしない）
* Router/LoopController は `user_text` と `short_memory` と `flags` を材料に **システムが**ルーティング決定する
  （会話LLMに「どのワーカーを呼ぶか」の決定権は渡さない）

---

## 1. モジュール分割（推奨）

```
/src
  /adapters
    slack.ts
    line.ts

  /core
    orchestrator.ts      # 入口→処理→返信の中心（1ターン）
    router.ts            # route決定（command → rules → classifier → fallback）
    loopController.ts    # ループ管理（回数/時間/停止/再ルート）
    rules.ts             # ルール辞書（regex + priority）
    evidence.ts          # CODE強証拠判定（hasStrongCodeEvidence）
    sanitizer.ts         # 秘密情報マスク/クラウド送信の安全化
    memory.ts            # short_memory生成・保存
    declarer.ts          # 宣言文（route切替時のみ）
    chatProposal.ts      # 会話LLMによる「次ループ提案」（任意・最大1回）

  /llm
    ollamaClient.ts      # ローカルLLM呼び出し（会話/推論） OpenAI互換前提
    cloudClient.ts       # クラウドコードLLM呼び出し（1本）
    classifierPrompt.ts  # 分類器プロンプト（固定1枚）
    chatPrompt.ts        # 会話LLMプロンプト（最終整形用）
    proposalPrompt.ts    # 次ループ提案プロンプト（JSON返し）

  /workers
    analyzeWorker.ts
    planWorker.ts
    opsWorker.ts
    researchWorker.ts
    codeWorker.ts

  /types
    messages.ts
    routing.ts
    worker.ts
    memory.ts

  /infra
    logger.ts
    config.ts
    storage.ts           # session/short_memory/log保存（ファイル/DBなど）
    time.ts
```

責務の境界：

* `orchestrator`：1ターンの司令塔（受信→ルーティング→ワーカー実行→会話LLM整形→返信）
* `router + loopController`：分岐・継続の最終決定を持つ（LLMは提案・作業のみ）
* `evidence.ts`：CODE誤爆防止の強証拠判定を単一実装で固定
* `sanitizer.ts`：クラウド送信前の安全化とログのマスクを集中管理

---

## 2. 設定（Config）

### 2.1 configファイル（例：`config.json`）

```json
{
  "channels": { "slack": true, "line": false },

  "localModeDefault": false,

  "routing": {
    "classifier": {
      "enabled": true,
      "minConfidence": 0.60,
      "minConfidenceForCode": 0.80
    },
    "fallbackRoute": "CHAT"
  },

  "loop": {
    "maxLoops": 3,
    "maxMillis": 25000,

    "allowAutoRerouteOnce": true,
    "allowChatLLMProposeRerouteOnce": true
  },

  "memory": {
    "maxRecentTurns": 8,
    "summaryMaxChars": 800
  },

  "security": {
    "redactPatterns": ["xoxb-", "xapp-", "sk-", "AKIA", "-----BEGIN"],
    "cloudAllowedRoutes": ["CODE"]
  },

  "timeouts": {
    "ollamaMs": 12000,
    "cloudMs": 20000
  }
}
```

### 2.2 環境変数（例）

#### Ollama（OpenAI互換 `/v1` で叩く前提）

* `OLLAMA_BASE_URL=http://localhost:11434/v1`
* `OLLAMA_API_KEY=ollama`（ダミーでOK。OpenAI互換クライアントが要求するため）
* `OLLAMA_CHAT_MODEL=qwen2.5:7b`（例：会話LLM）
* `OLLAMA_REASON_MODEL=qwen3-thinking-q4`（例：推論LLM・分類器）

#### クラウド（コード用1本のみ）

* `CLOUD_CODE_API_KEY=...`
* `CLOUD_CODE_BASE_URL=...`

#### Slack/LINE

* Slack/LINEのトークン類（ログに出さない）

---

## 3. データ構造（I/F契約）

### 3.1 入口メッセージ（Adapter → Orchestrator）

```json
{
  "channel": "slack|line",
  "session_id": "slack:channelId:threadTs | line:userId:chatId",
  "user_text": "string",
  "raw": { "providerPayload": "..." },
  "received_at": "iso8601"
}
```

### 3.2 ルーティング決定（Router → LoopController）

```json
{
  "primary_route": "CHAT|PLAN|ANALYZE|OPS|RESEARCH|CODE",
  "source": "command|rules|classifier|fallback",
  "confidence": 0.0,
  "reason": "string",
  "evidence": ["string", "string"],
  "flags": { "local_only": false }
}
```

### 3.3 ワーカー戻り値（Worker → LoopController）

ワーカーは必ずJSONで返す。パース不能は失敗扱い。

```json
{
  "result": "string|object",
  "needs_next_loop": false,
  "why": "string",
  "next_actions": ["string"],
  "questions_for_user": ["string"],
  "confidence": 0.0,
  "risk": "low|medium|high",
  "fit": true,
  "suggested_route": "CHAT|PLAN|ANALYZE|OPS|RESEARCH|CODE"
}
```

### 3.4 会話LLM（最終整形）に渡す入力（Orchestrator → Chat LLM）

* `short_memory`（要約）
* `recent_turns`（直近Nターン）
* `declaration`（必要時のみ一行）
* `materials`（ワーカー結果の素材）
* `user_text`

---

## 4. Orchestrator の処理フロー（1ターン）

### 4.1 概要フロー

1. Adapter が受信して `InputMessage` を作る
2. Orchestrator が session state（flags/memory）をロード
3. Router が `RoutingDecision` を作る（command→rules→classifier→fallback）
4. LoopController が `RoutingDecision` を起点に Worker を実行し、`materials` を蓄積
5. Declarer が route切替に応じて宣言文を生成（必要時のみ）
6. Orchestrator が会話LLMに `user_text + materials + memory + declaration` を渡して最終返信文を生成
7. Memory を更新（short_memory を更新し、前回route等を保存）
8. Adapter が返信送信

---

## 5. Router 実装（command → rules → classifier → fallback）

### 5.1 明示コマンド判定

* 行頭のみ有効（プロンプト注入対策）
* `/local` は `flags.local_only=true` をセッションに保存（解除コマンドは別途）

サポート例：

* `/code` `/analyze` `/plan` `/ops` `/research` `/chat`
* `/local`（クラウド禁止）

擬似コード：

```pseudo
if user_text startsWith "/":
  cmd = firstToken(user_text)
  if cmd in COMMANDS:
     if cmd == "/local":
        session.flags.local_only = true
        return decision(primary_route=currentOrFallback(), source="command", confidence=1.0, flags=session.flags)
     else:
        return decision(primary_route=map(cmd), source="command", confidence=1.0, flags=session.flags)
```

### 5.2 ルール辞書（rules.ts）

* ルールは `priority` 降順で評価し、最初に当たったものを採用
* CODEは誤爆が高コストなので、“強い証拠”のみ登録（単語だけのルール禁止）

ルール構造（例）：

```json
{
  "name": "CODE_DIFF",
  "route": "CODE",
  "priority": 900,
  "patterns": ["diff --git", "^\\+\\+\\+ ", "^--- ", "^@@ "]
}
```

擬似コード：

```pseudo
for rule in rulesSortedByPriority:
  if any(pattern matches user_text):
     return decision(primary_route=rule.route, source="rules", confidence=1.0, evidence=[matched], flags=session.flags)
```

### 5.3 CODE強証拠判定（evidence.ts）

Router と LoopController と CODE採用ゲートで共通利用する。

**強い証拠（いずれか1つ以上で true）**

* コードフェンス： ``` が出現
* diff/patch：`diff --git` または `+++` `---` `@@`
* スタックトレース/エラーログ塊：`Traceback` / `Exception` / `at <file>:<line>` 等が複数行で連続
* 具体ファイル名/拡張子：`package.json` `docker-compose.yml` `Dockerfile` `*.ts` `*.js` `*.py` `*.service` `*.yaml` `*.yml` 等

擬似コード：

```pseudo
function hasStrongCodeEvidence(text):
  return hasCodeFence(text)
      || hasDiffMarkers(text)
      || hasStackTraceBlock(text)
      || hasConcreteFilenamesOrExtensions(text)

function evidenceKinds(text): # ログ改善用（任意）
  kinds = []
  if hasCodeFence(text): kinds.push("code_fence")
  if hasDiffMarkers(text): kinds.push("diff")
  if hasStackTraceBlock(text): kinds.push("stacktrace")
  if hasConcreteFilenamesOrExtensions(text): kinds.push("filenames")
  return kinds
```

### 5.4 分類器呼び出し（推論LLM・1回のみ）

* ルールで確定できない場合のみ最大1回呼ぶ
* 出力はJSONのみ。パース失敗は捨てて fallback

採用ゲート：

* `confidence < minConfidence` → fallback（基本は CHAT/PLAN へ）
* `route == CODE` は追加条件：

  * `confidence >= minConfidenceForCode`
  * `hasStrongCodeEvidence(user_text) == true` を **Router側でも再確認**

擬似コード：

```pseudo
cls = callClassifier(user_text, short_memory, flags)
if invalidJSON(cls): return fallbackDecision()

if cls.route == "CODE":
  if cls.confidence < minConfidenceForCode: return fallbackPLAN()
  if !hasStrongCodeEvidence(user_text): return fallbackPLAN()

if cls.confidence < minConfidence: return fallbackDecision()

return decision(primary_route=cls.route, source="classifier", confidence=cls.confidence, reason=cls.reason, evidence=cls.evidence, flags=session.flags)
```

fallback方針（推奨）：

* 迷ったら `CHAT` または `PLAN`（安全側）
* `/local` 中は `CODE` を絶対に採用しない（LoopControllerでも二重チェック）

---

## 6. 分類器プロンプト（固定1枚・JSON返し）

`classifierPrompt.ts` に固定文字列で保持し、カテゴリ追加時のみ更新する。

````text
あなたは「ルーティング分類器」です。ユーザー入力を次の6カテゴリから1つ選び、JSONだけを返してください。

カテゴリ:
- CHAT: 説明/相談/雑談/要約/レビュー
- PLAN: 段取り/仕様化/タスク分解/構成案/方針決定
- ANALYZE: 抽出/構造化/タグ付け/集計/傾向分析（ログ・CSV・JSON処理）
- OPS: 運用手順/障害対応/設定確認/コマンド案内（systemctl, docker, ssh等）
- RESEARCH: 調査/出典確認/比較/最新情報
- CODE: コード生成/修正/diff/実装（強い証拠がある場合のみ）

重要: CODEの誤爆防止
次の「強い証拠」が1つ以上あるときだけ CODE を選ぶ:
- ``` のコードブロック
- diff/patch（diff --git, +++, ---, @@）
- スタックトレース/エラーログ塊（Traceback/Exception/at file:line等）
- 具体ファイル名や拡張子（package.json, docker-compose.yml, Dockerfile, *.ts, *.py, *.service, *.yml など）
強い証拠が無いなら CODE を選ばず PLAN/OPS/ANALYZE のいずれかにする。

出力はJSONオブジェクト1つのみ:
{"route":"CHAT|PLAN|ANALYZE|OPS|RESEARCH|CODE","confidence":0.0,"reason":"20文字以内","evidence":["根拠断片を最大2つ"]}

JSON以外は出力しない。
````

---

## 7. LoopController 実装（ループ管理の最終決定者）

### 7.1 目的

* `maxLoops` と `maxMillis` を厳守
* `needs_next_loop` は参考情報。**次を回すかの最終決定はLoopController**
* 自動再ルートは最大1回（条件付き）
* `/local` のクラウド禁止は **LoopControllerで強制**（RouterがCODEを返してもブロックできる）

### 7.2 ループの流れ

1. `primary_route` を起点に worker を実行
2. workerのJSON妥当性を検証
3. `risk / confidence / needs_next_loop` を見て続行判断
4. 必要なら次routeを決定し、maxLoopsまで繰り返す
5. `materials` を最終整形へ渡す

擬似コード：

```pseudo
start = now()
loops = 0
rerouted = false
materials = []

route = decision.primary_route

while loops < maxLoops and (now() - start) < maxMillis:
  # /local 二重ロック（クラウド禁止）
  if session.flags.local_only == true and route == "CODE":
     route = "PLAN"
     materials.append({route:"CODE", error:"blocked_by_local_mode"})
     # PLAN へ落として続行（方針のみ作る）
  
  w = runWorker(route, context)

  if workerInvalid(w):
     materials.append({route, error:"worker_invalid"})
     break

  materials.append({route, result:w.result, meta:w})

  if w.risk == "high":
     break

  if w.needs_next_loop != true:
     break

  # 自動再ルート（最大1回）：ワーカー自身のfit不一致
  if allowAutoRerouteOnce and !rerouted and w.fit == false and w.suggested_route in ROUTES:
     route = w.suggested_route
     rerouted = true
     loops += 1
     continue

  # 次のroute選択（ヒューリスティック）
  route = chooseNextRouteHeuristic(route, w)
  loops += 1
```

### 7.3 次route選択（chooseNextRouteHeuristic）

初期は固定でよい（ログで育てる前提）。

推奨マッピング：

* `ANALYZE` → `PLAN`（分析結果を段取りへ）
* `OPS` → `PLAN`（復旧手順や作業順の整理へ）
* `RESEARCH` → `PLAN`（採用案・意思決定の整理へ）
* `PLAN` → `CHAT`（ユーザーへ説明する最終形へ）
* `CODE` → `OPS`（適用手順・確認へ）または `CHAT`（提示で終わり）

擬似コード：

```pseudo
function chooseNextRouteHeuristic(currentRoute, w):
  if currentRoute == "ANALYZE": return "PLAN"
  if currentRoute == "OPS": return "PLAN"
  if currentRoute == "RESEARCH": return "PLAN"
  if currentRoute == "PLAN": return "CHAT"
  if currentRoute == "CODE": return "OPS"
  return "CHAT"
```

### 7.4 追加：会話LLMによる「次ループ提案」（任意・最大1回）

このスレッドの意図「次ループが必要かの判断は会話LLM寄りにしたい（れんには報告だけ）」を、決定権はシステムに残したまま実現する。

要点：

* ループを止める直前（`needs_next_loop=false` でも「目的未達の可能性」がある時）に、会話LLMへ **提案フェーズ** を最大1回だけ入れられる。
* 会話LLMは「ユーザー向け文章」ではなく **JSONのみ** で返す（内部用途）。
* LoopControllerはその提案を採用するか否かを決める（採用しても追加1ループまで）。

提案フェーズの発火条件（例）：

* `allowChatLLMProposeRerouteOnce == true`
* まだ `rerouted == false`
* `risk != high`
* 時間/回数に余裕がある
* 例：ワーカーが `fit=true` でも `confidence` が低い、または `why` が「情報不足」を示す、または `questions_for_user` が空で目的未達が疑われる、など

提案JSONの形式（会話LLM → LoopController）：

```json
{
  "propose_next_loop": true,
  "route": "CHAT|PLAN|ANALYZE|OPS|RESEARCH|CODE",
  "reason": "短文",
  "confidence": 0.0
}
```

CODE提案の採用ゲート（安全策）：

* `/local` なら不採用
* `hasStrongCodeEvidence(user_text)` が false なら不採用
* `route == CODE` は `confidence` 高め閾値（例：0.8）を要求

---

## 8. Worker 実装（route → 処理）

### 8.1 原則

* ワーカーは「素材生成」役。ユーザーへの最終文章は作らない（会話LLMの仕事）
* 戻り値は `result + meta(needs_next_loop / risk / confidence / fit / suggested_route)` のJSON

### 8.2 各ワーカーの責務

* `planWorker`：要件整理、手順分解、TODO、注意点、撤退条件
* `analyzeWorker`：ログ/CSV/JSONの抽出・構造化、要点列挙、差分抽出
* `opsWorker`：安全な確認コマンド案内、原因切り分け、再現手順（実行はしない）
* `researchWorker`：調査タスク分解（必要ならWeb取得モジュールを呼ぶ。クラウドLLMは使わない）
* `codeWorker`：クラウドへ投げる“最小指示”作成 → 生成結果を受け取って返す（/localなら禁止してPLANに落とす）

### 8.3 `/local` 強制（クラウド禁止の二重ロック）

* Router段階：`/local` が立っていたら、分類器/ルールがCODEを返しても採用しない方針にしてよい
* LoopController段階：最終的に `route==CODE` の実行前に必ず `flags.local_only` をチェックし、クラウド呼び出しをブロックする（必須）

ブロック時の挙動：

* `CODE` を `PLAN` にフォールバックして「方針だけ」生成する
* `materials` に `blocked_by_local_mode` を残す（ログ改善用。ユーザーには出さない）

---

## 9. Sanitizer（秘密情報とクラウド送信）

### 9.1 目的

* クラウドに送ってはいけないものを落とす（/local中は送信自体をしない）
* ログにも残さない（またはマスク）

### 9.2 実装

* `redact(text)`：`redactPatterns` に一致するものを `***` へ置換
* `extractSafeForCloud(text)`：鍵/トークン/秘密鍵ブロック/Slack token等を除外したテキストを作る
* `sanitizeForLogging(obj)`：payloadからトークン類削除、長文はサマリ化、必要ならハッシュ化

クラウド送信の必須ルール：

* クラウド呼び出し前に **必ず** `extractSafeForCloud()` を通す
* 送信対象は `CODE` route のみ（`cloudAllowedRoutes=["CODE"]` を強制）
* `/local` 中はクラウド経路を呼ばない

---

## 10. Memory（short_memory中心）

### 10.1 保存方針

セッションごとに保持：

* `recent_turns`：直近Nターン（入力/出力）
* `short_memory`：800文字程度の要約
* `state.flags`：`local_only`、`prev_primary_route` 等
* `artifacts`：ANALYZEで生成した構造化JSON等（必要なら）

### 10.2 更新

* 返信確定後に `short_memory` を更新（推論LLMで要約してもよい）
* `prev_primary_route` を保存（宣言の切替判定に使う）

---

## 11. 宣言（declarer）

### 11.1 ルール

* `prev_primary_route` と `current_primary_route` が異なる場合のみ宣言を付ける
* 同一routeが続く間は宣言しない
* 表示するのは「何をするか」だけ（ローカル/クラウドは表示しない）

宣言文（固定）：

* CODE：「コーディングするね。」
* ANALYZE：「整理して分析するね。」
* PLAN：「段取りを組むね。」
* OPS：「手順で案内するね。」
* RESEARCH：「調べてまとめるね。」
* CHAT：宣言なし

### 11.2 返信への挿入

* 会話LLMに任せず、**システム側で先頭に連結**してもよい（宣言が抜けないため）

---

## 12. エラーハンドリング（必須）

### 12.1 分類器

* JSONパース失敗、キー欠損、列挙外 → classifier結果を破棄して fallback routeへ
* 失敗理由はログに記録（ユーザーには出さない）

### 12.2 ワーカー

* JSONパース失敗、必須項目欠損 → そのワーカーは失敗扱いでループ停止
* 会話LLMには「失敗の要約」と「次に必要な入力（questions_for_user相当）」を素材として渡す

### 12.3 タイムアウト

* Ollama/Cloudは個別timeoutを持つ
* timeout時は失敗扱いでループ停止し、会話LLMへ「何が起きたか」「次に何を貼るべきか」を素材として渡す

---

## 13. ログ/観測（改善のため）

1ターン単位で最低限保存：

* `session_id`
* input（sanitize済み）
* `primary_route / source / confidence`
* classifier結果（sanitize済み）とパース可否（使った場合）
* `evidenceKinds`（CODE強証拠の種別：code_fence/diff/stacktrace/filenames）
* workers呼び出し履歴（route, success/fail, risk, needs_next_loop, fit, suggested_route）
* reroute実施有無（最大1回）
* 会話LLM提案フェーズ実施有無（最大1回）と採否
* final_route（最終返信を組み立てたroute）
* `flags.local_only`

注意：

* ログをユーザー会話に混ぜない（宣言は別）

---

## 14. テスト仕様（最低ライン）

### 14.1 Unit

* command判定（行頭のみ、`/local` のstate保存）
* rulesマッチ（優先順位、CODEは強証拠のみ）
* `hasStrongCodeEvidence()` の判定（コードフェンス/diff/スタックトレース/ファイル名）
* classifier JSONパース（成功/失敗/欠損/列挙外）
* CODE採用ゲート（confidence + 強証拠 + /localブロック）
* declarer（route切替時だけ宣言）

### 14.2 Integration（LLMはモック）

* 1ターン処理：CHAT/PLAN/ANALYZE/OPS/RESEARCH/CODE それぞれ
* `/local` で CODE が PLAN に落ち、クラウド呼び出しが発生しない
* worker `fit=false` → reroute 1回だけ
* 会話LLM提案フェーズが最大1回だけ動き、採用/不採用が制御できる
* `maxLoops / maxMillis` 到達で停止し、会話LLMが「報告＋次に必要な入力」を出す

### 14.3 Golden（回帰）

* よくある入力（Ubuntuログ貼り付け、設計相談、コード断片、URL調査）を固定し、
  期待routeが変わらないことを確認（辞書改修の副作用検知）

---

## 15. デプロイ/運用メモ（最低限）

* systemdで常駐（PicoClaw本体）
* Ollamaは別サービス（既存構成を利用）
* クラウドキーは環境変数で注入し、ログに出さない
* Slackは `thread_ts` を `session_id` に含める（会話の分岐が混ざらない）
* `/local` フラグは session state に保存し、再起動後も復元できる（storageで永続化）

