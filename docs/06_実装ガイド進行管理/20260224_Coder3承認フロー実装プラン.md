# Coder3 統合と承認フロー実装プラン

作成日: 2026-02-24
対象: PicoClaw Coder3 統合と承認フロー実装

## Context

PicoClaw に **Coder3（Claude API 専用の高品質コーディング/推論エージェント）** と **承認フロー** を統合する。

### 背景と目的

- **問題**: 現在の Coder1/Coder2 は設計・実装案を生成するが、破壊的操作の制御機構がなく、承認なしに実行されるリスクがある
- **新要件**: Coder3 仕様（`docs/05_LLM運用プロンプト設計/Coder3_Claude_API仕様.md`）により、以下が必要:
  - Claude API（OAuth/ブラウザセッション不使用）による高品質な設計/コード生成
  - Coder は「提案（plan）」と「差分（patch）」のみ生成、実行は Worker が担当
  - 破壊的操作には**承認が必須**（ユーザーが job_id で承認/拒否）
  - Auto-Approve モード（Scope/TTL 付き、即時 OFF 可能）
- **変更の意図**: Chat/Worker/Coder の責務を明確に分離し、安全で追跡可能な自動化を実現

### 期待される成果

- Coder3 を CODE3 ルーティングで呼び出し可能に
- ユーザー承認が必要な操作を自動実行しない安全性
- job_id でジョブ追跡可能（ログ、承認状態）
- 段階的に Auto-Approve 導入可能な基盤

---

## Recommended Approach

**Phase 1-3 を実装** （Coder3 ルーティング + 完全な承認フロー）

従来の Coder1/Coder2 は既存動作を維持しつつ、Coder3 と承認フローを段階的に導入する。

### Phase 1: Coder3 Routing（優先度: 高）

**目的**: CODE3 ルーティングを実装し、Claude API で Coder3 を呼び出せるようにする

#### 1.1 Routing Constants

**pkg/agent/router.go**
- `RouteCode3` 定数を追加
- `parseRouteCommand()` に `/code3` コマンド処理を追加
- `IsCodeRoute()` に CODE3 チェックを追加

```go
const (
    // 既存
    RouteCode  = "CODE"
    RouteCode1 = "CODE1"
    RouteCode2 = "CODE2"
    // 新規
    RouteCode3 = "CODE3"
)

func parseRouteCommand(text string) string {
    // ... 既存の処理 ...
    if strings.HasPrefix(text, "/code3") {
        return RouteCode3
    }
    // ...
}

func IsCodeRoute(route string) bool {
    return route == RouteCode || route == RouteCode1 ||
           route == RouteCode2 || route == RouteCode3
}
```

#### 1.2 Configuration

**pkg/config/config.go**
- `RouteLLMConfig` に Coder3 フィールドを追加

```go
type RouteLLMConfig struct {
    // 既存
    CoderProvider  string
    CoderModel     string
    Coder2Alias    string
    Coder2Provider string
    Coder2Model    string
    // 新規
    Coder3Alias    string
    Coder3Provider string
    Coder3Model    string
}
```

**config/picoclaw.yaml** の例:
```yaml
routing:
  llm:
    coder3_alias: "Gin"
    coder3_provider: "anthropic"
    coder3_model: "claude-sonnet-4.5"
```

#### 1.3 Routing Logic

**pkg/agent/loop.go**
- `selectCoderRoute()` に Coder3 選択ロジックを追加
  - キーワード例: "高品質", "仕様策定", "複雑な推論", "重大バグ"
- `applyRouteLLM()` に CODE3 ケースを追加（ClaudeProvider を使用）

```go
func selectCoderRoute(msg string) string {
    // 既存の CODE1/CODE2 ロジック...

    // CODE3: 高品質コーディング/推論向け
    code3Keywords := []string{"高品質", "仕様策定", "複雑な推論", "重大バグ", "失敗コスト"}
    for _, kw := range code3Keywords {
        if strings.Contains(msg, kw) {
            return RouteCode3
        }
    }

    // デフォルト
    return RouteCode
}

func (s *AgentLoop) applyRouteLLM(...) {
    switch route {
    case RouteCode3:
        providerName = s.cfg.RouteLLM.Coder3Provider
        modelName = s.cfg.RouteLLM.Coder3Model
        // ...
    }
}
```

**既存パターンを再利用**: ClaudeProvider（`pkg/providers/claude_provider.go`）がすでに存在し、API キーベースの Claude 呼び出しに対応済み。新規プロバイダーの実装は不要。

---

### Phase 2: Approval Infrastructure（優先度: 高）

**目的**: job_id 管理、承認状態追跡、基本的な承認 API を実装

#### 2.1 Job ID Generation

**新規パッケージ**: `pkg/approval/job.go`

```go
package approval

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "time"
)

// GenerateJobID は job_id を生成（timestamp + random）
func GenerateJobID() string {
    ts := time.Now().Format("20060102-150405")
    randBytes := make([]byte, 4)
    rand.Read(randBytes)
    return fmt.Sprintf("%s-%s", ts, hex.EncodeToString(randBytes))
}
```

#### 2.2 Approval State Tracking

**pkg/session/manager.go** に SessionFlags 拡張:

```go
type SessionFlags struct {
    LocalOnly            bool
    PrevPrimaryRoute     string
    // 新規
    PendingApprovalJobID string  // 承認待ちの job_id
}
```

#### 2.3 Approval API

**新規パッケージ**: `pkg/approval/manager.go`

```go
package approval

import (
    "fmt"
    "sync"
    "time"
)

type Status string

const (
    StatusPending      Status = "pending"
    StatusGranted      Status = "granted"
    StatusDenied       Status = "denied"
    StatusAutoApproved Status = "auto_approved"
)

type Job struct {
    JobID     string
    Status    Status
    Plan      string
    Patch     string
    Risk      map[string]interface{}
    RequestedAt string
    DecidedAt   string
    Approver    string
}

type Manager struct {
    mu   sync.RWMutex
    jobs map[string]*Job
}

func NewManager() *Manager {
    return &Manager{jobs: make(map[string]*Job)}
}

func (m *Manager) CreateJob(jobID, plan, patch string, risk map[string]interface{}) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    if _, exists := m.jobs[jobID]; exists {
        return fmt.Errorf("job %s already exists", jobID)
    }

    m.jobs[jobID] = &Job{
        JobID:       jobID,
        Status:      StatusPending,
        Plan:        plan,
        Patch:       patch,
        Risk:        risk,
        RequestedAt: time.Now().Format(time.RFC3339),
    }
    return nil
}

func (m *Manager) GetJob(jobID string) (*Job, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    job, ok := m.jobs[jobID]
    if !ok {
        return nil, fmt.Errorf("job %s not found", jobID)
    }
    return job, nil
}

func (m *Manager) Approve(jobID, approver string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    job, ok := m.jobs[jobID]
    if !ok {
        return fmt.Errorf("job %s not found", jobID)
    }

    job.Status = StatusGranted
    job.Approver = approver
    job.DecidedAt = time.Now().Format(time.RFC3339)
    return nil
}

func (m *Manager) Deny(jobID, approver string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    job, ok := m.jobs[jobID]
    if !ok {
        return fmt.Errorf("job %s not found", jobID)
    }

    job.Status = StatusDenied
    job.Approver = approver
    job.DecidedAt = time.Now().Format(time.RFC3339)
    return nil
}

func (m *Manager) IsApproved(jobID string) (bool, error) {
    job, err := m.GetJob(jobID)
    if err != nil {
        return false, err
    }
    return job.Status == StatusGranted || job.Status == StatusAutoApproved, nil
}
```

#### 2.4 Logging Events

**pkg/logging/logger.go** にイベント記録関数を追加:

```go
func LogApprovalRequested(jobID, plan, patch string, risk map[string]interface{}) {
    log.Printf("[approval.requested] job_id=%s plan=%q risk=%+v", jobID, plan, risk)
}

func LogApprovalGranted(jobID, approver string) {
    log.Printf("[approval.granted] job_id=%s approver=%s", jobID, approver)
}

func LogApprovalDenied(jobID, approver string) {
    log.Printf("[approval.denied] job_id=%s approver=%s", jobID, approver)
}

func LogCoderPlanGenerated(jobID, plan string) {
    log.Printf("[coder.plan_generated] job_id=%s plan=%q", jobID, plan)
}
```

---

### Phase 3: Approval Flow Logic（優先度: 高）

**目的**: Coder3 出力処理、承認要求送信、Worker 実行を統合

#### 3.1 Coder3 Output Parsing

Coder3 は以下の JSON を返すことを期待:

```json
{
  "job_id": "string",
  "plan": "手順・判断理由",
  "patch": "diff 形式の変更案",
  "risk": {
    "destructive": false,
    "compatibility_issues": [],
    "rollback_possible": true
  },
  "cost_hint": {
    "estimated_tokens": 8000,
    "near_limit": false
  },
  "need_approval": true
}
```

**pkg/agent/loop.go** で Coder3 レスポンスをパース:

```go
type Coder3Output struct {
    JobID        string                 `json:"job_id"`
    Plan         string                 `json:"plan"`
    Patch        string                 `json:"patch"`
    Risk         map[string]interface{} `json:"risk"`
    CostHint     map[string]interface{} `json:"cost_hint"`
    NeedApproval bool                   `json:"need_approval"`
}

func parseCoder3Output(response string) (*Coder3Output, error) {
    var output Coder3Output
    if err := json.Unmarshal([]byte(response), &output); err != nil {
        return nil, err
    }
    return &output, nil
}
```

#### 3.2 Approval Request Message

**pkg/approval/message.go**

```go
package approval

import "fmt"

func FormatApprovalRequest(job *Job) string {
    return fmt.Sprintf(`
【承認要求】
Job ID: %s

【操作要約】
%s

【変更内容】
%s

【影響範囲とリスク】
%+v

承認する場合: /approve %s
拒否する場合: /deny %s
`, job.JobID, job.Plan, job.Patch, job.Risk, job.JobID, job.JobID)
}
```

#### 3.3 Chat Integration

**pkg/agent/loop.go** の `Run()` メソッドを拡張:

```go
func (s *AgentLoop) Run(ctx context.Context, req *Request) (*Response, error) {
    // ... 既存のルーティング処理 ...

    // CODE3 の場合
    if finalRoute == RouteCode3 {
        // 1. job_id 生成
        jobID := approval.GenerateJobID()

        // 2. Coder3 呼び出し（既存の applyRouteLLM を使用）
        coderResp, err := s.applyRouteLLM(ctx, finalRoute, req)
        if err != nil {
            return nil, err
        }

        // 3. Coder3 出力パース
        output, err := parseCoder3Output(coderResp)
        if err != nil {
            return nil, fmt.Errorf("coder3 output parse error: %w", err)
        }

        // 4. 承認が必要かチェック
        if output.NeedApproval {
            // 5. 承認ジョブ作成
            err = s.approvalMgr.CreateJob(jobID, output.Plan, output.Patch, output.Risk)
            if err != nil {
                return nil, err
            }

            // 6. セッションに job_id を保存
            s.sessionMgr.UpdateFlags(req.SessionID, func(flags *session.SessionFlags) {
                flags.PendingApprovalJobID = jobID
            })

            // 7. ログ記録
            logging.LogApprovalRequested(jobID, output.Plan, output.Patch, output.Risk)

            // 8. 承認要求メッセージを返す
            job, _ := s.approvalMgr.GetJob(jobID)
            msg := approval.FormatApprovalRequest(job)

            return &Response{
                Text: msg,
                RouteUsed: finalRoute,
            }, nil
        }

        // need_approval=false の場合は直接 Worker へ
        // （後続の Worker 呼び出しに進む）
    }

    // ... 既存の Worker 呼び出し処理 ...
}
```

#### 3.4 Approval Commands

**pkg/agent/router.go** に承認コマンドを追加:

```go
const (
    RouteApprove = "APPROVE"
    RouteDeny    = "DENY"
)

func parseRouteCommand(text string) string {
    if strings.HasPrefix(text, "/approve") {
        return RouteApprove
    }
    if strings.HasPrefix(text, "/deny") {
        return RouteDeny
    }
    // ... 既存の処理 ...
}
```

**pkg/agent/loop.go** で承認コマンド処理:

```go
func (s *AgentLoop) Run(ctx context.Context, req *Request) (*Response, error) {
    // ... ルーティング ...

    if finalRoute == RouteApprove {
        // /approve <job_id> のパース
        parts := strings.Fields(req.Text)
        if len(parts) < 2 {
            return &Response{Text: "使い方: /approve <job_id>"}, nil
        }
        jobID := parts[1]

        // 承認
        err := s.approvalMgr.Approve(jobID, req.UserID)
        if err != nil {
            return &Response{Text: fmt.Sprintf("承認エラー: %v", err)}, nil
        }

        logging.LogApprovalGranted(jobID, req.UserID)

        // ジョブ取得
        job, _ := s.approvalMgr.GetJob(jobID)

        // Worker に差分適用を依頼
        workerReq := &Request{
            Text: fmt.Sprintf("以下の patch を適用してください:\n\n%s", job.Patch),
            SessionID: req.SessionID,
        }
        workerResp, err := s.applyRouteLLM(ctx, RouteWorker, workerReq)
        if err != nil {
            return &Response{Text: fmt.Sprintf("Worker 実行エラー: %v", err)}, nil
        }

        return &Response{
            Text: fmt.Sprintf("承認完了 (job_id=%s)\n\nWorker 実行結果:\n%s", jobID, workerResp),
            RouteUsed: RouteApprove,
        }, nil
    }

    if finalRoute == RouteDeny {
        // /deny <job_id> のパース
        parts := strings.Fields(req.Text)
        if len(parts) < 2 {
            return &Response{Text: "使い方: /deny <job_id>"}, nil
        }
        jobID := parts[1]

        // 拒否
        err := s.approvalMgr.Deny(jobID, req.UserID)
        if err != nil {
            return &Response{Text: fmt.Sprintf("拒否エラー: %v", err)}, nil
        }

        logging.LogApprovalDenied(jobID, req.UserID)

        return &Response{
            Text: fmt.Sprintf("承認拒否しました (job_id=%s)", jobID),
            RouteUsed: RouteDeny,
        }, nil
    }

    // ... 既存の処理 ...
}
```

---

## Critical Files

### 修正が必要なファイル

1. **pkg/agent/router.go**
   - `RouteCode3`, `RouteApprove`, `RouteDeny` 定数追加
   - `parseRouteCommand()` に `/code3`, `/approve`, `/deny` 処理追加
   - `IsCodeRoute()` に CODE3 チェック追加

2. **pkg/agent/loop.go**
   - `selectCoderRoute()` に Coder3 選択ロジック追加
   - `applyRouteLLM()` に CODE3 ケース追加
   - `Run()` に Coder3 出力処理と承認フロー統合
   - `parseCoder3Output()` 関数追加
   - 承認コマンド（APPROVE/DENY）処理追加

3. **pkg/config/config.go**
   - `RouteLLMConfig` に `Coder3Alias`, `Coder3Provider`, `Coder3Model` フィールド追加

4. **pkg/session/manager.go**
   - `SessionFlags` に `PendingApprovalJobID` フィールド追加

5. **config/picoclaw.yaml**（設定例を追加）
   - `routing.llm.coder3_*` 設定を追加

### 新規作成が必要なファイル

6. **pkg/approval/job.go**
   - `GenerateJobID()` 関数

7. **pkg/approval/manager.go**
   - `Manager`, `Job`, `Status` 型定義
   - `CreateJob()`, `GetJob()`, `Approve()`, `Deny()`, `IsApproved()` メソッド

8. **pkg/approval/message.go**
   - `FormatApprovalRequest()` 関数

9. **pkg/logging/logger.go**（既存ファイルに追加）
   - `LogApprovalRequested()`, `LogApprovalGranted()`, `LogApprovalDenied()`, `LogCoderPlanGenerated()` 関数

### 既存パターンの再利用

- **ClaudeProvider** (`pkg/providers/claude_provider.go`): API キーベースの Claude 呼び出しに対応済み
- **SessionFlags パターン** (`pkg/session/manager.go`): セッション状態管理に使用
- **Message Tool** (`pkg/bus/message.go`): ユーザー通知に使用可能
- **Bus Metadata**: job_id の関連付けに使用可能

---

## Verification

### End-to-End テスト手順

#### 1. Coder3 Routing テスト

```bash
# 設定ファイルに Coder3 を追加
cat <<EOF >> config/picoclaw.yaml
routing:
  llm:
    coder3_alias: "Gin"
    coder3_provider: "anthropic"
    coder3_model: "claude-sonnet-4.5"
EOF

# 環境変数に API キーを設定
export ANTHROPIC_API_KEY="your-api-key"

# ビルド
go build -o picoclaw cmd/picoclaw/main.go

# 実行
./picoclaw

# LINE/Slack で以下を送信
"/code3 仕様策定の骨格を作成してください"

# 期待: Coder3 が呼び出され、plan/patch を含むレスポンスが返る
```

#### 2. 承認フロー テスト

```bash
# Coder3 に高品質コーディングを依頼
"高品質なリファクタリング案を作成してください"

# 期待: 承認要求メッセージが返る（job_id 付き）
# 例:
# 【承認要求】
# Job ID: 20260224-153045-a1b2c3d4
# ...
# 承認する場合: /approve 20260224-153045-a1b2c3d4

# 承認コマンドを送信
"/approve 20260224-153045-a1b2c3d4"

# 期待:
# - 承認ログが記録される
# - Worker が patch を適用する
# - 実行結果が返る
```

#### 3. 承認拒否テスト

```bash
# 承認要求後、拒否コマンドを送信
"/deny 20260224-153045-a1b2c3d4"

# 期待:
# - 拒否ログが記録される
# - Worker は実行されない
# - "承認拒否しました" メッセージが返る
```

#### 4. ログ確認

```bash
# ログファイルに以下が記録されていることを確認
grep "approval.requested" logs/picoclaw.log
grep "approval.granted" logs/picoclaw.log
grep "approval.denied" logs/picoclaw.log
grep "coder.plan_generated" logs/picoclaw.log
```

### ユニットテスト

#### pkg/approval/manager_test.go

```go
func TestManager_CreateJob(t *testing.T) {
    mgr := NewManager()
    jobID := "test-job-001"

    err := mgr.CreateJob(jobID, "plan", "patch", map[string]interface{}{"destructive": false})
    if err != nil {
        t.Fatalf("CreateJob failed: %v", err)
    }

    job, err := mgr.GetJob(jobID)
    if err != nil {
        t.Fatalf("GetJob failed: %v", err)
    }

    if job.Status != StatusPending {
        t.Errorf("Expected status=pending, got %s", job.Status)
    }
}

func TestManager_Approve(t *testing.T) {
    mgr := NewManager()
    jobID := "test-job-002"

    mgr.CreateJob(jobID, "plan", "patch", nil)
    err := mgr.Approve(jobID, "user123")
    if err != nil {
        t.Fatalf("Approve failed: %v", err)
    }

    job, _ := mgr.GetJob(jobID)
    if job.Status != StatusGranted {
        t.Errorf("Expected status=granted, got %s", job.Status)
    }
    if job.Approver != "user123" {
        t.Errorf("Expected approver=user123, got %s", job.Approver)
    }
}

func TestManager_IsApproved(t *testing.T) {
    mgr := NewManager()
    jobID := "test-job-003"

    mgr.CreateJob(jobID, "plan", "patch", nil)

    approved, _ := mgr.IsApproved(jobID)
    if approved {
        t.Error("Expected not approved before approval")
    }

    mgr.Approve(jobID, "user123")
    approved, _ = mgr.IsApproved(jobID)
    if !approved {
        t.Error("Expected approved after approval")
    }
}
```

#### pkg/approval/job_test.go

```go
func TestGenerateJobID(t *testing.T) {
    jobID := GenerateJobID()

    // 形式チェック: YYYYMMDD-HHMMSS-xxxxxxxx
    if len(jobID) != 24 {
        t.Errorf("Expected jobID length=24, got %d", len(jobID))
    }

    parts := strings.Split(jobID, "-")
    if len(parts) != 3 {
        t.Errorf("Expected 3 parts, got %d", len(parts))
    }
}
```

### 統合テスト

```bash
# すべてのテストを実行
go test ./pkg/approval/... -v
go test ./pkg/agent/... -v
go test ./pkg/config/... -v
go test ./pkg/session/... -v

# カバレッジ確認
go test ./pkg/approval/... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

---

## Implementation Notes

### Phase 1 での注意点

- Coder3 は既存の `ClaudeProvider` を再利用（新規プロバイダー不要）
- `selectCoderRoute()` のキーワードマッチングは初期実装として簡易的でOK（後で分類器に移行可能）
- `/code3` コマンドでの明示的呼び出しを優先サポート

### Phase 2 での注意点

- `approval.Manager` は in-memory 実装でスタート（永続化は Phase 5 以降）
- job_id は timestamp + random で十分（UUID は不要）
- セッションへの job_id 保存は、承認待ち中の状態を追跡するため

### Phase 3 での注意点

- Coder3 出力フォーマットは JSON 期待（エラーハンドリング重要）
- 承認コマンド（`/approve`, `/deny`）は簡易実装でスタート（UI は後で拡張）
- Worker への patch 適用は、既存の Worker 呼び出しを再利用

### 後方互換性

- Coder1/Coder2 の既存動作は一切変更しない
- 新規設定 `coder3_*` がない場合、CODE3 ルーティングはエラーを返す（設定不備として明確化）
- 承認フローは Coder3 のみに適用（Coder1/Coder2 は影響なし）

### セキュリティ

- API キーは環境変数 `ANTHROPIC_API_KEY` から取得（平文保存禁止）
- 承認ログには機密情報をマスクして記録（既存のサニタイザーパターン利用）
- job_id はログで追跡可能だが、予測困難な形式（timestamp + random）

---

## Estimated Effort

- **Phase 1**: 2-3 時間（ルーティング追加、設定追加、動作確認）
- **Phase 2**: 3-4 時間（pkg/approval パッケージ作成、テスト作成）
- **Phase 3**: 4-5 時間（承認フロー統合、end-to-end テスト）
- **合計**: 9-12 時間

---

## References

- **正本仕様**: `docs/01_正本仕様/実装仕様.md`
- **Coder3 詳細仕様**: `docs/05_LLM運用プロンプト設計/Coder3_Claude_API仕様.md`
- **統合仕様反映**: `docs/06_実装ガイド進行管理/20260224_Coder3統合仕様反映.md`
- **既存 ClaudeProvider**: `pkg/providers/claude_provider.go`
- **既存 Router**: `pkg/agent/router.go`
- **既存 AgentLoop**: `pkg/agent/loop.go`
