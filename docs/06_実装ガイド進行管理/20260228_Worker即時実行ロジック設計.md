# Worker 即時実行ロジック設計

**作成日**: 2026-02-28
**目的**: 承認フロー廃止に伴う Worker 即時実行ロジックの詳細設計
**関連仕様**: [20260228_承認フロー廃止プラン.md](./20260228_承認フロー廃止プラン.md)

---

## 概要

このドキュメントは、Coder3 が生成した `patch` を受け取り、即座に実行する Worker ロジックの詳細設計を定義します。

**基本フロー**:
1. Coder3 が `plan` と `patch` を生成
2. Worker が `patch` をパース
3. Worker が各コマンドを順次実行
4. 実行結果をログに記録
5. （オプション）Git auto-commit を実行
6. 結果をユーザーに返す

---

## 1. データ構造定義

### 1.1 PatchCommand 構造体

`patch` 内の個別コマンドを表現する構造体。

```go
// PatchCommand は patch 内の1つのコマンドを表現
type PatchCommand struct {
	Type    string            `json:"type"`    // コマンド種別
	Action  string            `json:"action"`  // アクション
	Target  string            `json:"target"`  // 対象（ファイルパスやコマンド）
	Content string            `json:"content"` // 内容（ファイル内容やコマンド引数）
	Metadata map[string]string `json:"metadata,omitempty"` // 追加情報
}
```

#### Type（コマンド種別）

| Type | 説明 | 例 |
|------|------|-----|
| `file_edit` | ファイル編集（作成・更新・削除） | ファイルの新規作成、内容変更 |
| `shell_command` | シェルコマンド実行 | `go test`, `npm install` |
| `git_operation` | Git 操作 | `git add`, `git commit` |

#### Action（アクション）

| Type | 使用可能な Action | 説明 |
|------|-------------------|------|
| `file_edit` | `create`, `update`, `delete`, `append` | ファイル操作の種類 |
| `shell_command` | `run` | コマンドを実行 |
| `git_operation` | `add`, `commit`, `reset`, `checkout` | Git 操作の種類 |

#### Target（対象）

- `file_edit`: ファイルパス（例: `pkg/agent/loop.go`）
- `shell_command`: コマンド本体（例: `go test ./pkg/...`）
- `git_operation`: Git コマンド引数（例: `pkg/agent/loop.go`）

#### Content（内容）

- `file_edit`: ファイル内容全文または追加テキスト
- `shell_command`: コマンド引数（Target に含めても可）
- `git_operation`: コミットメッセージ等

---

### 1.2 PatchExecutionResult 構造体

実行結果を表現する構造体。

```go
// PatchExecutionResult は patch 実行の結果を表現
type PatchExecutionResult struct {
	Success      bool              `json:"success"`
	ExecutedCmds int               `json:"executed_cmds"`  // 実行したコマンド数
	FailedCmds   int               `json:"failed_cmds"`    // 失敗したコマンド数
	Results      []CommandResult   `json:"results"`        // 各コマンドの結果
	Summary      string            `json:"summary"`        // サマリメッセージ
	GitCommit    string            `json:"git_commit,omitempty"` // auto-commit した場合のコミットハッシュ
}

// CommandResult は個別コマンドの実行結果
type CommandResult struct {
	Command   PatchCommand `json:"command"`
	Success   bool         `json:"success"`
	Output    string       `json:"output"`    // 標準出力
	Error     string       `json:"error"`     // エラーメッセージ
	Duration  int64        `json:"duration"`  // 実行時間（ミリ秒）
}
```

---

## 2. 関数設計

### 2.1 parsePatch() - patch パーサー

**目的**: Coder3 が生成した `patch` 文字列を解析し、`[]PatchCommand` に変換する。

**シグネチャ**:
```go
func parsePatch(patch string) ([]PatchCommand, error)
```

**入力フォーマット**: 以下の2つをサポート

#### フォーマット A: JSON 配列

```json
[
  {
    "type": "file_edit",
    "action": "update",
    "target": "pkg/agent/loop.go",
    "content": "package agent\n\nfunc foo() {\n  // new code\n}\n"
  },
  {
    "type": "shell_command",
    "action": "run",
    "target": "go test ./pkg/agent/...",
    "content": ""
  }
]
```

#### フォーマット B: Markdown コードブロック

````markdown
## ファイル編集

```go:pkg/agent/loop.go
package agent

func foo() {
  // new code
}
```

## コマンド実行

```bash
go test ./pkg/agent/...
```
````

**実装ロジック**:
1. patch の先頭が `[` なら JSON パース
2. patch に ` ```go:` または ` ```bash` が含まれるなら Markdown パース
3. どちらでもない場合はエラー

**Markdown パースの詳細**:
- ` ```go:<filepath>` → `file_edit` + `update` + filepath
- ` ```bash` → `shell_command` + `run`
- ` ```sh` → `shell_command` + `run`
- ` ```git` → `git_operation` + `add` or `commit`（コマンド内容から判定）

**エラーハンドリング**:
- 不正な JSON → エラー返却
- 不明なコードブロック → 警告ログ + スキップ
- 空の patch → 空の配列を返す（エラーではない）

---

### 2.2 executeWorkerPatch() - patch 実行エントリーポイント

**目的**: parsePatch() でパースした `[]PatchCommand` を順次実行し、結果を返す。

**シグネチャ**:
```go
func (a *AgentLoop) executeWorkerPatch(ctx context.Context, patch string, sessionKey string) (*PatchExecutionResult, error)
```

**実装フロー**:
```go
func (a *AgentLoop) executeWorkerPatch(ctx context.Context, patch string, sessionKey string) (*PatchExecutionResult, error) {
	// 1. patch をパース
	commands, err := parsePatch(patch)
	if err != nil {
		return nil, fmt.Errorf("patch parse error: %w", err)
	}

	result := &PatchExecutionResult{
		Success:      true,
		ExecutedCmds: 0,
		FailedCmds:   0,
		Results:      make([]CommandResult, 0, len(commands)),
	}

	// 2. 各コマンドを順次実行
	for i, cmd := range commands {
		startTime := time.Now()
		cmdResult := CommandResult{
			Command: cmd,
			Success: false,
		}

		output, err := a.executeCommand(ctx, cmd)
		duration := time.Since(startTime).Milliseconds()

		if err != nil {
			// エラー発生 → 失敗を記録し、次へ進む（または中断）
			cmdResult.Success = false
			cmdResult.Error = err.Error()
			cmdResult.Duration = duration
			result.FailedCmds++
			result.Success = false // 1つでも失敗したら全体も失敗

			logger.ErrorCF("worker", "command execution failed", map[string]interface{}{
				"command_index": i,
				"type":          cmd.Type,
				"action":        cmd.Action,
				"target":        cmd.Target,
				"error":         err.Error(),
			})
		} else {
			cmdResult.Success = true
			cmdResult.Output = output
			cmdResult.Duration = duration
			result.ExecutedCmds++

			logger.InfoCF("worker", "command executed", map[string]interface{}{
				"command_index": i,
				"type":          cmd.Type,
				"action":        cmd.Action,
				"target":        cmd.Target,
			})
		}

		result.Results = append(result.Results, cmdResult)

		// TODO: エラー時の挙動（中断 or 継続）を設定可能にする
		// 現在の設計では「継続」（すべて試す）
	}

	// 3. （オプション）Git auto-commit
	if a.cfg.Worker.AutoCommit && result.ExecutedCmds > 0 {
		commitHash, err := a.autoCommitChanges(ctx, patch)
		if err != nil {
			logger.WarnCF("worker", "auto-commit failed", map[string]interface{}{
				"error": err.Error(),
			})
		} else {
			result.GitCommit = commitHash
			logger.InfoCF("worker", "auto-commit success", map[string]interface{}{
				"commit": commitHash,
			})
		}
	}

	// 4. サマリ生成
	result.Summary = fmt.Sprintf("実行: %d 件, 成功: %d 件, 失敗: %d 件",
		len(commands), result.ExecutedCmds, result.FailedCmds)

	// 5. ログ記録
	if result.Success {
		logger.LogWorkerSuccess(patch, result.Summary)
	} else {
		logger.LogWorkerFail(patch, fmt.Errorf(result.Summary))
	}

	return result, nil
}
```

**エラーハンドリング戦略**:
- **継続モード**（デフォルト）: 1つのコマンドが失敗しても、残りのコマンドを実行し続ける
- **中断モード**（オプション）: 最初の失敗で即座に中断し、エラーを返す

→ 現在の設計では「継続モード」を採用。設定で切り替え可能にすることも検討。

---

### 2.3 executeCommand() - 個別コマンド実行

**目的**: `PatchCommand` の Type に応じて適切な実行関数を呼び出す。

**シグネチャ**:
```go
func (a *AgentLoop) executeCommand(ctx context.Context, cmd PatchCommand) (string, error)
```

**実装**:
```go
func (a *AgentLoop) executeCommand(ctx context.Context, cmd PatchCommand) (string, error) {
	switch cmd.Type {
	case "file_edit":
		return a.executeFileEdit(ctx, cmd)
	case "shell_command":
		return a.executeShellCommand(ctx, cmd)
	case "git_operation":
		return a.executeGitOperation(ctx, cmd)
	default:
		return "", fmt.Errorf("unknown command type: %s", cmd.Type)
	}
}
```

---

### 2.4 executeFileEdit() - ファイル編集実行

**目的**: `file_edit` コマンドを実行（作成・更新・削除・追記）。

**シグネチャ**:
```go
func (a *AgentLoop) executeFileEdit(ctx context.Context, cmd PatchCommand) (string, error)
```

**実装**:
```go
func (a *AgentLoop) executeFileEdit(ctx context.Context, cmd PatchCommand) (string, error) {
	target := cmd.Target
	action := cmd.Action
	content := cmd.Content

	// セキュリティチェック: workspace 外への書き込みを禁止
	if !strings.HasPrefix(target, a.workspace) {
		return "", fmt.Errorf("file path outside workspace: %s", target)
	}

	switch action {
	case "create", "update":
		// ファイルを作成または上書き
		err := os.WriteFile(target, []byte(content), 0644)
		if err != nil {
			return "", fmt.Errorf("failed to write file %s: %w", target, err)
		}
		return fmt.Sprintf("File %s written successfully (%d bytes)", target, len(content)), nil

	case "delete":
		// ファイルを削除
		err := os.Remove(target)
		if err != nil {
			return "", fmt.Errorf("failed to delete file %s: %w", target, err)
		}
		return fmt.Sprintf("File %s deleted", target), nil

	case "append":
		// ファイルに追記
		f, err := os.OpenFile(target, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
		if err != nil {
			return "", fmt.Errorf("failed to open file %s: %w", target, err)
		}
		defer f.Close()

		_, err = f.WriteString(content)
		if err != nil {
			return "", fmt.Errorf("failed to append to file %s: %w", target, err)
		}
		return fmt.Sprintf("Appended %d bytes to %s", len(content), target), nil

	default:
		return "", fmt.Errorf("unknown file_edit action: %s", action)
	}
}
```

**セキュリティ考慮**:
- workspace 外への書き込みを禁止
- シンボリックリンクのトラバーサル攻撃を防止（`filepath.Clean()` を使用）

---

### 2.5 executeShellCommand() - シェルコマンド実行

**目的**: `shell_command` コマンドを実行（bash 経由）。

**シグネチャ**:
```go
func (a *AgentLoop) executeShellCommand(ctx context.Context, cmd PatchCommand) (string, error)
```

**実装**:
```go
func (a *AgentLoop) executeShellCommand(ctx context.Context, cmd PatchCommand) (string, error) {
	command := cmd.Target
	if cmd.Content != "" {
		command += " " + cmd.Content
	}

	// シェルコマンド実行（タイムアウト付き）
	execCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	defer cancel()

	cmdExec := exec.CommandContext(execCtx, "bash", "-c", command)
	cmdExec.Dir = a.workspace // workspace をカレントディレクトリに

	output, err := cmdExec.CombinedOutput()
	if err != nil {
		return string(output), fmt.Errorf("command failed: %w (output: %s)", err, string(output))
	}

	return string(output), nil
}
```

**セキュリティ考慮**:
- タイムアウト設定（デフォルト: 5分）
- workspace をカレントディレクトリに固定
- 危険なコマンド（`rm -rf /`）のブロックは**行わない**（ユーザー責任）

---

### 2.6 executeGitOperation() - Git 操作実行

**目的**: `git_operation` コマンドを実行（add, commit, reset 等）。

**シグネチャ**:
```go
func (a *AgentLoop) executeGitOperation(ctx context.Context, cmd PatchCommand) (string, error)
```

**実装**:
```go
func (a *AgentLoop) executeGitOperation(ctx context.Context, cmd PatchCommand) (string, error) {
	action := cmd.Action
	target := cmd.Target
	content := cmd.Content

	var gitCmd []string

	switch action {
	case "add":
		gitCmd = []string{"git", "add", target}

	case "commit":
		message := content
		if message == "" {
			message = "Auto-commit by Worker"
		}
		gitCmd = []string{"git", "commit", "-m", message}

	case "reset":
		gitCmd = []string{"git", "reset", target}

	case "checkout":
		gitCmd = []string{"git", "checkout", target}

	default:
		return "", fmt.Errorf("unknown git_operation action: %s", action)
	}

	// Git コマンド実行
	execCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	cmdExec := exec.CommandContext(execCtx, gitCmd[0], gitCmd[1:]...)
	cmdExec.Dir = a.workspace

	output, err := cmdExec.CombinedOutput()
	if err != nil {
		return string(output), fmt.Errorf("git command failed: %w (output: %s)", err, string(output))
	}

	return string(output), nil
}
```

**セキュリティ考慮**:
- タイムアウト設定（デフォルト: 30秒）
- workspace をカレントディレクトリに固定
- force 系コマンド（`git push --force`）は許可（ユーザー責任）

---

### 2.7 autoCommitChanges() - Git auto-commit

**目的**: Worker が実行したすべての変更を自動コミットする。

**シグネチャ**:
```go
func (a *AgentLoop) autoCommitChanges(ctx context.Context, patch string) (string, error)
```

**実装**:
```go
func (a *AgentLoop) autoCommitChanges(ctx context.Context, patch string) (string, error) {
	// 1. git add -A（すべての変更をステージング）
	addCmd := exec.CommandContext(ctx, "git", "add", "-A")
	addCmd.Dir = a.workspace
	if output, err := addCmd.CombinedOutput(); err != nil {
		return "", fmt.Errorf("git add failed: %w (output: %s)", err, string(output))
	}

	// 2. コミットメッセージ生成
	prefix := a.cfg.Worker.CommitMessagePrefix
	if prefix == "" {
		prefix = "[Worker Auto-Commit]"
	}

	// patch の最初の行を抜粋（最大 80 文字）
	patchSummary := strings.Split(patch, "\n")[0]
	if len(patchSummary) > 80 {
		patchSummary = patchSummary[:80] + "..."
	}

	commitMsg := fmt.Sprintf("%s %s", prefix, patchSummary)

	// 3. git commit
	commitCmd := exec.CommandContext(ctx, "git", "commit", "-m", commitMsg)
	commitCmd.Dir = a.workspace
	if output, err := commitCmd.CombinedOutput(); err != nil {
		// コミット対象がない場合（nothing to commit）もエラーになるが、ログのみ
		if strings.Contains(string(output), "nothing to commit") {
			return "", nil
		}
		return "", fmt.Errorf("git commit failed: %w (output: %s)", err, string(output))
	}

	// 4. コミットハッシュを取得
	hashCmd := exec.CommandContext(ctx, "git", "rev-parse", "HEAD")
	hashCmd.Dir = a.workspace
	hashOutput, err := hashCmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get commit hash: %w", err)
	}

	commitHash := strings.TrimSpace(string(hashOutput))
	return commitHash, nil
}
```

**設定**:
- `WorkerConfig.AutoCommit` (bool): auto-commit を有効化するか
- `WorkerConfig.CommitMessagePrefix` (string): コミットメッセージの接頭辞（デフォルト: `[Worker Auto-Commit]`）

---

## 3. 設定追加（pkg/config/config.go）

### 3.1 WorkerConfig 構造体

```go
// WorkerConfig は Worker の設定
type WorkerConfig struct {
	AutoCommit         bool   `json:"auto_commit" env:"PICOCLAW_WORKER_AUTO_COMMIT"`
	CommitMessagePrefix string `json:"commit_message_prefix" env:"PICOCLAW_WORKER_COMMIT_PREFIX"`
	CommandTimeout     int    `json:"command_timeout" env:"PICOCLAW_WORKER_COMMAND_TIMEOUT"` // 秒単位
	GitTimeout         int    `json:"git_timeout" env:"PICOCLAW_WORKER_GIT_TIMEOUT"`       // 秒単位
	StopOnError        bool   `json:"stop_on_error" env:"PICOCLAW_WORKER_STOP_ON_ERROR"`   // エラー時に中断するか
}
```

### 3.2 Config 構造体への追加

```go
type Config struct {
	// ... 既存フィールド ...
	Worker WorkerConfig `json:"worker"`
}
```

### 3.3 デフォルト値

```go
func DefaultConfig() *Config {
	return &Config{
		// ... 既存設定 ...
		Worker: WorkerConfig{
			AutoCommit:         false, // デフォルトは無効
			CommitMessagePrefix: "[Worker Auto-Commit]",
			CommandTimeout:     300, // 5分
			GitTimeout:         30,  // 30秒
			StopOnError:        false, // 継続モード
		},
	}
}
```

---

## 4. 実装順序

### フェーズ 1: 基本構造の実装

1. `PatchCommand` および `PatchExecutionResult` 構造体を定義
2. `parsePatch()` を実装（JSON フォーマットのみ）
3. `executeCommand()` のディスパッチロジックを実装
4. `executeFileEdit()` を実装（create, update, delete のみ）

### フェーズ 2: コマンド実行の拡張

5. `executeShellCommand()` を実装
6. `executeGitOperation()` を実装
7. `parsePatch()` に Markdown フォーマット対応を追加

### フェーズ 3: auto-commit とエラーハンドリング

8. `autoCommitChanges()` を実装
9. `WorkerConfig` を追加
10. エラーハンドリングを強化（継続モード / 中断モード）

### フェーズ 4: 統合とテスト

11. `executeWorkerPatch()` を pkg/agent/loop.go に統合
12. Coder3 の出力処理（L497-L520 削除箇所）を置き換え
13. ユニットテスト作成
14. 統合テスト（End-to-End）

---

## 5. テスト戦略

### 5.1 ユニットテスト

| テスト対象 | テストケース |
|-----------|-------------|
| `parsePatch()` | JSON フォーマット（正常・異常）、Markdown フォーマット（正常・異常）、空 patch |
| `executeFileEdit()` | create, update, delete, append, workspace 外パス |
| `executeShellCommand()` | 正常実行、エラー、タイムアウト |
| `executeGitOperation()` | add, commit, reset, checkout, エラー |
| `autoCommitChanges()` | 正常コミット、nothing to commit、エラー |

### 5.2 統合テスト

| シナリオ | 検証内容 |
|---------|---------|
| 完全な patch 実行 | JSON patch → 複数コマンド実行 → 結果確認 |
| エラーハンドリング | 1つのコマンドが失敗 → 継続 → 結果に反映 |
| auto-commit | AutoCommit=true → コミット生成 → ハッシュ確認 |
| セキュリティ | workspace 外パス → 拒否、タイムアウト → 中断 |

---

## 6. エラーハンドリング詳細

### 6.1 パースエラー

- **発生条件**: JSON 不正、不明なコードブロック
- **対応**: エラーを返し、実行を中断
- **ユーザーメッセージ**: "patch のフォーマットが不正だよ。JSON または Markdown で書いてね。"

### 6.2 コマンド実行エラー

- **発生条件**: ファイル書き込み失敗、シェルコマンド失敗、Git エラー
- **対応（継続モード）**: エラーを記録し、次のコマンドへ進む
- **対応（中断モード）**: 即座に実行を中断し、エラーを返す
- **ユーザーメッセージ**: "コマンド実行に失敗したよ: [詳細]"

### 6.3 タイムアウト

- **発生条件**: シェルコマンドまたは Git 操作がタイムアウト
- **対応**: プロセスを強制終了し、エラーとして記録
- **ユーザーメッセージ**: "コマンドがタイムアウトしたよ（制限時間: X 秒）"

### 6.4 セキュリティ違反

- **発生条件**: workspace 外へのファイル書き込み試行
- **対応**: 即座に拒否し、エラーを返す
- **ユーザーメッセージ**: "セキュリティエラー: workspace 外への書き込みは許可されていないよ。"

---

## 7. ログ設計

### 7.1 ログイベント

| イベント | Component | Message | Fields |
|---------|-----------|---------|--------|
| patch 実行開始 | worker | worker.patch_execution_start | patch, session_key |
| コマンド実行成功 | worker | worker.command_executed | command_index, type, action, target |
| コマンド実行失敗 | worker | worker.command_failed | command_index, type, action, target, error |
| patch 実行完了 | worker | worker.patch_execution_complete | success, executed_cmds, failed_cmds, summary |
| auto-commit 成功 | worker | worker.auto_commit_success | commit |
| auto-commit 失敗 | worker | worker.auto_commit_failed | error |

### 7.2 ログレベル

- **INFO**: 正常実行（コマンド実行、auto-commit 成功）
- **WARN**: 軽微なエラー（auto-commit 失敗、nothing to commit）
- **ERROR**: 重大なエラー（パースエラー、セキュリティ違反、コマンド失敗）

---

## 8. 実装例: 統合コード

### 8.1 pkg/agent/loop.go への統合

削除箇所（L497-L520）を以下のコードに置き換え:

```go
} else if coderOutput.NeedApproval {
	// 【旧】承認フロー → 【新】即時実行
	logger.InfoCF("worker", "worker.patch_execution_start", map[string]interface{}{
		"patch":       coderOutput.Patch,
		"session_key": sessionKey,
	})

	result, err := al.executeWorkerPatch(ctx, coderOutput.Patch, sessionKey)
	if err != nil {
		response = fmt.Sprintf("patch の実行に失敗したよ: %v", err)
		logger.ErrorCF("worker", "worker.patch_execution_error", map[string]interface{}{
			"error": err.Error(),
		})
	} else {
		// 実行結果をユーザーに返す
		response = fmt.Sprintf("実行完了！\n\n%s\n\n詳細:\n%s",
			result.Summary,
			formatExecutionResults(result.Results))

		if result.GitCommit != "" {
			response += fmt.Sprintf("\n\nGit コミット: %s", result.GitCommit)
		}

		logger.InfoCF("worker", "worker.patch_execution_complete", map[string]interface{}{
			"success":       result.Success,
			"executed_cmds": result.ExecutedCmds,
			"failed_cmds":   result.FailedCmds,
			"summary":       result.Summary,
		})
	}
```

### 8.2 formatExecutionResults() ヘルパー

```go
func formatExecutionResults(results []CommandResult) string {
	var lines []string
	for i, r := range results {
		status := "✓"
		if !r.Success {
			status = "✗"
		}
		line := fmt.Sprintf("%s [%d] %s %s %s (%dms)",
			status, i+1, r.Command.Type, r.Command.Action, r.Command.Target, r.Duration)
		if r.Error != "" {
			line += fmt.Sprintf("\n    エラー: %s", r.Error)
		}
		lines = append(lines, line)
	}
	return strings.Join(lines, "\n")
}
```

---

## 9. セキュリティチェックリスト

実装時に以下を確認すること:

- [ ] workspace 外へのファイル書き込みを禁止している
- [ ] シンボリックリンクトラバーサルを防止している
- [ ] タイムアウトを適切に設定している
- [ ] コマンドインジェクション対策（ユーザー入力を直接 shell に渡さない）
- [ ] エラーメッセージに機密情報（API キー等）を含めない

---

## 10. 今後の拡張

### 10.1 Dry-run モード

- `WorkerConfig.DryRun` を追加
- `true` の場合、コマンドを実行せず、実行予定を表示するのみ

### 10.2 Rollback 機能

- 実行前に Git スナップショットを作成
- エラー時に自動 rollback（`git reset --hard`）

### 10.3 並列実行

- 独立したコマンドを並列実行（依存関係を解析）

---

**最終更新**: 2026-02-28
**作成者**: Claude (Serena Agent)
**関連ドキュメント**:
- [20260228_承認フロー廃止プラン.md](./20260228_承認フロー廃止プラン.md)
- [20260228_承認フロー削除箇所リスト.md](./20260228_承認フロー削除箇所リスト.md)
