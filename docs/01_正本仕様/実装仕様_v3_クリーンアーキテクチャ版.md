# PicoClaw 実装仕様 v3.0 クリーンアーキテクチャ版

**作成日**: 2026-03-01
**バージョン**: 3.0
**ベース**: v1.0（理想的Clean Architecture）+ v2.0（実践的Event Sourcing）+ 仕様書（要件）
**ステータス**: 正本仕様（実装の一次参照）

---

## 目次

- [0. エグゼクティブサマリ](#0-エグゼクティブサマリ)
- [1. アーキテクチャ設計](#1-アーキテクチャ設計)
- [2. パッケージ構造](#2-パッケージ構造)
- [3. スコープ・責務境界](#3-スコープ責務境界)
- [4. Domain層実装詳細](#4-domain層実装詳細)
- [5. ルーティング決定仕様](#5-ルーティング決定仕様)
- [6. ループ制御と再ルート](#6-ループ制御と再ルート)
- [7. I/O契約](#7-io契約)
- [8. ワーカー仕様](#8-ワーカー仕様)
- [9. Worker即時実行仕様](#9-worker即時実行仕様)
- [10. セキュリティ仕様](#10-セキュリティ仕様)
- [11. ログ仕様](#11-ログ仕様)
- [12. 状態管理とセッション](#12-状態管理とセッション)
- [13. 設定値と閾値](#13-設定値と閾値)
- [14. 実装プラン](#14-実装プラン)
- [15. テスト観点](#15-テスト観点)
- [16. Application層実装詳細](#16-application層実装詳細)
- [17. Infrastructure層実装詳細](#17-infrastructure層実装詳細)
- [18. Adapter層実装詳細](#18-adapter層実装詳細)
- [付録A: 既存仕様との差分マップ](#付録a-既存仕様との差分マップ)
- [付録B: 用語集](#付録b-用語集)
- [付録C: 参考文献](#付録c-参考文献)

---

## 0. エグゼクティブサマリ

### 0.1 なぜv3.0クリーンアーキテクチャ版か

**背景**:
- 既存実装（pkg/agent/loop.go中心）は1,980行に肥大化、保守困難
- Worker実行委譲（60%）が未完成
- アーキテクチャ設計の明文化が不足、実装判断が属人化
- **承認フロー廃止決定**（2026-02-28）: PicoClaw基本思想「完全自動」に回帰

**v3.0の位置付け**:
- **v1.0（理想）**: Clean Architecture、DDD、Wire DI → 完璧な層分離
- **v2.0（実用）**: Event Sourcing、承認フロー（廃止済） → 段階的移行
- **v3.0（統合）**: v1.0 + v2.0 + 仕様書要件 + **Worker即時実行** → **実装可能な最適解**

### 0.2 期待効果

| 効果 | 詳細 | KPI |
|------|------|-----|
| **完全性** | 仕様100%準拠（LINE固定、Mio委譲、Worker即時実行） | 仕様準拠率100% |
| **保守性** | Agent Loop分解（1,980行 → 5サービス）、Clean Architecture | 変更影響範囲-70% |
| **自動化** | 承認なし即時実行、高速応答 | 平均応答時間-50% |
| **セーフガード** | 詳細ログ、Git auto-commit、ドライモードで安全性確保 | 巻き戻し成功率100% |
| **拡張性** | 新Agent/Provider/Route 追加が数十行 | 新機能追加工数-50% |
| **テスタビリティ** | 各層独立、モック・スタブ容易 | Domain層カバレッジ90% |

### 0.3 実装期間

**8週間**（Phase 1-4）

| Phase | 期間 | 内容 | マイルストーン |
|-------|------|------|--------------|
| Phase 1 | 2週間 | Domain層 | Domain層90%カバレッジ、PatchCommand動作確認 |
| Phase 2 | 3週間 | Application層 + Infrastructure層 | E2Eテスト（Worker即時実行）成功 |
| Phase 3 | 2週間 | Adapter層 + Wire DI | 全シナリオE2Eテスト成功 |
| Phase 4 | 1週間 | 本番移行 | 仕様100%準拠、性能劣化10%以内 |

### 0.4 主要設計決定

1. **Clean Architecture 4層構造**: Domain → Application → Infrastructure → Adapter
2. **Worker即時実行**: Coder3 plan/patch生成 → Worker即時適用（承認なし）
3. **DDD**: MioAgent/ShiroAgent/CoderAgent エンティティ、PatchCommand 値オブジェクト
4. **Wire DI**: 依存性注入による疎結合
5. **仕様準拠**: LINE入口CHAT固定、Mio委譲判断
6. **セーフガード**: 詳細ログ、Git auto-commit、ドライモードで安全性確保

---

## 1. アーキテクチャ設計

### 1.1 Clean Architecture 4層構造

```
┌──────────────────────────────────────┐
│  Adapter Layer (外部インターフェース)  │ ← LINE, Slack, CLI Webhook
│  - LINE Handler (CHAT固定)           │
│  - Slack/CLI Handler                │
│  - Notification Sender              │
└──────────────────────────────────────┘
           ↓ 依存（Use Case呼び出し）
┌──────────────────────────────────────┐
│ Application Layer (Use Cases)       │
│  - ProcessUserMessage               │
│  - WorkerExecutionService           │
│  - MessageOrchestrator (分解済み)    │
│  - Services (Routing, Worker実行等) │
└──────────────────────────────────────┘
           ↓ 依存（Domain呼び出し）
┌──────────────────────────────────────┐
│ Domain Layer (ビジネスロジック)       │
│  - MioAgent/ShiroAgent/CoderAgent   │
│  - PatchCommand (Value Object)     │
│  - Task, Proposal (Value Object)   │
└──────────────────────────────────────┘
           ↑ 依存性逆転（interface）
┌──────────────────────────────────────┐
│ Infrastructure Layer (技術詳細)      │
│  - LLM Providers (Ollama/Claude等)  │
│  - ToolRunner (ファイル編集/コマンド)│
│  - Config Loader                   │
│  - Logger                          │
└──────────────────────────────────────┘
```

**依存方向**: 外層 → 内層（Domain層は何にも依存しない）

### 1.2 セーフガード設計

承認なし即時実行でも、以下のセーフガードで安全性を確保:

**1. 詳細ログ記録**（必須）:
- 実行前: plan/patch 全文、実行サマリ（コマンド数、種別）
- 実行中: 各コマンドの stdout/stderr
- 実行後: 実行結果、変更ファイルリスト

**2. Git auto-commit**（推奨、有効化時は必須）:
- 実行前後に自動コミット
- `git revert` で即座に巻き戻し可能
- コミットメッセージ: `[Worker Auto-Commit] Before/After patch: <summary>`
- **重要**: `AutoCommit=true` の場合、コミット失敗 = 実行中断（安全性担保）

**3. 保護ファイルパターン**（推奨）:
- 機密ファイルの誤削除・誤編集を防止
- デフォルト保護パターン: `.env*`, `*credentials*`, `*.key`, `*.pem`
- 保護ファイルへの操作は即座にエラー

**4. ドライモード**（オプション）:
- `PICOCLAW_DRY_RUN=true` で有効化
- 実行せず、実行内容のみログ出力
- 破壊的操作の事前確認に有用

**5. ワークスペース制限**（必須）:
- ファイル操作は workspace 内のみ許可
- workspace 外への書き込みはエラー

**6. 実行前サマリ表示**（推奨）:
- 実行前に変更内容の概要をログ出力
- コマンド総数、種別（file_edit/shell_command/git_operation）
- トラブルシューティングの効率化

### 1.3 DDD（Domain-Driven Design）

| パターン | 実装例 | 役割 |
|---------|--------|------|
| **エンティティ** | MioAgent, ShiroAgent, CoderAgent | 一意性を持つドメインオブジェクト |
| **値オブジェクト** | Task, JobID, Proposal, RoutingDecision, PatchCommand | 不変、値の等価性で比較 |
| **サービス** | ToolRunner, WorkerExecutionService | ドメインロジックの調整 |

### 1.4 Wire依存性注入

```go
// cmd/picoclaw/wire.go
//go:build wireinject
// +build wireinject

func InitializeApp(cfg *config.Config) (*App, error) {
    wire.Build(
        // Infrastructure
        provideLLMProviders,
        provideToolRunner,
        provideLogger,

        // Domain Entities
        domain.NewMioAgent,
        domain.NewShiroAgent,
        domain.NewCoderAgent,

        // Application Services
        service.NewMessageOrchestrator,
        service.NewWorkerExecutionService,

        // Use Cases
        usecase.NewProcessMessage,

        // Adapters
        adapter.NewLINEHandler,

        // App
        wire.Struct(new(App), "*"),
    )
    return nil, nil
}
```

---

## 2. パッケージ構造

### 2.1 ディレクトリツリー

```
picoclaw_multiLLM/
├── cmd/
│   └── picoclaw/
│       ├── main.go              # エントリーポイント
│       ├── wire.go              # Wire DI設定
│       └── wire_gen.go          # Wire自動生成
│
├── internal/
│   ├── domain/                  # Domain層（純粋ビジネスロジック）
│   │   ├── agent/
│   │   │   ├── mio_agent.go    # Mio（Chat）エンティティ
│   │   │   ├── shiro_agent.go  # Shiro（Worker）エンティティ
│   │   │   ├── coder_agent.go  # Coder エンティティ
│   │   │   ├── classifier.go   # Classifier インターフェース
│   │   │   ├── rule_dictionary.go # RuleDictionary 型
│   │   │   ├── role.go         # Role enum
│   │   │   └── events.go       # Agent Domain Events
│   │   ├── worker/
│   │   │   ├── tool_runner.go  # ToolRunner インターフェース
│   │   │   └── mcp_client.go   # MCPClient インターフェース
│   │   ├── llm/
│   │   │   └── provider.go     # LLMProvider インターフェース
│   │   ├── task/
│   │   │   ├── task.go         # Task 値オブジェクト
│   │   │   └── job_id.go       # JobID 値オブジェクト
│   │   ├── proposal/
│   │   │   └── proposal.go     # Proposal 値オブジェクト
│   │   ├── patch/
│   │   │   ├── command.go      # PatchCommand 値オブジェクト
│   │   │   └── result.go       # PatchExecutionResult 値オブジェクト
│   │   ├── routing/
│   │   │   ├── decision.go     # RoutingDecision 値オブジェクト
│   │   │   └── route.go        # Route enum
│   │   └── session/
│   │       ├── session.go      # Session エンティティ
│   │       └── repository.go   # SessionRepository interface
│   │
│   ├── application/             # Application層（Use Cases + Services）
│   │   ├── usecase/
│   │   │   └── process_message.go    # ProcessUserMessage Use Case
│   │   ├── service/
│   │   │   ├── message_orchestrator.go   # Agent Loop分解の中核
│   │   │   ├── routing_service.go        # ルーティング決定
│   │   │   ├── llm_iterator_service.go   # LLM呼び出しループ
│   │   │   ├── worker_execution_service.go # Worker実行
│   │   │   ├── memory_service.go         # メモリ管理
│   │   │   └── types.go                  # Response等の共通型
│   │   └── port/
│   │       ├── inbound.go                # Inbound Port (Use Case interface)
│   │       └── outbound.go               # Outbound Port (Repository interface)
│   │
│   ├── infrastructure/          # Infrastructure層（技術詳細）
│   │   ├── llm/
│   │   │   ├── ollama/         # Ollama Provider（既存活用）
│   │   │   ├── claude/         # Claude Provider（既存活用）
│   │   │   ├── openai/         # OpenAI Provider（既存活用）
│   │   │   └── deepseek/       # DeepSeek Provider（既存活用）
│   │   ├── persistence/
│   │   │   └── session/
│   │   │       └── json_repo.go          # Session Repository（既存活用）
│   │   ├── config/
│   │   │   └── loader.go                 # Layered Config Loader
│   │   └── mcp/
│   │       └── client.go                 # MCP Client（既存活用）
│   │
│   └── adapter/                 # Adapter層（外部インターフェース）
│       ├── inbound/
│       │   ├── line/
│       │   │   └── handler.go            # LINE Webhook Handler
│       │   ├── slack/
│       │   │   └── handler.go            # Slack Handler
│       │   └── cli/
│       │       └── handler.go            # CLI Handler
│       └── outbound/
│           └── notification/
│               └── sender.go             # 通知送信

├── pkg/                         # 公開パッケージ
│   ├── event/
│   │   └── bus.go              # Event Bus
│   ├── logger/
│   │   ├── logger.go           # 構造化ログ（既存活用）
│   │   └── masking.go          # API Key Masking
│   ├── providers/              # LLM Provider抽象化（既存活用）
│   │   └── provider.go
│   └── tools/                  # Tool Registry（既存活用）
│       └── registry.go

└── config/
    ├── config.yaml             # 設定ファイル
    └── config.example.yaml
```

### 2.2 パッケージ間依存関係

```
adapter → application → domain
infrastructure → domain (interface実装)
pkg → すべてから参照可能（共通ライブラリ）
```

**ルール**:
- Domain層は他のどの層にも依存しない
- Application層はDomain層のみに依存
- Infrastructure層はDomain層のinterfaceを実装
- Adapter層はApplication層のUse Caseを呼び出し

---

## 3. スコープ・責務境界

### 3.1 対象プラットフォーム

- **LINE**: メインチャネル（CHAT固定）
- **Slack**: サブチャネル（全ルート対応）
- **CLI**: 開発・デバッグ用（全ルート対応）

### 3.2 役割固定（Chat/Worker/Coder）

| 役割 | 愛称 | 実体LLM（デフォルト） | 責務 |
|------|------|---------------------|------|
| **Chat** | Mio（澪） | Ollama chat-v1:latest | 意思決定・委譲判断・ユーザー対話 |
| **Worker** | Shiro（白） | Ollama worker-v1:latest | 実行・道具係・ツール呼び出し |
| **Coder1** | Aka（赤） | DeepSeek API | 仕様設計向けコーディング |
| **Coder2** | Ao（青） | OpenAI API | 実装向けコーディング |
| **Coder3** | Gin（銀） | Anthropic Claude API | 高品質コーディング・推論 |

**重要**: 役割名は固定、実体LLMは設定で差し替え可能

### 3.3 責務の明確な分離

#### Chat（Mio）の責務

1. **ルーティング決定**（Mio委譲判断）
   - 明示コマンド検出（/code, /analyze等）
   - ルール辞書マッチング
   - 分類器呼び出し（Worker経由）
   - 安全側フォールバック（CHAT）

2. **ユーザー対話**
   - 最終回答生成
   - エラー通知
   - 進捗報告

3. **実行結果の統合**
   - Worker実行結果の受信
   - Coder生成結果の整形
   - 複数ルートの結果統合

#### Worker（Shiro）の責務

1. **ツール実行**
   - ファイル編集
   - コマンド実行
   - テスト実行

2. **差分適用**
   - Coder生成のpatch適用
   - 実行結果の報告

3. **分類補助**
   - ルーティング分類器としての判定

#### Coder（Aka/Ao/Gin）の責務

1. **設計・実装案作成**
   - plan生成
   - patch生成（unified diff形式）
   - risk評価
   - cost_hint提供

2. **コード生成**
   - 新規ファイル作成案
   - 既存ファイル変更案

**重要**: Coderは原則として破壊的操作を**直接実行せず**、plan と patch を生成。実行はWorkerが**即座に**担当。

### 3.4 LINE入口の特殊仕様

**仕様**: LINE入口は必ずCHAT（Mio）に固定（`line_forced_chat`）

**理由**:
- LINE APIの制約（Webhook応答時間制限）
- ユーザー体験の一貫性
- Worker即時実行の確実な動作

**実装**: `internal/adapter/inbound/line/handler.go`

```go
func (h *LINEHandler) HandleMessage(event *linebot.Event) error {
    input := InputMessage{
        Channel:     "line",
        ChatID:      event.Source.UserID,
        Message:     event.Message.Text,
        ForcedRoute: RouteCHAT, // LINE固定
    }
    // ...
}
```

---

## 4. Domain層実装詳細

### 4.1 MioAgent（Chat）エンティティ

**ファイル**: `internal/domain/agent/mio_agent.go`

```go
package agent

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/routing"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// MioAgent は Chat 役割（Mio/澪）のエンティティ
type MioAgent struct {
    role            Role
    ruleDictionary  *RuleDictionary
    classifier      Classifier // Worker呼び出し経由
}

func NewMioAgent(ruleDictionary *RuleDictionary, classifier Classifier) *MioAgent {
    return &MioAgent{
        role:           RoleChat,
        ruleDictionary: ruleDictionary,
        classifier:     classifier,
    }
}

// DecideAction は Mio委譲判断ロジック（仕様準拠: 前段Routerではなく会話中に判断）
func (m *MioAgent) DecideAction(ctx context.Context, t task.Task) (routing.Decision, error) {
    // 1. 明示コマンド優先（/code, /analyze, /plan等）
    if cmd := parseExplicitCommand(t.UserMessage()); cmd != "" {
        return routing.Decision{
            Route:      routing.Route(cmd),
            Source:     "explicit",
            Confidence: 1.0,
        }, nil
    }

    // 2. ルール辞書マッチング（強証拠）
    if route := m.ruleDictionary.Match(t); route != routing.RouteUnknown {
        return routing.Decision{
            Route:      route,
            Source:     "rule",
            Confidence: 0.95,
        }, nil
    }

    // 3. 分類器に問い合わせ（Worker呼び出し）
    decision, err := m.classifier.Classify(ctx, t)
    if err != nil || decision.Confidence < 0.7 {
        // 4. 安全側フォールバック（CHAT）
        return routing.Decision{
            Route:      routing.RouteCHAT,
            Source:     "fallback",
            Confidence: 0.5,
        }, nil
    }

    return decision, nil
}

// Role returns the agent's role
func (m *MioAgent) Role() Role {
    return m.role
}

// parseExplicitCommand は明示コマンドを解析（/code, /analyze等）
func parseExplicitCommand(message string) string {
    // 明示コマンドマッピング
    commands := map[string]string{
        "/chat":    "CHAT",
        "/plan":    "PLAN",
        "/analyze": "ANALYZE",
        "/ops":     "OPS",
        "/research": "RESEARCH",
        "/code":    "CODE",
        "/code1":   "CODE1",
        "/code2":   "CODE2",
        "/code3":   "CODE3",
    }

    // メッセージの先頭から明示コマンドを検出
    for cmd, route := range commands {
        if strings.HasPrefix(strings.TrimSpace(message), cmd) {
            return route
        }
    }

    return "" // 明示コマンドなし
}
```

### 4.2 ShiroAgent（Worker）エンティティ

**ファイル**: `internal/domain/agent/shiro_agent.go`

```go
package agent

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/proposal"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// ShiroAgent は Worker 役割（Shiro/白）のエンティティ
type ShiroAgent struct {
    role        Role
    toolRunner  ToolRunner
    mcpClient   MCPClient
}

func NewShiroAgent(toolRunner ToolRunner, mcpClient MCPClient) *ShiroAgent {
    return &ShiroAgent{
        role:       RoleWorker,
        toolRunner: toolRunner,
        mcpClient:  mcpClient,
    }
}

// Execute は Worker実行（ツール呼び出し、patch適用）
// 注: この実装はDomain層の責務として簡略化。実際の複雑な実行ロジックは
// Application層のWorkerExecutionServiceで実装される。
func (s *ShiroAgent) Execute(ctx context.Context, t task.Task, p proposal.Proposal) (*patch.PatchExecutionResult, error) {
    // Domain層では基本的な実行フローのみ定義
    // 詳細な実装はApplication層（WorkerExecutionService）を参照

    // 実装例（簡略版）:
    // 1. Patch解析は parsePatch() で実施
    // 2. Chrome操作検出
    // 3. 通常ツール実行

    // 実際の実装はWorkerExecutionService.ExecuteProposal()を参照
    return nil, fmt.Errorf("not implemented: use WorkerExecutionService.ExecuteProposal()")
}

// Role returns the agent's role
func (s *ShiroAgent) Role() Role {
    return s.role
}
```

### 4.3 CoderAgent エンティティ

**ファイル**: `internal/domain/agent/coder_agent.go`

```go
package agent

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/proposal"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// CoderAgent は Coder 役割（Aka/Ao/Gin）のエンティティ
type CoderAgent struct {
    role     Role
    variant  CoderVariant // CODE1, CODE2, CODE3
    provider LLMProvider
}

type CoderVariant string

const (
    CoderVariantAka CoderVariant = "aka" // DeepSeek（仕様設計）
    CoderVariantAo  CoderVariant = "ao"  // OpenAI（実装）
    CoderVariantGin CoderVariant = "gin" // Claude（高品質）
)

func NewCoderAgent(variant CoderVariant, provider LLMProvider) *CoderAgent {
    return &CoderAgent{
        role:     RoleCoder,
        variant:  variant,
        provider: provider,
    }
}

// GenerateProposal は Coder提案生成（plan/patch/risk/cost_hint）
func (c *CoderAgent) GenerateProposal(ctx context.Context, t task.Task) (*proposal.Proposal, error) {
    // LLM呼び出し
    response, err := c.provider.Generate(ctx, GenerateRequest{
        Messages: buildMessages(t),
        // ...
    })
    if err != nil {
        return nil, err
    }

    // plan/patch/risk/cost_hint 抽出
    p := proposal.NewProposal(
        extractPlan(response),
        extractPatch(response),
        extractRisk(response),
        extractCostHint(response),
    )

    return p, nil
}

// Role returns the agent's role
func (c *CoderAgent) Role() Role {
    return c.role
}

// buildMessages はタスクからLLMメッセージを構築
func buildMessages(t task.Task) []llm.Message {
    return []llm.Message{
        {
            Role:    "user",
            Content: t.UserMessage(),
        },
    }
}

// extractPlan はLLM応答からplanを抽出
func extractPlan(response llm.GenerateResponse) string {
    // レスポンスから「## Plan」セクションを抽出
    content := response.Content
    planStart := strings.Index(content, "## Plan")
    if planStart == -1 {
        return ""
    }

    // 次のセクション（## Patch等）までを抽出
    planEnd := strings.Index(content[planStart+7:], "##")
    if planEnd == -1 {
        return strings.TrimSpace(content[planStart+7:])
    }

    return strings.TrimSpace(content[planStart+7 : planStart+7+planEnd])
}

// extractPatch はLLM応答からpatchを抽出
func extractPatch(response llm.GenerateResponse) string {
    // レスポンスから「## Patch」セクションを抽出
    content := response.Content
    patchStart := strings.Index(content, "## Patch")
    if patchStart == -1 {
        return ""
    }

    // 次のセクション（## Risk等）までを抽出
    patchEnd := strings.Index(content[patchStart+8:], "##")
    if patchEnd == -1 {
        return strings.TrimSpace(content[patchStart+8:])
    }

    return strings.TrimSpace(content[patchStart+8 : patchStart+8+patchEnd])
}

// extractRisk はLLM応答からriskを抽出
func extractRisk(response llm.GenerateResponse) proposal.RiskLevel {
    // レスポンスから「## Risk」セクションを抽出
    content := response.Content
    riskStart := strings.Index(content, "## Risk")
    if riskStart == -1 {
        return proposal.RiskLevelMedium
    }

    riskSection := content[riskStart : riskStart+50] // 最初の50文字を検査

    // Risk levelを判定
    if strings.Contains(strings.ToLower(riskSection), "high") {
        return proposal.RiskLevelHigh
    } else if strings.Contains(strings.ToLower(riskSection), "low") {
        return proposal.RiskLevelLow
    }

    return proposal.RiskLevelMedium
}

// extractCostHint はLLM応答からcost_hintを抽出
func extractCostHint(response llm.GenerateResponse) string {
    // レスポンスから「## Cost」セクションを抽出
    content := response.Content
    costStart := strings.Index(content, "## Cost")
    if costStart == -1 {
        return ""
    }

    // 次のセクションまでを抽出
    costEnd := strings.Index(content[costStart+7:], "##")
    if costEnd == -1 {
        return strings.TrimSpace(content[costStart+7:])
    }

    return strings.TrimSpace(content[costStart+7 : costStart+7+costEnd])
}
```

### 4.4 Domain層インターフェース定義

#### Classifier インターフェース

**ファイル**: `internal/domain/agent/classifier.go`

```go
package agent

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/routing"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// Classifier はルーティング分類器（Worker経由でLLM呼び出し）
type Classifier interface {
    Classify(ctx context.Context, t task.Task) (routing.Decision, error)
}
```

#### RuleDictionary 型

**ファイル**: `internal/domain/agent/rule_dictionary.go`

```go
package agent

import (
    "github.com/sipeed/picoclaw/internal/domain/routing"
    "github.com/sipeed/picoclaw/internal/domain/task"
    "regexp"
)

// RuleDictionary はルーティングルール辞書
type RuleDictionary struct {
    rules []RoutingRule
}

type RoutingRule struct {
    Pattern    string         // 正規表現パターン
    Route      routing.Route  // ルーティング先
    Confidence float64        // 確信度（0.0-1.0）
}

func NewRuleDictionary(rules []RoutingRule) *RuleDictionary {
    return &RuleDictionary{rules: rules}
}

// Match はタスクメッセージとルールをマッチング
func (rd *RuleDictionary) Match(t task.Task) routing.Route {
    message := t.UserMessage()

    for _, rule := range rd.rules {
        matched, _ := regexp.MatchString(rule.Pattern, message)
        if matched {
            return rule.Route
        }
    }

    return routing.RouteUnknown
}
```

#### ToolRunner インターフェース

**ファイル**: `internal/domain/worker/tool_runner.go`

```go
package worker

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/patch"
)

// ToolRunner はツール実行インターフェース（pkg/tools/registry.goの抽象化）
type ToolRunner interface {
    Execute(ctx context.Context, cmd patch.PatchCommand) (string, error)
}
```

#### MCPClient インターフェース

**ファイル**: `internal/domain/worker/mcp_client.go`

```go
package worker

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/patch"
)

// MCPClient は MCP (Model Context Protocol) クライアント
type MCPClient interface {
    Execute(ctx context.Context, commands []patch.PatchCommand) (*MCPResult, error)
}

type MCPResult struct {
    Success bool
    Output  string
    Error   error
}
```

#### LLMProvider インターフェース

**ファイル**: `internal/domain/llm/provider.go`

```go
package llm

import "context"

// LLMProvider はLLMプロバイダーの抽象化
// 実装は pkg/providers/ に存在
type LLMProvider interface {
    Generate(ctx context.Context, req GenerateRequest) (GenerateResponse, error)
}

type GenerateRequest struct {
    Messages    []Message
    MaxTokens   int
    Temperature float64
    SystemPrompt string
}

type GenerateResponse struct {
    Content     string
    TokensUsed  int
    FinishReason string
}

type Message struct {
    Role    string // "user", "assistant", "system"
    Content string
}
```

### 4.5 Task 値オブジェクト

**ファイル**: `internal/domain/task/task.go`

```go
package task

import (
    "github.com/sipeed/picoclaw/internal/domain/routing"
)

// Task は不変の値オブジェクト
type Task struct {
    jobID       JobID
    userMessage string
    channel     string
    chatID      string
    route       routing.Route
    forcedRoute routing.Route // LINE固定等で使用
}

func NewTask(jobID JobID, userMessage, channel, chatID string) Task {
    return Task{
        jobID:       jobID,
        userMessage: userMessage,
        channel:     channel,
        chatID:      chatID,
        route:       routing.RouteUnknown,
    }
}

// Getters（不変性を保証）
func (t Task) JobID() JobID                { return t.jobID }
func (t Task) UserMessage() string         { return t.userMessage }
func (t Task) Channel() string             { return t.channel }
func (t Task) ChatID() string              { return t.chatID }
func (t Task) Route() routing.Route        { return t.route }
func (t Task) ForcedRoute() routing.Route  { return t.forcedRoute }

// WithRoute returns a new Task with updated route
func (t Task) WithRoute(route routing.Route) Task {
    t.route = route
    return t
}

// WithForcedRoute returns a new Task with forced route (LINE固定等)
func (t Task) WithForcedRoute(route routing.Route) Task {
    t.forcedRoute = route
    return t
}
```

### 4.5 JobID 値オブジェクト

**ファイル**: `internal/domain/task/job_id.go`

```go
package task

import (
    "fmt"
    "math/rand"
    "time"
)

// JobID はWorker実行ジョブの一意識別子
type JobID string

func NewJobID() JobID {
    return JobID(fmt.Sprintf("job_%d_%s", time.Now().Unix(), randomString(8)))
}

func randomString(length int) string {
    const charset = "abcdefghijklmnopqrstuvwxyz0123456789"
    b := make([]byte, length)
    for i := range b {
        b[i] = charset[rand.Intn(len(charset))]
    }
    return string(b)
}

func (j JobID) String() string {
    return string(j)
}
```

### 4.6 Proposal 値オブジェクト

**ファイル**: `internal/domain/proposal/proposal.go`

```go
package proposal

// Proposal は Coder生成の提案（不変）
type Proposal struct {
    plan          string
    patch         string
    risk          RiskLevel
    costHint      string
    affectedFiles []string
    flags         map[string]bool // uses_browser等
}

type RiskLevel string

const (
    RiskLow    RiskLevel = "low"
    RiskMedium RiskLevel = "medium"
    RiskHigh   RiskLevel = "high"
)

func NewProposal(plan, patch string, risk RiskLevel, costHint string) *Proposal {
    return &Proposal{
        plan:          plan,
        patch:         patch,
        risk:          risk,
        costHint:      costHint,
        affectedFiles: extractAffectedFiles(patch),
        flags:         make(map[string]bool),
    }
}

// Getters
func (p *Proposal) Plan() string          { return p.plan }
func (p *Proposal) Patch() string         { return p.patch }
func (p *Proposal) Risk() RiskLevel       { return p.risk }
func (p *Proposal) CostHint() string      { return p.costHint }
func (p *Proposal) AffectedFiles() []string { return p.affectedFiles }

// SetFlag sets a boolean flag (e.g., uses_browser)
func (p *Proposal) SetFlag(key string, value bool) {
    p.flags[key] = value
}

// HasFlag checks if a flag is set
func (p *Proposal) HasFlag(key string) bool {
    return p.flags[key]
}

func extractAffectedFiles(patch string) []string {
    // unified diff形式のpatchから変更ファイル一覧を抽出
    // 例: "diff --git a/pkg/test.go b/pkg/test.go" → "pkg/test.go"
    // 実装略
    return []string{}
}
```

### 4.7 PatchCommand 値オブジェクト

**ファイル**: `internal/domain/patch/command.go`

```go
package patch

// PatchCommand は Worker が実行する単一のコマンド（不変）
type PatchCommand struct {
    Type     string            // "file_edit", "shell_command", "git_operation"
    Action   string            // "create", "update", "delete", "run", "add", "commit"
    Target   string            // ファイルパスまたはコマンド
    Content  string            // ファイル内容またはコマンド引数
    Metadata map[string]string // 追加情報

    // Shell Command拡張（TypeShellCommandの場合のみ使用）
    Env      map[string]string // 環境変数（例: {"NODE_ENV": "production"}）
    WorkDir  string            // 作業ディレクトリ（例: "/workspace/frontend"）
    Shell    string            // シェル種別（"bash", "sh", "zsh"、デフォルト: "bash"）
}

// Type constants
const (
    TypeFileEdit      = "file_edit"
    TypeShellCommand  = "shell_command"
    TypeGitOperation  = "git_operation"
)

// Action constants for file_edit
const (
    ActionCreate = "create"  // ファイル作成
    ActionUpdate = "update"  // ファイル上書き
    ActionDelete = "delete"  // ファイル削除
    ActionAppend = "append"  // ファイル末尾追記
    ActionRename = "rename"  // ファイル/ディレクトリ移動・リネーム（Target→Content）
    ActionMkdir  = "mkdir"   // ディレクトリ作成（親ディレクトリも自動作成）
    ActionCopy   = "copy"    // ファイルコピー（Target→Content）
)

// Action constants for shell_command
const (
    ActionRun = "run"
)

// Action constants for git_operation
const (
    ActionAdd      = "add"
    ActionCommit   = "commit"
    ActionReset    = "reset"
    ActionCheckout = "checkout"
)
```

### 4.8 PatchExecutionResult 値オブジェクト

**ファイル**: `internal/domain/patch/result.go`

```go
package patch

// PatchExecutionResult は Worker 実行結果（不変）
type PatchExecutionResult struct {
    Success      bool
    ExecutedCmds int
    FailedCmds   int
    Results      []CommandResult
    Summary      string
    GitCommit    string // auto-commit時のコミットハッシュ
}

type CommandResult struct {
    Command PatchCommand
    Success bool
    Output  string
    Error   string
}
```

### 4.9 Patch解析関数（Domain層）

**ファイル**: `internal/domain/patch/parser.go`

**重要**: parsePatch関連関数はDomain層の純粋なビジネスロジック。Application層のWorkerExecutionServiceから呼び出される。

```go
package patch

import (
    "encoding/json"
    "fmt"
    "regexp"
    "sort"
    "strings"
)

// ParsePatch は JSON または Markdown 形式の patch を解析
func ParsePatch(patchStr string) ([]PatchCommand, error) {
    // JSON 形式判定（先頭が '['）
    trimmed := strings.TrimSpace(patchStr)
    if len(trimmed) > 0 && trimmed[0] == '[' {
        return parseJSONPatch(patchStr)
    }

    // Markdown 形式判定（コードブロック検出）
    if strings.Contains(patchStr, "```go:") || strings.Contains(patchStr, "```bash") {
        return parseMarkdownPatch(patchStr)
    }

    return nil, fmt.Errorf("unknown patch format")
}

// parseJSONPatch は JSON 配列形式の patch を解析
func parseJSONPatch(patchStr string) ([]PatchCommand, error) {
    var commands []PatchCommand

    if err := json.Unmarshal([]byte(patchStr), &commands); err != nil {
        return nil, fmt.Errorf("JSON parse error: %w", err)
    }

    // バリデーション
    for i, cmd := range commands {
        if cmd.Type == "" {
            return nil, fmt.Errorf("command[%d]: type is required", i)
        }
        if cmd.Action == "" {
            return nil, fmt.Errorf("command[%d]: action is required", i)
        }
        if cmd.Target == "" {
            return nil, fmt.Errorf("command[%d]: target is required", i)
        }
    }

    return commands, nil
}

// parseMarkdownPatch は Markdown コードブロック形式の patch を解析
func parseMarkdownPatch(patchStr string) ([]PatchCommand, error) {
    // 位置情報付きコマンド
    type positionedCommand struct {
        pos int
        cmd PatchCommand
    }
    var positioned []positionedCommand

    // 正規表現: ```言語:ファイルパス\n内容\n```
    // (?s) フラグ: DOTALL モード（.が改行にもマッチ）
    reCodeBlock := regexp.MustCompile("(?s)```([a-z]+):([^\n]+)\n(.*?)```")
    matches := reCodeBlock.FindAllStringSubmatchIndex(patchStr, -1)

    for _, match := range matches {
        lang := patchStr[match[2]:match[3]]
        filePath := strings.TrimSpace(patchStr[match[4]:match[5]])
        content := patchStr[match[6]:match[7]]

        cmd := PatchCommand{
            Type:    TypeFileEdit,
            Action:  ActionUpdate,
            Target:  filePath,
            Content: content,
            Metadata: map[string]string{
                "language": lang,
            },
        }
        positioned = append(positioned, positionedCommand{pos: match[0], cmd: cmd})
    }

    // 正規表現: ```bash\nコマンド\n```
    // (?s) フラグ: DOTALL モード（複数行コマンド対応）
    reShellBlock := regexp.MustCompile("(?s)```bash\n(.*?)```")
    shellMatches := reShellBlock.FindAllStringSubmatchIndex(patchStr, -1)

    for _, match := range shellMatches {
        command := strings.TrimSpace(patchStr[match[2]:match[3]])

        cmd := PatchCommand{
            Type:   TypeShellCommand,
            Action: ActionRun,
            Target: command,
        }
        positioned = append(positioned, positionedCommand{pos: match[0], cmd: cmd})
    }

    if len(positioned) == 0 {
        return nil, fmt.Errorf("no valid code blocks found in Markdown patch")
    }

    // 出現順にソート
    sort.Slice(positioned, func(i, j int) bool {
        return positioned[i].pos < positioned[j].pos
    })

    // コマンドリストに変換
    commands := make([]PatchCommand, len(positioned))
    for i, p := range positioned {
        commands[i] = p.cmd
    }

    return commands, nil
}
```

### 4.10 Session エンティティ

**ファイル**: `internal/domain/session/session.go`

```go
package session

import (
    "time"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// Session はユーザーセッションを表すエンティティ
// 日次カットオーバーで切り替わり、会話履歴とメモリを保持
type Session struct {
    id        string           // セッションID（日付ベース: "20260301"）
    channel   string           // チャネル（LINE/Slack等）
    chatID    string           // チャットID
    history   []task.Task      // 会話履歴
    memory    map[string]interface{} // セッションメモリ
    createdAt time.Time        // セッション作成時刻
    updatedAt time.Time        // 最終更新時刻
}

// NewSession は新しいセッションを作成
func NewSession(id, channel, chatID string) *Session {
    now := time.Now()
    return &Session{
        id:        id,
        channel:   channel,
        chatID:    chatID,
        history:   make([]task.Task, 0),
        memory:    make(map[string]interface{}),
        createdAt: now,
        updatedAt: now,
    }
}

// ID はセッションIDを返す
func (s *Session) ID() string {
    return s.id
}

// AddTask はタスクを履歴に追加
func (s *Session) AddTask(t task.Task) {
    s.history = append(s.history, t)
    s.updatedAt = time.Now()
}

// GetHistory は会話履歴を返す
func (s *Session) GetHistory() []task.Task {
    return s.history
}

// SetMemory はメモリに値を設定
func (s *Session) SetMemory(key string, value interface{}) {
    s.memory[key] = value
    s.updatedAt = time.Now()
}

// GetMemory はメモリから値を取得
func (s *Session) GetMemory(key string) (interface{}, bool) {
    value, ok := s.memory[key]
    return value, ok
}

// ClearMemory はメモリをクリア
func (s *Session) ClearMemory() {
    s.memory = make(map[string]interface{})
    s.updatedAt = time.Now()
}
```

**SessionRepository インターフェース**:

**ファイル**: `internal/domain/session/repository.go`

```go
package session

import "context"

// SessionRepository はセッション永続化の抽象化
type SessionRepository interface {
    Save(ctx context.Context, session *Session) error
    Load(ctx context.Context, id string) (*Session, error)
    Delete(ctx context.Context, id string) error
    Exists(ctx context.Context, id string) (bool, error)
}
```

**実装メモ**:
- Infrastructure層で `JSONSessionRepository` を実装（既存の `pkg/session/manager.go` を活用）
- 日次カットオーバーロジックは Application層の `SessionManager` で実装
- セッションIDフォーマット: `YYYYMMDD-{channel}-{chatID}`（例: `20260301-line-U123456`）

---

## 5. ルーティング決定仕様

### 5.1 ルーティングカテゴリ

| カテゴリ | 説明 | 担当Agent | 用途例 |
|---------|------|----------|--------|
| `CHAT` | 会話・意思決定 | Mio（Chat） | 雑談、質問応答、対話管理 |
| `PLAN` | 計画策定 | Mio（Chat） | プロジェクト計画、タスク分解 |
| `ANALYZE` | 分析 | Shiro（Worker） | ログ分析、性能分析 |
| `OPS` | 運用操作 | Shiro（Worker） | デプロイ、再起動、設定変更 |
| `RESEARCH` | 調査 | Shiro（Worker） | 文献調査、API仕様調査 |
| `CODE` | コーディング（汎用） | Aka/Ao/Gin（Coder） | 一般的なコーディング |
| `CODE1` | 仕様設計向け | Aka（Coder1） | アーキテクチャ設計、仕様策定 |
| `CODE2` | 実装向け | Ao（Coder2） | 実装、テストコード作成 |
| `CODE3` | 高品質コーディング/推論 | Gin（Coder3） | 難解な実装、最適化、高度な推論 |

### 5.2 Mio委譲判断の4段階優先順位

**仕様準拠**: 前段Routerではなく、Mioが会話中に委譲判断を行う

#### 優先度1: 明示コマンド（最優先）

ユーザーが明示的にコマンドを指定した場合、それを優先。

**明示コマンド一覧**:
- `/chat` → CHAT
- `/plan` → PLAN
- `/analyze` → ANALYZE
- `/ops` → OPS
- `/research` → RESEARCH
- `/code` → CODE（デフォルトCoder）
- `/code1` → CODE1（Aka）
- `/code2` → CODE2（Ao）
- `/code3` → CODE3（Gin）

**実装**: `MioAgent.DecideAction()`の最初でチェック

#### 優先度2: ルール辞書（強証拠）

明示コマンドがない場合、ルール辞書でマッチング。

**ルール辞書例**:
```yaml
rules:
  - pattern: "ファイルを作成"
    route: CODE
    confidence: 0.95

  - pattern: "ログを確認"
    route: ANALYZE
    confidence: 0.9

  - pattern: "状態|status|確認"
    route: CHAT
    confidence: 1.0
```

#### 優先度3: 分類器（LLM判定）

ルール辞書でマッチしない場合、Worker（Shiro）を分類器として呼び出し。

**分類器プロンプト**（Worker）:
```
以下のメッセージを分類してください:
"{user_message}"

以下のカテゴリから最も適切なものを選んでください:
- CHAT: 会話・質問応答
- CODE: コーディング
- ANALYZE: 分析
- OPS: 運用操作
- RESEARCH: 調査

JSON形式で回答してください:
{
  "route": "CHAT",
  "confidence": 0.85,
  "reason": "..."
}
```

#### 優先度4: 安全側フォールバック

分類器が失敗またはConfidence < 0.7の場合、安全側にCHATへフォールバック。

**実装**: `MioAgent.DecideAction()`の最後

### 5.3 RoutingDecision 値オブジェクト

**ファイル**: `internal/domain/routing/decision.go`

```go
package routing

// Decision はルーティング決定結果（不変）
type Decision struct {
    Route      Route
    Source     string  // "explicit", "rule", "classifier", "fallback"
    Confidence float64 // 0.0 ~ 1.0
    Reason     string  // 判定理由
}

func NewDecision(route Route, source string, confidence float64) Decision {
    return Decision{
        Route:      route,
        Source:     source,
        Confidence: confidence,
    }
}
```

### 5.4 Route enum

**ファイル**: `internal/domain/routing/route.go`

```go
package routing

type Route string

const (
    RouteUnknown  Route = "UNKNOWN"
    RouteCHAT     Route = "CHAT"
    RoutePLAN     Route = "PLAN"
    RouteANALYZE  Route = "ANALYZE"
    RouteOPS      Route = "OPS"
    RouteRESEARCH Route = "RESEARCH"
    RouteCODE     Route = "CODE"
    RouteCODE1    Route = "CODE1"
    RouteCODE2    Route = "CODE2"
    RouteCODE3    Route = "CODE3"
)

func (r Route) String() string {
    return string(r)
}

func (r Route) IsCoder() bool {
    return r == RouteCODE || r == RouteCODE1 || r == RouteCODE2 || r == RouteCODE3
}
```

---

## 6. ループ制御と再ルート

### 6.1 ループ制限

**max_loops**: 最大ループ回数（デフォルト: 5）
**max_millis**: 最大実行時間（デフォルト: 120000ms = 2分）

ループは以下の条件で終了:
- Worker出力の`needs_next_loop: false`
- max_loops到達
- max_millis到達
- エラー発生

### 6.2 再ルート（自動）

Worker出力の`suggested_route`に基づき、最大1回まで自動再ルート可能。

**再ルート条件**:
- `suggested_route`が`initial_route`と異なる
- `confidence >= 0.8`
- `fit < 0.3`（現在のルートに不適合）
- まだ再ルートしていない（最大1回）

**実装**: `internal/application/service/llm_iterator_service.go`

---

## 7. I/O契約

### 7.1 InputMessage

```go
type InputMessage struct {
    Channel     string // "line", "slack", "cli"
    ChatID      string // ユーザーID
    Message     string // ユーザーメッセージ
    ForcedRoute Route  // LINE固定等で使用（オプション）
    SessionID   string // セッション識別子
}
```

### 7.2 RoutingDecision

（既出: 5.3参照）

### 7.3 WorkerOutput

```json
{
  "result": "実行結果テキスト",
  "needs_next_loop": false,
  "why": "ループ継続/終了の理由",
  "confidence": 0.9,
  "risk": "low",
  "fit": 0.85,
  "suggested_route": "CODE3"
}
```

### 7.4 Coder3 出力（plan/patch/risk/cost_hint）

```json
{
  "plan": "実装計画...",
  "patch": "diff --git a/pkg/test.go b/pkg/test.go\n...",
  "risk": "medium",
  "cost_hint": "約15分、200行の変更",
  "uses_browser": false
}
```

---

## 8. ワーカー仕様

### 8.1 JSON出力形式

Worker（Shiro）は常にJSON形式で出力:

```json
{
  "result": "実行結果",
  "needs_next_loop": false,
  "why": "理由",
  "confidence": 0.9,
  "risk": "low",
  "fit": 0.85,
  "suggested_route": "CHAT"
}
```

### 8.2 Coder3のplan/patch/riskフィールド

Coder3（Gin）は以下のフィールドを必須で出力:

```json
{
  "plan": "実装計画（マークダウン形式）",
  "patch": "unified diff形式のパッチ",
  "risk": "low|medium|high",
  "cost_hint": "約15分、200行の変更"
}
```

---

## 9. Worker即時実行仕様

### 9.1 基本フロー

```
Coder3 が plan/patch を生成
  ↓
Worker が即座に patch を解析
  ↓
Worker が即座に patch を適用（承認なし）
  ↓
実行結果をユーザーに返却
```

**特徴**:
- ✅ 完全自動（ユーザー操作不要）
- ✅ 高速（承認待ちなし）
- ⚠️ リスク高（破壊的操作も即座に実行）→ セーフガードで対応

### 9.2 patch フォーマット

Coder3（Claude API）が生成するpatchは以下の2形式をサポート:

#### 形式1: JSON配列

```json
[
  {
    "type": "file_edit",
    "action": "create",
    "target": "src/utils/helper.go",
    "content": "package utils\n\nfunc Helper() string {\n    return \"helper\"\n}\n"
  },
  {
    "type": "shell_command",
    "action": "run",
    "target": "go test ./..."
  }
]
```

#### 形式2: Markdownコードブロック

```markdown
## ファイル編集

```go:src/utils/helper.go
package utils

func Helper() string {
    return "helper"
}
```

## コマンド実行

```bash
go test ./...
```
```

#### 拡張機能の使用例

**1. ディレクトリ作成 + ファイル作成**:
```json
[
  {
    "type": "file_edit",
    "action": "mkdir",
    "target": "/workspace/src/utils"
  },
  {
    "type": "file_edit",
    "action": "create",
    "target": "/workspace/src/utils/helper.go",
    "content": "package utils\n..."
  }
]
```

**注**: `ActionCreate`は自動的に親ディレクトリを作成するため、明示的な`mkdir`は通常不要。

**2. ファイルリネーム**:
```json
{
  "type": "file_edit",
  "action": "rename",
  "target": "/workspace/old_name.go",
  "content": "/workspace/new_name.go"
}
```

**3. ファイルコピー**:
```json
{
  "type": "file_edit",
  "action": "copy",
  "target": "/workspace/template.go",
  "content": "/workspace/new_file.go"
}
```

**4. 環境変数付きシェルコマンド**:
```json
{
  "type": "shell_command",
  "action": "run",
  "target": "npm install",
  "workdir": "/workspace/frontend",
  "env": {
    "NODE_ENV": "production",
    "NPM_CONFIG_LOGLEVEL": "silent"
  }
}
```

**5. 異なるシェルの使用**:
```json
{
  "type": "shell_command",
  "action": "run",
  "target": "echo $SHELL",
  "shell": "zsh"
}
```

### 9.3 Worker実行ロジック

#### executeWorkerPatch() フロー

1. **patch解析**（parsePatch）
   - JSON または Markdown 形式を自動判定
   - PatchCommand リストに変換

2. **実行前サマリ表示**（ShowExecutionSummary=trueの場合）
   - コマンド総数、種別（file_edit/shell_command/git_operation）をログ出力
   - トラブルシューティングの効率化

3. **実行前 Git コミット**（AutoCommit=trueの場合）
   - `git add -A`
   - `git commit -m "[Worker Auto-Commit] Before patch"`
   - **重要**: コミット失敗時は即座にエラーを返し、実行中断（安全性担保）

4. **patch適用**（executeCommand × N）
   - **保護ファイルチェック**: 保護パターンに一致するファイルはエラー
   - **ワークスペースチェック**: workspace外のファイルはエラー
   - ファイル編集: create, update, delete, append
   - シェルコマンド: bash実行（タイムアウト5分）
   - Git操作: add, commit, reset, checkout

5. **実行後 Git コミット**（AutoCommit=trueの場合）
   - `git add -A`
   - `git commit -m "[Worker Auto-Commit] After patch: <summary>"`
   - コミット失敗時はログ警告（実行後のため中断しない）

6. **ログ記録**
   - 成功: `logger.InfoCF("worker", "Worker execution succeeded", ...)`
   - 失敗: `logger.ErrorCF("worker", "Worker execution failed", ...)`

7. **結果返却**
   - 成功: "実行完了。変更内容: [summary]"
   - 失敗: "実行失敗。エラー: [error]"

### 9.4 エラーハンドリング戦略

#### 継続モード（デフォルト）
- 1つのコマンドが失敗しても残りを実行
- 全体の成功/失敗は最後に判定

#### 中断モード（オプション）
- `StopOnError: true` で有効化
- 最初の失敗で即座に中断

#### Worker失敗時のロールバック処理

**実行前Git auto-commitがONの場合**:
1. 実行前コミットが成功 → パッチ適用開始
2. パッチ適用中にエラー発生 → `StopOnError=true` の場合は即座に中断
3. **ロールバック**: `git reset --hard HEAD~1` で実行前の状態に戻す
4. エラーログ記録:
   ```go
   logger.ErrorCF("worker", "Worker execution failed, rolled back", map[string]interface{}{
       "job_id": jobID.String(),
       "failed_command": cmd.Type + ":" + cmd.Action,
       "error": err.Error(),
       "rollback_commit": commitHash,
   })
   ```

**実行前Git auto-commitがOFFの場合**:
- ロールバック不可
- エラーログのみ記録
- ユーザーに手動リカバリを促すメッセージを返す:
  ```
  "実行失敗: {error}. Git auto-commit がOFFのため、ロールバックできません。手動で復旧してください。"
  ```

#### 分類器エラー時の詳細ログ

**MioAgent.DecideAction() 内で分類器呼び出し失敗時**:
```go
// internal/domain/agent/mio.go
func (m *MioAgent) DecideAction(ctx context.Context, t task.Task) (routing.Decision, error) {
    // ... 明示コマンド、ルール辞書チェック ...

    // 分類器呼び出し
    decision, err := m.classifier.Classify(ctx, t)
    if err != nil {
        logger.ErrorCF("routing", "Classifier failed, fallback to CHAT", map[string]interface{}{
            "job_id": t.JobID().String(),
            "message": t.UserMessage(),
            "error": err.Error(),
            "error_type": fmt.Sprintf("%T", err), // エラー型
            "fallback_route": "CHAT",
        })
        // 安全側フォールバック: CHAT
        return routing.Decision{
            Route:      routing.RouteCHAT,
            Confidence: 0.5,
            Reason:     fmt.Sprintf("Classifier error (fallback): %v", err),
        }, nil
    }

    return decision, nil
}
```

**詳細ログ項目**:
- `job_id`: ジョブID
- `message`: ユーザーメッセージ（先頭100文字）
- `error`: エラーメッセージ
- `error_type`: エラー型（`*url.Error`, `context.DeadlineExceeded` 等）
- `fallback_route`: フォールバック先ルート

#### MCP部分失敗時のロールバック

**MCPツール実行が部分的に失敗した場合**:

**シナリオ**: Coder3が複数のMCPツールを提案 → Worker実行 → 1つ目成功、2つ目失敗

**対応**:
1. **継続モード（デフォルト）**: 失敗したツールをスキップ、残りを実行
   - ログ: 成功数/失敗数を記録
   - 返信: "実行完了 (2/3 コマンド成功). 失敗: {error}"

2. **中断モード（`StopOnError=true`）**: 失敗時点で即座に中断
   - Git auto-commit ONの場合: `git reset --hard HEAD~1` でロールバック
   - Git auto-commit OFFの場合: ユーザーに手動リカバリを促す

**MCPツール実行ログ**:
```go
// executeCommand() でMCPツール実行時
logger.InfoCF("worker", "MCP tool execution", map[string]interface{}{
    "job_id": jobID.String(),
    "tool_name": mcpToolName,
    "tool_args": toolArgs,
})

// 失敗時
logger.ErrorCF("worker", "MCP tool execution failed", map[string]interface{}{
    "job_id": jobID.String(),
    "tool_name": mcpToolName,
    "error": err.Error(),
    "partial_success": successCount,
    "total": totalCount,
})
```

**重要**: MCP操作はWorker即時実行の一環として扱い、承認フローは廃止（2026-02-28決定）。

### 9.5 セキュリティ

- **workspace外書き込み禁止**: ファイルパスがworkspace外の場合はエラー
- **タイムアウト**: シェルコマンド5分、Git操作30秒
- **コマンドインジェクション対策**: 適切なエスケープ処理

---

## 10. セキュリティ仕様

### 10.1 CODE以外クラウド禁止

**ルール**: CHAT, PLAN, ANALYZE, OPS, RESEARCH はクラウドLLMに送信禁止

**実装**: `local_only`フラグでチェック

### 11.2 API Key管理

- 環境変数から取得（`ANTHROPIC_API_KEY`, `OPENAI_API_KEY`, `DEEPSEEK_API_KEY`）
- 設定ファイルへの平文保存禁止
- ログ出力時のマスキング必須（`pkg/logger/masking.go`）

---

## 11. ログ仕様

### 11.1 構造化ログ

```go
logger.InfoCF("worker", "Patch execution started", map[string]interface{}{
    "job_id": jobID,
    "route": route,
    "patch_commands": len(commands),
})
```

### 11.2 Workerイベント

- `worker.patch_parse`: Patch解析完了
- `worker.execution_started`: Worker実行開始
- `worker.execution_completed`: Worker実行完了
- `worker.execution_failed`: Worker実行失敗
- `worker.auto_commit`: Git auto-commit実行

### 12.3 API Key Masking

ログ出力時、API Keyを自動的にマスク:

```
ANTHROPIC_API_KEY=sk-ant-1234... → ANTHROPIC_API_KEY=sk-ant-****
```

---

## 12. 状態管理とセッション

### 13.1 session_id

チャネル単位で管理:
- LINE: `line:<user_id>`
- Slack: `slack:<channel_id>`
- CLI: `cli:default`

### 13.2 short_memory

会話履歴の要約を保存（日次カットオーバー）。

### 13.3 日次カットオーバー

毎日0時にセッションリセット、daily_noteに保存。

---

## 13. 設定値と閾値

### 13.1 Coder3設定

```yaml
providers:
  claude:
    model: claude-sonnet-4-6
    max_tokens: 8192
    temperature: 0.7
```

### 13.2 Worker設定

```yaml
worker:
  # Git auto-commit設定
  auto_commit: false           # デフォルト無効（ユーザーが有効化推奨）
  commit_message_prefix: "[Worker Auto-Commit]"

  # タイムアウト設定
  command_timeout: 300         # 秒（5分）
  git_timeout: 30              # 秒（30秒）

  # エラーハンドリング
  stop_on_error: false         # 継続モード（デフォルト）

  # ワークスペース制限
  workspace: "/path/to/workspace" # ワークスペースルート

  # 保護ファイルパターン（推奨）
  protected_patterns:
    - ".env*"
    - "*credentials*"
    - "*.key"
    - "*.pem"
  action_on_protected_file: "error"  # "error", "skip", "log"

  # 実行前サマリ表示（推奨）
  show_execution_summary: true  # 実行前に変更内容サマリを表示
```

### 13.3 Ollama設定

```yaml
ollama:
  keep_alive: -1      # 常駐化
  max_context: 8192
  health_check_interval: 60 # 秒
```

---

## 14. 実装プラン

### 14.1 Phase 1（2週間）: Domain層

#### Week 1: Domain層実装

- **Day 1-2**: MioAgent/ShiroAgent/CoderAgent エンティティ実装
- **Day 3**: Task/JobID/Proposal 値オブジェクト実装
- **Day 4**: PatchCommand/PatchExecutionResult 値オブジェクト実装
- **Day 5**: RoutingDecision + Route enum実装

#### Week 2: Domain層完成

- **Day 1-2**: ToolRunner インターフェース実装
- **Day 3**: parsePatch() ロジック実装（JSON/Markdown対応）
- **Day 4**: executeCommand() ロジック実装（file_edit, shell_command, git_operation）
- **Day 5**: ユニットテスト（Domain層90%カバレッジ）

#### マイルストーン

- ✅ Domain層90%カバレッジ達成
- ✅ PatchCommand動作確認（JSON/Markdown解析成功）
- ✅ executeCommand単体テスト全パターン成功

### 15.2 Phase 2（3週間）: Application層 + Infrastructure層

#### Week 3: Infrastructure層

- **Day 1-2**: LLM Providers統合（既存活用）
- **Day 3**: Job Repository実装（SQLite）
- **Day 4**: Event Bus実装
- **Day 5**: Config Loader実装（Layered Configuration）

#### Week 4-5: Application層

- **Week 4 Day 1-3**: MessageOrchestrator実装（Agent Loop分解）
- **Week 4 Day 4-5**: RoutingService、LLMIteratorService実装
- **Week 5 Day 1-2**: WorkerExecutionService実装（executeWorkerPatch, parsePatch, executeCommand）
- **Week 5 Day 3-4**: WorkerExecutionService完成（Git auto-commit, エラーハンドリング）
- **Week 5 Day 5**: MemoryService実装

#### マイルストーン

- ✅ E2Eテスト（基本フロー: CHAT → Worker → 返信）成功
- ✅ E2Eテスト（Worker即時実行: Coder3 → Worker即時適用 → 返信）成功
- ✅ Git auto-commit機能動作確認成功

### 15.3 Phase 3（2週間）: Adapter層 + Wire DI

#### Week 6-7: Adapter層 + Wire DI

- **Week 6 Day 1-2**: LINE Handler実装（CHAT固定）
- **Week 6 Day 3-4**: Slack/CLI Handler実装
- **Week 6 Day 5**: Notification Sender実装
- **Week 7 Day 1-3**: Wire DI設定、全層統合
- **Week 7 Day 4-5**: E2Eテスト（全シナリオ）

#### マイルストーン

- ✅ 全シナリオE2Eテスト成功（LINE/Slack/CLI × CHAT/WORKER/CODE1/CODE2/CODE3）
- ✅ Wire DI動作確認（依存性注入が正しく機能）
- ✅ 既存の実装仕様.md（2026-02-24版）の全要件を満たす

### 15.4 Phase 4（1週間）: 本番移行

#### Week 8: テスト環境デプロイ、性能テスト、本番移行

- **Day 1-2**: テスト環境デプロイ、動作確認
- **Day 3**: 性能テスト（メモリ<10MB、レイテンシ劣化10%以内）
- **Day 4**: 本番デプロイ
- **Day 5**: 監視、ロールバック準備

#### マイルストーン

- ✅ 仕様100%準拠確認（LINE固定、Mio委譲、Worker即時実行）
- ✅ 性能劣化10%以内
- ✅ メモリ使用量<10MB
- ✅ 本番稼働開始

---

## 15. テスト観点

### 15.1 テストピラミッド

```
          /\
         /E2E\          ← 10% (主要シナリオ + 新機能)
        /------\
       /Integration\    ← 20% (Worker即時実行、E2Eシナリオ)
      /------------\
     /  Unit Tests  \   ← 70% (Domain層 + Application層)
    /----------------\
```

### 15.2 Domain層ユニットテスト（カバレッジ目標: 90%）

**テスト対象**:
- MioAgent.DecideAction()（委譲判断ロジック）
- ShiroAgent.Execute()（Worker実行）
- CoderAgent.GenerateProposal()（plan/patch生成）
- PatchCommand/PatchExecutionResult 値オブジェクト
- Task/JobID/Proposal 値オブジェクト

**例**:
```go
func TestMioAgent_DecideAction_ExplicitCommand(t *testing.T) {
    // Arrange
    mio := NewMioAgent(ruleDictionary, classifier)
    task := task.NewTask(jobID, "/code test", "line", "user123")

    // Act
    decision, err := mio.DecideAction(ctx, task)

    // Assert
    assert.NoError(t, err)
    assert.Equal(t, routing.RouteCODE, decision.Route)
    assert.Equal(t, "explicit", decision.Source)
    assert.Equal(t, 1.0, decision.Confidence)
}

func TestPatchCommand_Validation(t *testing.T) {
    // Arrange
    cmd := patch.PatchCommand{
        Type:    patch.TypeFileEdit,
        Action:  patch.ActionCreate,
        Target:  "/workspace/test.go",
        Content: "package main",
    }

    // Act & Assert
    assert.Equal(t, patch.TypeFileEdit, cmd.Type)
    assert.Equal(t, patch.ActionCreate, cmd.Action)
}
```

### 16.3 Application層ユニットテスト（カバレッジ目標: 80%）

**テスト対象**:
- MessageOrchestrator.ProcessMessage()
  - CHATルート → Mio → 返信
  - CODE3ルート → Coder3 → Worker即時実行 → 返信
  - WORKERルート → Shiro → 返信
- RoutingService.Decide()（Mio委譲判断）
- WorkerExecutionService.ExecuteProposal()
  - parsePatch（JSON/Markdown）
  - executeCommand（file_edit/shell_command/git_operation）
  - 保護ファイルチェック
  - Git auto-commit

**例**:
```go
func TestMessageOrchestrator_ProcessMessage_CODE3_ImmediateExecution(t *testing.T) {
    // Arrange
    orchestrator := NewMessageOrchestrator(routingService, llmIterator, workerExecution, memoryService)
    input := InputMessage{
        Channel: "line",
        ChatID:  "user123",
        Message: "/code3 ファイルを作成して",
    }

    // Act
    response, err := orchestrator.ProcessMessage(ctx, input)

    // Assert
    assert.NoError(t, err)
    assert.Contains(t, response.Content, "実行完了")
    assert.NotNil(t, response.Content)
}
```

### 16.4 統合テスト（20%）

**テスト対象**:
- Worker実行（Patch適用）
  - ファイル編集（create, update, delete, append）
  - シェルコマンド実行
  - Git操作（add, commit, reset, checkout）
- Git auto-commit機能
  - 実行前コミット成功
  - 実行後コミット成功
  - コミット失敗時の中断
- 保護ファイルチェック
  - .env*, *credentials* の保護
  - エラー/スキップ/ログモード

### 16.5 E2Eテスト（10%）

**主要シナリオ**:
1. 基本フロー（CHAT → Mio → 返信）
2. Worker即時実行フロー（CODE3 → Coder3 → Worker即時実行 → 返信）
3. Git auto-commitフロー（AutoCommit有効 → 実行前後コミット → 成功）
4. 保護ファイル防御（.env編集試行 → エラー → 中断）
5. ドライモード（DryRun有効 → 実行内容のみログ → 実際の実行なし）
6. Chrome操作フロー（uses_browser=true → MCP Chrome呼び出し → 成功）

---

## 16. Application層実装詳細

### 16.1 MessageOrchestrator

**ファイル**: `internal/application/service/message_orchestrator.go`

```go
package service

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// MessageOrchestrator はAgent Loop分解の中核
type MessageOrchestrator struct {
    routingService   RoutingService
    llmIterator      LLMIteratorService
    workerExecution  WorkerExecutionService
    memoryService    MemoryService
}

func NewMessageOrchestrator(
    routingService RoutingService,
    llmIterator LLMIteratorService,
    workerExecution WorkerExecutionService,
    memoryService MemoryService,
) *MessageOrchestrator {
    return &MessageOrchestrator{
        routingService:  routingService,
        llmIterator:     llmIterator,
        workerExecution: workerExecution,
        memoryService:   memoryService,
    }
}

// ProcessMessage はメインフロー調整
func (o *MessageOrchestrator) ProcessMessage(ctx context.Context, input InputMessage) (*Response, error) {
    // 1. Task作成
    t := task.NewTask(task.NewJobID(), input.Message, input.Channel, input.ChatID)
    if input.ForcedRoute != "" {
        t = t.WithForcedRoute(input.ForcedRoute)
    }

    // 2. ルーティング決定（Mio委譲判断）
    decision, err := o.routingService.Decide(ctx, t)
    if err != nil {
        return nil, err
    }
    t = t.WithRoute(decision.Route)

    // 3. LLM呼び出しループ
    result, err := o.llmIterator.Execute(ctx, t, decision)
    if err != nil {
        return nil, err
    }

    // 4. Worker即時実行（Coder3の場合）
    if decision.Route == routing.RouteCODE3 && result.Proposal != nil {
        execResult, err := o.workerExecution.ExecuteProposal(ctx, t.JobID(), result.Proposal)
        if err != nil {
            return &Response{
                Content: fmt.Sprintf("Worker実行失敗: %v", err),
                Error:   err,
            }, err
        }

        // 実行結果を整形して返却
        return &Response{
            Content: fmt.Sprintf("実行完了 (%d/%d コマンド成功)\n\n【Plan】\n%s\n\n【実行結果】\n%s",
                execResult.ExecutedCmds,
                execResult.ExecutedCmds + execResult.FailedCmds,
                result.Proposal.Plan(),
                execResult.Summary),
        }, nil
    }

    // 5. その他のルート（CHAT, WORKER等）
    return &Response{Content: result.Content}, nil
}
```

### 17.2 RoutingService

**ファイル**: `internal/application/service/routing_service.go`

```go
package service

import (
    "context"
    "github.com/sipeed/picoclaw/internal/domain/agent"
    "github.com/sipeed/picoclaw/internal/domain/routing"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

type RoutingService interface {
    Decide(ctx context.Context, t task.Task) (routing.Decision, error)
}

type routingService struct {
    mioAgent *agent.MioAgent
}

func NewRoutingService(mioAgent *agent.MioAgent) RoutingService {
    return &routingService{mioAgent: mioAgent}
}

func (r *routingService) Decide(ctx context.Context, t task.Task) (routing.Decision, error) {
    // Mio委譲判断に委譲
    return r.mioAgent.DecideAction(ctx, t)
}
```

### 17.3 LLMIteratorService

**ファイル**: `internal/application/service/llm_iterator_service.go`

```go
package service

import (
    "context"
    "fmt"
    "time"
    "github.com/sipeed/picoclaw/internal/domain/llm"
    "github.com/sipeed/picoclaw/internal/domain/proposal"
    "github.com/sipeed/picoclaw/internal/domain/routing"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// LLMIteratorService はLLM呼び出しループを管理（リトライ、タイムアウト等）
type LLMIteratorService interface {
    Execute(ctx context.Context, t task.Task, decision routing.Decision) (*LLMIteratorResult, error)
}

type LLMIteratorResult struct {
    Content  string
    Proposal *proposal.Proposal // Coderルートの場合のみ設定
}

type llmIteratorService struct {
    providers  map[string]llm.LLMProvider
    maxRetries int
    timeout    time.Duration
}

func NewLLMIteratorService(providers map[string]llm.LLMProvider, maxRetries int, timeout time.Duration) LLMIteratorService {
    return &llmIteratorService{
        providers:  providers,
        maxRetries: maxRetries,
        timeout:    timeout,
    }
}

func (l *llmIteratorService) Execute(ctx context.Context, t task.Task, decision routing.Decision) (*LLMIteratorResult, error) {
    // ルートに応じたプロバイダー選択
    provider := l.selectProvider(decision.Route)

    // LLM呼び出し（リトライ付き）
    for i := 0; i < l.maxRetries; i++ {
        response, err := provider.Generate(ctx, buildRequest(t))
        if err == nil {
            return &LLMIteratorResult{
                Content:  response.Content,
                Proposal: extractProposalFromResponse(response), // Coderルートの場合のみ
            }, nil
        }
        // リトライ
        time.Sleep(time.Second * time.Duration(i+1))
    }

    return nil, fmt.Errorf("LLM call failed after %d retries", l.maxRetries)
}

// selectProvider はルートに応じてプロバイダーを選択
func (l *llmIteratorService) selectProvider(route routing.Route) llm.LLMProvider {
    // ルーティングに応じたプロバイダーマッピング
    providerMap := map[routing.Route]string{
        routing.RouteCHAT:     "ollama-chat",
        routing.RouteANALYZE:  "ollama-worker",
        routing.RouteOPS:      "ollama-worker",
        routing.RouteRESEARCH: "ollama-worker",
        routing.RouteCODE1:    "deepseek",
        routing.RouteCODE2:    "openai",
        routing.RouteCODE3:    "claude",
    }

    providerName, ok := providerMap[route]
    if !ok {
        providerName = "ollama-chat" // デフォルト
    }

    if provider, ok := l.providers[providerName]; ok {
        return provider
    }

    return l.providers["ollama-chat"] // フォールバック
}

// buildRequest はタスクからLLMリクエストを構築
func buildRequest(t task.Task) llm.GenerateRequest {
    return llm.GenerateRequest{
        Messages: []llm.Message{
            {
                Role:    "user",
                Content: t.UserMessage(),
            },
        },
        MaxTokens:    4096,
        Temperature:  0.7,
        SystemPrompt: "", // ルートに応じてシステムプロンプトを設定可能
    }
}

// extractProposalFromResponse はLLM応答からProposalを抽出（Coderルートの場合のみ）
func extractProposalFromResponse(response llm.GenerateResponse) *proposal.Proposal {
    // Coderルートの場合のみProposal抽出
    // Plan/Patch/Risk/CostHintセクションを抽出
    plan := extractPlanFromContent(response.Content)
    patch := extractPatchFromContent(response.Content)
    risk := extractRiskFromContent(response.Content)
    costHint := extractCostHintFromContent(response.Content)

    if plan == "" || patch == "" {
        return nil // CoderルートでないまたはProposal形式でない
    }

    return proposal.NewProposal(plan, patch, risk, costHint)
}

// extractPlanFromContent は応答コンテンツからPlanセクションを抽出
func extractPlanFromContent(content string) string {
    planStart := strings.Index(content, "## Plan")
    if planStart == -1 {
        return ""
    }
    planEnd := strings.Index(content[planStart+7:], "##")
    if planEnd == -1 {
        return strings.TrimSpace(content[planStart+7:])
    }
    return strings.TrimSpace(content[planStart+7 : planStart+7+planEnd])
}

// extractPatchFromContent は応答コンテンツからPatchセクションを抽出
func extractPatchFromContent(content string) string {
    patchStart := strings.Index(content, "## Patch")
    if patchStart == -1 {
        return ""
    }
    patchEnd := strings.Index(content[patchStart+8:], "##")
    if patchEnd == -1 {
        return strings.TrimSpace(content[patchStart+8:])
    }
    return strings.TrimSpace(content[patchStart+8 : patchStart+8+patchEnd])
}

// extractRiskFromContent は応答コンテンツからRiskレベルを抽出
func extractRiskFromContent(content string) proposal.RiskLevel {
    riskStart := strings.Index(content, "## Risk")
    if riskStart == -1 {
        return proposal.RiskLevelMedium
    }
    riskSection := content[riskStart : min(riskStart+50, len(content))]
    if strings.Contains(strings.ToLower(riskSection), "high") {
        return proposal.RiskLevelHigh
    } else if strings.Contains(strings.ToLower(riskSection), "low") {
        return proposal.RiskLevelLow
    }
    return proposal.RiskLevelMedium
}

// extractCostHintFromContent は応答コンテンツからCostヒントを抽出
func extractCostHintFromContent(content string) string {
    costStart := strings.Index(content, "## Cost")
    if costStart == -1 {
        return ""
    }
    costEnd := strings.Index(content[costStart+7:], "##")
    if costEnd == -1 {
        return strings.TrimSpace(content[costStart+7:])
    }
    return strings.TrimSpace(content[costStart+7 : costStart+7+costEnd])
}
```

### 17.4 MemoryService

**ファイル**: `internal/application/service/memory_service.go`

```go
package service

import (
    "context"
    "fmt"
    "sync"
    "github.com/sipeed/picoclaw/internal/domain/task"
)

// MemoryService はセッションメモリ管理
type MemoryService interface {
    Save(ctx context.Context, jobID task.JobID, key string, value interface{}) error
    Load(ctx context.Context, jobID task.JobID, key string) (interface{}, error)
    Clear(ctx context.Context, jobID task.JobID) error
}

type memoryService struct {
    store map[string]map[string]interface{} // jobID -> key -> value
    mu    sync.RWMutex
}

func NewMemoryService() MemoryService {
    return &memoryService{
        store: make(map[string]map[string]interface{}),
    }
}

func (m *memoryService) Save(ctx context.Context, jobID task.JobID, key string, value interface{}) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    id := jobID.String()
    if _, ok := m.store[id]; !ok {
        m.store[id] = make(map[string]interface{})
    }
    m.store[id][key] = value
    return nil
}

func (m *memoryService) Load(ctx context.Context, jobID task.JobID, key string) (interface{}, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    id := jobID.String()
    if session, ok := m.store[id]; ok {
        if value, ok := session[key]; ok {
            return value, nil
        }
    }
    return nil, fmt.Errorf("key not found: %s", key)
}

func (m *memoryService) Clear(ctx context.Context, jobID task.JobID) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    delete(m.store, jobID.String())
    return nil
}
```

### 17.5 Response 型

**ファイル**: `internal/application/service/types.go`

```go
package service

// Response はMessageOrchestratorの応答型
type Response struct {
    Content string
    Error   error
}
```

### 17.6 WorkerExecutionService

**ファイル**: `internal/application/service/worker_execution_service.go`

詳細は **9.3 Worker実行ロジック** を参照。ここでは主要な実装ポイントのみ記載。

```go
package service

import (
    "context"
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
    "strings"
    "time"
    "github.com/sipeed/picoclaw/internal/domain/agent"
    "github.com/sipeed/picoclaw/internal/domain/patch"
    "github.com/sipeed/picoclaw/internal/domain/proposal"
    "github.com/sipeed/picoclaw/internal/domain/task"
    "github.com/sipeed/picoclaw/pkg/logger"
)

type WorkerConfig struct {
    AutoCommit         bool
    CommitMessagePrefix string
    CommandTimeout     int // 秒
    GitTimeout         int // 秒
    StopOnError        bool
    Workspace          string
    ProtectedPatterns  []string // 保護ファイルパターン
    ActionOnProtected  string   // "error", "skip", "log"
    ShowExecutionSummary bool   // 実行前サマリ表示
}

type WorkerExecutionService interface {
    ExecuteProposal(ctx context.Context, jobID task.JobID, p *proposal.Proposal) (*patch.PatchExecutionResult, error)
}

type workerExecutionService struct {
    shiroAgent *agent.ShiroAgent
    config     WorkerConfig
}

func NewWorkerExecutionService(shiroAgent *agent.ShiroAgent, config WorkerConfig) WorkerExecutionService {
    return &workerExecutionService{
        shiroAgent: shiroAgent,
        config:     config,
    }
}

func (w *workerExecutionService) ExecuteProposal(ctx context.Context, jobID task.JobID, p *proposal.Proposal) (*patch.PatchExecutionResult, error) {
    // 1. Patch解析（Domain層のParsePatch関数を使用）
    commands, err := patch.ParsePatch(p.Patch())
    if err != nil {
        return nil, fmt.Errorf("patch parse error: %w", err)
    }

    // 2. 実行前サマリ表示（推奨）
    if w.config.ShowExecutionSummary {
        summary := w.generateExecutionSummary(commands)
        logger.InfoCF("worker", "Execution summary",
            map[string]interface{}{
                "job_id":         jobID.String(),
                "total_commands": summary.TotalCommands,
                "file_edits":     summary.FileEdits,
                "shell_commands": summary.ShellCommands,
                "git_operations": summary.GitOperations,
            })
    }

    // 3. 実行前 Git コミット（AutoCommit=trueの場合は必須）
    var beforeCommit string
    if w.config.AutoCommit {
        beforeCommit, err = w.autoCommitChanges(ctx, "Before patch")
        if err != nil {
            // 重要: AutoCommit有効時、コミット失敗 = 実行中断（安全性担保）
            return nil, fmt.Errorf("auto-commit failed (safety requirement), execution aborted: %w", err)
        }
        logger.InfoCF("worker", "Auto-commit before patch succeeded",
            map[string]interface{}{"commit": beforeCommit})
    }

    // 3. コマンド実行ループ
    result := &patch.PatchExecutionResult{
        Success:      true,
        ExecutedCmds: 0,
        FailedCmds:   0,
        Results:      make([]patch.CommandResult, 0),
    }

    for _, cmd := range commands {
        output, err := w.executeCommand(ctx, cmd)
        cmdResult := patch.CommandResult{
            Command: cmd,
            Success: err == nil,
            Output:  output,
        }

        if err != nil {
            cmdResult.Error = err.Error()
            result.FailedCmds++
            result.Success = false

            // 中断モード
            if w.config.StopOnError {
                result.Results = append(result.Results, cmdResult)
                return result, fmt.Errorf("command failed (stop on error): %w", err)
            }
        } else {
            result.ExecutedCmds++
        }

        result.Results = append(result.Results, cmdResult)
    }

    // 4. 実行後 Git コミット（オプション）
    if w.config.AutoCommit {
        afterCommit, err := w.autoCommitChanges(ctx, "After patch: "+p.Plan()[:min(50, len(p.Plan()))])
        if err != nil {
            logger.WarnCF("worker", "Auto-commit after patch failed", map[string]interface{}{"error": err})
        } else {
            result.GitCommit = afterCommit
        }
    }

    // 5. ログ記録
    if result.Success {
        logger.InfoCF("worker", "Worker execution succeeded", map[string]interface{}{
            "job_id": jobID.String(),
            "executed": result.ExecutedCmds,
        })
    } else {
        logger.ErrorCF("worker", "Worker execution failed", map[string]interface{}{
            "job_id": jobID.String(),
            "failed": result.FailedCmds,
            "total": len(commands),
        })
    }

    return result, nil
}

// executeCommand は単一のコマンドを実行
func (w *workerExecutionService) executeCommand(ctx context.Context, cmd patch.PatchCommand) (string, error) {
    switch cmd.Type {
    case patch.TypeFileEdit:
        return w.executeFileEdit(ctx, cmd)
    case patch.TypeShellCommand:
        return w.executeShellCommand(ctx, cmd)
    case patch.TypeGitOperation:
        return w.executeGitOperation(ctx, cmd)
    default:
        return "", fmt.Errorf("unknown command type: %s", cmd.Type)
    }
}

// executeFileEdit はファイル編集を実行
func (w *workerExecutionService) executeFileEdit(ctx context.Context, cmd patch.PatchCommand) (string, error) {
    // 1. workspace 外への書き込みを禁止
    if !strings.HasPrefix(cmd.Target, w.config.Workspace) {
        return "", fmt.Errorf("file path outside workspace: %s", cmd.Target)
    }

    // 2. 保護ファイルチェック
    if w.isProtectedFile(cmd.Target) {
        switch w.config.ActionOnProtected {
        case "error":
            return "", fmt.Errorf("protected file cannot be modified: %s", cmd.Target)
        case "skip":
            logger.WarnCF("worker", "Skipped protected file", map[string]interface{}{"file": cmd.Target})
            return "skipped (protected file)", nil
        case "log":
            logger.WarnCF("worker", "Modifying protected file", map[string]interface{}{"file": cmd.Target})
            // 続行
        }
    }

    switch cmd.Action {
    case patch.ActionCreate, patch.ActionUpdate:
        // ファイル作成/上書き（親ディレクトリが存在しない場合は自動作成）
        dir := filepath.Dir(cmd.Target)
        if err := os.MkdirAll(dir, 0755); err != nil {
            return "", fmt.Errorf("failed to create parent directory: %w", err)
        }
        return "", os.WriteFile(cmd.Target, []byte(cmd.Content), 0644)

    case patch.ActionDelete:
        return "", os.Remove(cmd.Target)

    case patch.ActionAppend:
        f, err := os.OpenFile(cmd.Target, os.O_APPEND|os.O_WRONLY, 0644)
        if err != nil {
            return "", err
        }
        defer f.Close()
        _, err = f.WriteString(cmd.Content)
        return "", err

    case patch.ActionRename:
        // ファイル/ディレクトリ移動・リネーム（Target → Content）
        if cmd.Content == "" {
            return "", fmt.Errorf("rename requires Content field (destination path)")
        }
        // デスティネーションも保護ファイルチェック
        if w.isProtectedFile(cmd.Content) {
            return "", fmt.Errorf("cannot rename to protected file: %s", cmd.Content)
        }
        // 移動先の親ディレクトリが存在しない場合は自動作成
        destDir := filepath.Dir(cmd.Content)
        if err := os.MkdirAll(destDir, 0755); err != nil {
            return "", fmt.Errorf("failed to create destination directory: %w", err)
        }
        return "", os.Rename(cmd.Target, cmd.Content)

    case patch.ActionMkdir:
        // ディレクトリ作成（親ディレクトリも自動作成）
        return "", os.MkdirAll(cmd.Target, 0755)

    case patch.ActionCopy:
        // ファイルコピー（Target → Content）
        if cmd.Content == "" {
            return "", fmt.Errorf("copy requires Content field (destination path)")
        }
        // デスティネーションも保護ファイルチェック
        if w.isProtectedFile(cmd.Content) {
            return "", fmt.Errorf("cannot copy to protected file: %s", cmd.Content)
        }
        // コピー先の親ディレクトリが存在しない場合は自動作成
        destDir := filepath.Dir(cmd.Content)
        if err := os.MkdirAll(destDir, 0755); err != nil {
            return "", fmt.Errorf("failed to create destination directory: %w", err)
        }
        // ファイルコピー
        srcData, err := os.ReadFile(cmd.Target)
        if err != nil {
            return "", fmt.Errorf("failed to read source file: %w", err)
        }
        if err := os.WriteFile(cmd.Content, srcData, 0644); err != nil {
            return "", fmt.Errorf("failed to write destination file: %w", err)
        }
        return fmt.Sprintf("copied %s -> %s", cmd.Target, cmd.Content), nil

    default:
        return "", fmt.Errorf("unknown action: %s", cmd.Action)
    }
}

// executeShellCommand はシェルコマンドを実行
func (w *workerExecutionService) executeShellCommand(ctx context.Context, cmd patch.PatchCommand) (string, error) {
    execCtx, cancel := context.WithTimeout(ctx, time.Duration(w.config.CommandTimeout)*time.Second)
    defer cancel()

    // シェル種別の決定（デフォルト: bash）
    shell := cmd.Shell
    if shell == "" {
        shell = "bash"
    }

    // コマンド構築
    execCmd := exec.CommandContext(execCtx, shell, "-c", cmd.Target)

    // 作業ディレクトリの設定
    if cmd.WorkDir != "" {
        // workspace内かチェック
        if !strings.HasPrefix(cmd.WorkDir, w.config.Workspace) {
            return "", fmt.Errorf("workdir outside workspace: %s", cmd.WorkDir)
        }
        execCmd.Dir = cmd.WorkDir
    }

    // 環境変数の設定
    if len(cmd.Env) > 0 {
        // 既存の環境変数を継承し、指定された環境変数を追加/上書き
        execCmd.Env = os.Environ()
        for key, value := range cmd.Env {
            execCmd.Env = append(execCmd.Env, fmt.Sprintf("%s=%s", key, value))
        }
    }

    output, err := execCmd.CombinedOutput()
    return string(output), err
}

// executeGitOperation は Git 操作を実行
func (w *workerExecutionService) executeGitOperation(ctx context.Context, cmd patch.PatchCommand) (string, error) {
    execCtx, cancel := context.WithTimeout(ctx, time.Duration(w.config.GitTimeout)*time.Second)
    defer cancel()

    var gitCmd *exec.Cmd
    switch cmd.Action {
    case patch.ActionAdd:
        gitCmd = exec.CommandContext(execCtx, "git", "add", cmd.Target)
    case patch.ActionCommit:
        gitCmd = exec.CommandContext(execCtx, "git", "commit", "-m", cmd.Content)
    case patch.ActionReset:
        gitCmd = exec.CommandContext(execCtx, "git", "reset", cmd.Target)
    case patch.ActionCheckout:
        gitCmd = exec.CommandContext(execCtx, "git", "checkout", cmd.Target)
    default:
        return "", fmt.Errorf("unknown git action: %s", cmd.Action)
    }

    output, err := gitCmd.CombinedOutput()
    return string(output), err
}

// autoCommitChanges は Git 自動コミットを実行
func (w *workerExecutionService) autoCommitChanges(ctx context.Context, message string) (string, error) {
    // git add -A
    addCmd := exec.CommandContext(ctx, "git", "add", "-A")
    if err := addCmd.Run(); err != nil {
        return "", err
    }

    // git commit
    commitMsg := fmt.Sprintf("%s %s", w.config.CommitMessagePrefix, message)
    commitCmd := exec.CommandContext(ctx, "git", "commit", "-m", commitMsg)
    if err := commitCmd.Run(); err != nil {
        return "", err
    }

    // コミットハッシュ取得
    hashCmd := exec.CommandContext(ctx, "git", "rev-parse", "HEAD")
    hash, err := hashCmd.Output()
    if err != nil {
        return "", err
    }

    return strings.TrimSpace(string(hash)), nil
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

// isProtectedFile は保護ファイルパターンに一致するか判定
func (w *workerExecutionService) isProtectedFile(filePath string) bool {
    for _, pattern := range w.config.ProtectedPatterns {
        matched, _ := filepath.Match(pattern, filepath.Base(filePath))
        if matched {
            return true
        }
    }
    return false
}

// generateExecutionSummary は実行前サマリを生成
func (w *workerExecutionService) generateExecutionSummary(commands []patch.PatchCommand) ExecutionSummary {
    summary := ExecutionSummary{}
    for _, cmd := range commands {
        summary.TotalCommands++
        switch cmd.Type {
        case patch.TypeFileEdit:
            summary.FileEdits++
        case patch.TypeShellCommand:
            summary.ShellCommands++
        case patch.TypeGitOperation:
            summary.GitOperations++
        }
    }
    return summary
}

type ExecutionSummary struct {
    TotalCommands int
    FileEdits     int
    ShellCommands int
    GitOperations int
}
```

---

## 17. Infrastructure層実装詳細

### 17.1 LLM Providers

**既存活用**: `pkg/providers/`の以下を活用
- `ollama/provider.go`
- `claude/provider.go`
- `openai/provider.go`
- `deepseek/provider.go`

---

## 18. Adapter層実装詳細

### 18.1 LINE Handler

**ファイル**: `internal/adapter/inbound/line/handler.go`

```go
package line

import (
    "context"
    "github.com/line/line-bot-sdk-go/v7/linebot"
    "github.com/sipeed/picoclaw/internal/application/usecase"
    "github.com/sipeed/picoclaw/internal/domain/routing"
)

type LINEHandler struct {
    processMessageUC *usecase.ProcessMessage
    bot              *linebot.Client
}

func NewLINEHandler(processMessageUC *usecase.ProcessMessage, bot *linebot.Client) *LINEHandler {
    return &LINEHandler{
        processMessageUC: processMessageUC,
        bot:              bot,
    }
}

func (h *LINEHandler) HandleMessage(event *linebot.Event) error {
    // LINE入口は必ずCHAT（Mio）に固定
    input := usecase.InputMessage{
        Channel:     "line",
        ChatID:      event.Source.UserID,
        Message:     event.Message.(*linebot.TextMessage).Text,
        ForcedRoute: routing.RouteCHAT, // 仕様準拠: LINE固定
    }

    response, err := h.processMessageUC.Execute(context.Background(), input)
    if err != nil {
        return err
    }

    // LINE API経由で返信
    if _, err := h.bot.ReplyMessage(event.ReplyToken, linebot.NewTextMessage(response.Content)).Do(); err != nil {
        return err
    }

    return nil
}
```

### 19.2 Wire DI設定

**ファイル**: `cmd/picoclaw/wire.go`

```go
//go:build wireinject
// +build wireinject

package main

import (
    "github.com/google/wire"
    "github.com/sipeed/picoclaw/internal/adapter/inbound/line"
    "github.com/sipeed/picoclaw/internal/application/service"
    "github.com/sipeed/picoclaw/internal/application/usecase"
    "github.com/sipeed/picoclaw/internal/domain/agent"
    "github.com/sipeed/picoclaw/internal/infrastructure/persistence/session"
    "github.com/sipeed/picoclaw/pkg/providers"
    "github.com/sipeed/picoclaw/pkg/tools"
)

func InitializeApp(cfg *Config) (*App, error) {
    wire.Build(
        // Infrastructure
        provideLLMProviders,
        provideToolRegistry,
        session.NewJSONSessionRepository,

        // Domain
        agent.NewMioAgent,
        agent.NewShiroAgent,
        agent.NewCoderAgent,

        // Application Services
        service.NewMessageOrchestrator,
        service.NewRoutingService,
        service.NewLLMIteratorService,
        service.NewWorkerExecutionService,
        service.NewMemoryService,

        // Use Cases
        usecase.NewProcessMessage,
        // Adapters
        line.NewLINEHandler,
        provideLINEBotClient,

        // App
        wire.Struct(new(App), "*"),
    )
    return nil, nil
}

func provideSQLiteDB(cfg *Config) (*sql.DB, error) {
    return sql.Open("sqlite", cfg.DatabasePath)
}

func provideLLMProviders(cfg *Config) (map[string]providers.Provider, error) {
    // Ollama, Claude, OpenAI, DeepSeek Provider初期化
    // 実装略
    return nil, nil
}

func provideLINEBotClient(cfg *Config) (*linebot.Client, error) {
    return linebot.New(cfg.LINE.ChannelSecret, cfg.LINE.ChannelAccessToken)
}
```

---


## 付録A: 既存仕様との差分マップ

| 既存仕様章 | 新仕様章 | 変更内容 |
|-----------|---------|---------|
| 1. スコープ・責務境界 | 3. スコープ・責務境界 | 継承（変更なし） |
| 2. ルーティング決定仕様 | 5. ルーティング決定仕様 | **Mio委譲判断の実装詳細を追加** |
| 3. ループ制御と再ルート | 6. ループ制御と再ルート | 継承（変更なし） |
| 4. I/O契約 | 7. I/O契約 | 継承（変更なし） |
| 5. ワーカー仕様 | 8. ワーカー仕様 | 継承（変更なし） |
| 6. 承認フロー仕様 | （削除） | **承認フロー廃止により削除** |
| 7. セキュリティ仕様 | 11. セキュリティ仕様 | 継承（変更なし） |
| 8. ログ仕様 | 12. ログ仕様 | 継承（変更なし） |
| 9. 状態管理とセッション | 13. 状態管理とセッション | 継承（変更なし） |
| 10. 設定値と閾値 | 14. 設定値と閾値 | 継承（変更なし） |
| 11. テスト観点 | 16. テスト観点 | **テストピラミッド、Domain層/Application層テスト戦略を追加** |
| （なし） | 0. エグゼクティブサマリ | **新規追加** |
| （なし） | 1. アーキテクチャ設計 | **新規追加** |
| （なし） | 2. パッケージ構造 | **新規追加** |
| （なし） | 4. Domain層実装詳細 | **新規追加** |
| （なし） | 10. Event Sourcing + CQRS | **新規追加** |
| （なし） | 15. 実装プラン | **新規追加** |
| （なし） | 17. Application層実装詳細 | **新規追加** |
| （なし） | 18. Infrastructure層実装詳細 | **新規追加** |
| （なし） | 19. Adapter層実装詳細 | **新規追加** |
| （なし） | 20. データベーススキーマ | **新規追加** |

---

## 付録B: 用語集

| 用語 | 説明 |
|------|------|
| **Clean Architecture** | 外層→内層への依存方向を強制し、ビジネスロジック（Domain）を外部の技術詳細から分離するアーキテクチャパターン |
| **Event Sourcing** | 状態変化をイベントとして記録し、イベント履歴からエンティティを復元する設計手法 |
| **CQRS** | Command Query Responsibility Segregation。コマンド（書き込み）とクエリ（読み込み）を分離する設計パターン |
| **DDD** | Domain-Driven Design。ドメインモデル中心の設計手法 |
| **エンティティ** | 一意性を持つドメインオブジェクト（例: Agent, Session） |
| **値オブジェクト** | 不変で値の等価性で比較されるオブジェクト（例: Task, JobID） |
| **アグリゲート** | 関連オブジェクトの一貫性を保証する境界（例: Session） |
| **リポジトリ** | 永続化の抽象化（Domain層でinterface定義、Infrastructure層で実装） |
| **Wire DI** | Googleの依存性注入ツール。コンパイル時に依存性を解決 |

---

## 付録C: 参考文献

1. **Clean Architecture** - Robert C. Martin
2. **Domain-Driven Design** - Eric Evans
3. **Implementing Domain-Driven Design** - Vaughn Vernon
4. **Event Sourcing Pattern** - Microsoft Architecture Guide
5. **Wire (依存性注入)** - https://github.com/google/wire
6. **Go プロジェクト構成** - https://github.com/golang-standards/project-layout

---

**最終更新日**: 2026-03-01
**メンテナンス**: 仕様変更時は必ずこのファイルを更新し、既存の実装仕様.md（2026-02-24版）との整合性を保つこと
