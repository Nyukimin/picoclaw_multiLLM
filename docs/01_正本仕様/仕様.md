# 仕様（修正版）：PicoClaw 後段ルーティング拡張（会話LLM単一窓口・システム分岐・推論/コードワーカー）

## 実装仕様リンク（統合正本）

- 正本: `docs/01_正本仕様/実装仕様.md`
- 章分割版: `docs/02_v2統合分割仕様/実装仕様_v2_00_目次.md`

### 仕様章 → 実装章 対応
- 目的と前提 / 用語 / 全体構成 → `実装仕様.md` 1章
- ルーティングカテゴリ / 決定ルール / 分類器 → `実装仕様.md` 2章
- ワーカー出力契約 → `実装仕様.md` 4章, 5章
- ループ制御 / 再ルート → `実装仕様.md` 3章
- 可視化（宣言） → `実装仕様.md` 8章
- セキュリティとデータ取り扱い → `実装仕様.md` 6章
- セッションとメモリ → `実装仕様.md` 9章
- ログと改善データ → `実装仕様.md` 7章
- 拡張性 → `実装仕様.md` 2章（分類器管理）, 7章（ログ改善運用）

## 最終更新（2026-02-20）

本書のうち、以下は最新運用に合わせて優先適用する。

- LINE 入口は `CHAT(Kuro)` 固定（`line_forced_chat`）。
- 委譲判断は前段Routerではなく、`Kuro` が会話中に実施する。
- 画像入力は OpenAI 互換の `image_url` 形式で LLM へ送る。
- 画像受け渡しの監査ログを `provider.http` で記録する。
- 一時メディアは即時削除せず、保持時間を設ける。

## 目的と前提

* ユーザー（れん）が直接会話する相手は **会話LLM 1つ**（人格・文体・窓口は常に1つ）
* 本仕様の初期適用対象チャネルは **LINE と Slack**
  （PicoClaw本体が持つ他チャネル機能は本仕様の対象外。既存挙動を壊さない）
* ローカルLLMは **Ollama を使用**
* **常駐モデルは最低2つ**（会話LLM＋推論LLM）
* **コードが必要な場合のみ**クラウドAPIを **1本だけ**利用する（それ以外はローカル）
* LINE入口の一次決定は `CHAT(Kuro)` 固定とし、後段委譲は **Kuroの会話判断**で行う
* 役割名は **Chat / Worker / Coder** で固定し、愛称と実体LLMは設定で差し替える

  * ただし前段Routerによる直接振り分けではなく、Kuroが必要時に Worker/Coder へ委譲する

## 用語

* Chat：ユーザー応答の最終文を生成する唯一の窓口役割（ユーザーに見える発話は必ずここ）
* Worker：分類器・データ蓄積・データ分析・検証などを担う非コーディング役割
* Coder：コード生成/修正に使うコーディング役割（必要時のみクラウド）
* Router：入力をカテゴリに分岐させ、ワーカー呼び出しを制御するシステム部
* LoopController：ループ回数/停止条件/安全制約を管理し、次処理を実際に回す最終決定者（Routerに含めてもよい）
* ワーカー：推論LLM／コードLLM／（必要なら）リサーチ処理など、裏方の実行ユニット
* ループ：ワーカー処理→追加処理の必要性判断→（必要なら）次ワーカー処理…の反復

## 全体構成

* 入口（LINE/Slack）
  → PicoClaw本体（受信/送信・セッション管理）
  → Router/LoopController（分岐・制約・回数管理）
  → ワーカー（推論/コード/リサーチ等）
  → 会話LLM（最終整形・宣言・返信）
  → 入口へ返信

### 重要な制約（権限境界）

* 最終回答文は必ず会話LLMが生成する（ワーカー出力は“素材”）
* 前段での直接振り分けは行わず、Kuroが会話中に「直答/委譲」を選ぶ
* 「次のループが必要かも」という判断はワーカーが出せるが、
  **次を回す/止める最終決定は LoopController が行う**

  * 会話LLMは「続行したい/止めたい」の意見（提案）を返せるが、最終権限はシステム

## ルーティングカテゴリ（拡張可能な最小セット）

* CHAT：説明/相談/雑談/要約/レビュー
* PLAN：段取り、仕様化、タスク分解、方針決定
* ANALYZE：抽出・構造化・タグ付け・集計・傾向分析（データ蓄積を含む）
* OPS：運用手順、障害対応、設定確認、コマンド案内（実行自動化は別途）
* RESEARCH：調査、出典確認、比較、最新情報（必要時のみ）
* CODE：コード生成/修正/diff作成/実装（クラウド使用）

## ルーティング決定ルール（優先順位）

優先順位は固定：

1. 明示コマンド
2. ルール辞書（強い証拠）
3. 分類器（推論LLM）を1回だけ呼ぶ
4. 信頼度不足なら安全側に倒す（基本はCHAT/PLAN/OPS/ANALYZE）

### 明示コマンド

* `/code` `/analyze` `/plan` `/ops` `/research` `/chat` をサポート
* `/local` をサポート（クラウド利用禁止フラグを立てる）
* `/cloud` をサポート（`/local` を解除する）
* 明示コマンドは **プロンプト注入より強い**（入力本文に「/codeって書いて」とあっても、実際に先頭コマンドでなければ無効）
* `local_only=true` の間に `/code` が来た場合は、CODE実行を拒否し、
  会話LLM経由で「`/cloud` で解除が必要」を短く案内する

### ルール辞書（初期セットは「強い証拠」だけ）

* CODEは誤爆が高コストなので **強い証拠がある時だけ**確定させる

  * コードブロック、diff、スタックトレース塊、具体ファイル名/拡張子など
* OPSはコマンド語・systemd/docker/ssh等の明確な運用文脈で確定
* ANALYZEはCSV/ログ/集計語＋貼り付けデータ量などで確定
* RESEARCHはURL/出典/最新/比較などで確定
* PLANは設計/構成/仕様/タスク分解などで確定
* それ以外は分類器へ

  * 分類器呼び出し自体が失敗した場合（後述）はCHATへ倒す

## 分類器（推論LLM）の仕様

* 目的：辞書で確定できない入力に対し、route候補を提案する
* 呼び出し回数：1ユーザー入力につき最大1回（必要時のみ）
  （この上限は分類器に対する制約。再ルート時にワーカーを1回追加実行することはありうる）
* 出力形式：JSONのみ（余計なテキスト禁止）

  * `route`：6カテゴリのいずれか
  * `confidence`：0.0〜1.0
  * `reason`：短文
  * `evidence`：入力中の根拠断片（最大2）

### CODE判定のガード

* 分類器は、強い証拠が無い限りCODEを選ばない（誤爆防止）

### Router側の採用ゲート

* `confidence` が閾値未満なら安全側へ倒す
* CODEだけは閾値を高くする（例：0.8以上＋強い証拠の再確認）

### 分類器の故障時仕様（重要）

* 分類器の出力が以下の場合、**分類器結果は破棄**して CHAT へフォールバックし、ログに記録する

  * JSONとしてパース不能
  * 必須キー欠損（route/confidence）
  * routeが列挙外
  * confidenceが範囲外

## ワーカー出力契約（推論/コード共通の“戻り値”）

ワーカーは作業結果（result）に加えて、次のループが必要かを **メタ情報**として返す。

返却項目（概念）：

* `result`：作業成果（文章、JSON、差分案など）
* `needs_next_loop`：true/false
* `why`：次が必要な理由（短く）
* `next_actions`：次にやるべき候補（最大3）
* `questions_for_user`：ユーザー確認が必要な場合のみ（最大3）
* `confidence`：成果の確からしさ（0.0〜1.0）
* `risk`：low/medium/high（高リスクはエスカレーション対象）
* （任意）`fit`：このルートで適切だったか（true/false）
* （任意）`suggested_route`：再ルート提案（列挙内）

### ワーカーの故障時仕様

* ワーカー出力がパース不能/欠損の場合：

  * 当該ワーカー結果を「失敗」と扱い、LoopControllerは **追加ループを回さず**、会話LLMに「失敗の要約（短い）」だけ渡して返信させる
  * ログに記録（入力・route・失敗理由）

## ループ制御（次のループ判断）

* ワーカーが「次のループが必要」と判断することはある（情報不足、分割作業、追加診断など）
* ただし運用上の最終責任として：

  * **次を回す/止める最終決定は LoopController**
  * 会話LLMは「続行/停止/ユーザー確認」の提案を返せる（ユーザーは基本“報告”だけ受け取る）

### ユーザー確認（キャッチ）が発生する条件（例）

* `risk == high`
* `confidence` が低く、分岐が重大
* 追加情報がないと正しく進めない（環境・前提・選択肢の確定が必要）

### 自動ループの上限

* 無限ループ防止のため、システムで最大回数/最大時間を持つ（値は実装仕様で決定）
* 上限到達時は強制停止し、会話LLMが「ここまでの成果＋次に必要な入力」を短く報告する

## ユーザーへの可視化（宣言）

* 内部のクラウド/ローカル等は原則表示しない
* 表示するのは **「今なにをするか」だけ**
* 「ルートが切り替わった時」の定義：

  * **前回のユーザー返信（primary route）と今回のprimary routeが異なる時**
* ルートが切り替わった時だけ1行宣言し、同じルートが続く間は宣言しない

  * CODE：「コーディングするね。」
  * ANALYZE：「整理して分析するね。」
  * PLAN：「段取りを組むね。」
  * OPS：「手順で案内するね。」
  * RESEARCH：「調べてまとめるね。」
  * CHAT：宣言なし

## 誤分類への対策

* 誤分類は前提として許容し、事故化しない
* 最重要：CODE誤爆を抑える（強い証拠＋高信頼度＋明示/ルール優先）

### 矯正手段

* ユーザーが明示コマンドで上書きできる
* 自動再ルーティングは最大1回まで（無限ループ防止）

### 自動再ルーティングの発火条件（明確化）

以下のいずれかを満たす場合に限り、同一ユーザー入力に対して1回だけ再ルートを許可：

* ワーカーが `fit=false` を返し、かつ `suggested_route` が提示された
* 会話LLMが「目的未達」と判断し、再ルート提案を返した（ただしLoopControllerが採否を決める）
* `fit` / `suggested_route` が未実装（未返却）のワーカーでは、この条件を使わない

### 誤分類検知の主

* 強シグナル：ユーザーの否定・上書き
* 補助：ワーカーの自己申告（fit不一致）（最終決定はシステム）

## セキュリティとデータ取り扱い

* CODE以外の用途でクラウドを使わない（原則）
* `/local` 中はクラウド呼び出しを禁止（システムで強制）
* 秘密情報・個人情報・トークン類は

  * クラウド送信対象から除外する（実装でサニタイズ）
  * ログに残さない（またはマスク）
* 分類器/ワーカーへの入力に対し、ルーティングや制約を上書きする指示（プロンプト注入）を無効化する（システムルール優先）

## セッションとメモリ（状態管理）

* 入口（LINE/Slack）ごとに `session_id` を持つ（Slackはthread単位などを推奨）
* 会話履歴は全文保存ではなく、短い要約（short_memory）中心で回す（ローカル負荷/漏洩リスク低減）
* ANALYZEは構造化データ（JSON等）として蓄積できる（保存先は実装仕様で定義）

## ログと改善データ

* 最低限、以下を蓄積して辞書/閾値の改善に使う

  * 入力、初回route、分類器route/confidence（使った場合）
  * ユーザー上書きの有無、再ルート有無
  * ワーカー呼び出し有無（推論/コード）、`needs_next_loop`、`risk`、（任意）`fit`
  * 最終route
  * パース失敗等のエラー理由（分類器/ワーカー）
* ログ出力はユーザー会話に混ぜない（宣言は別）

### 画像受け渡し監査ログ（2026-02-20追加）

以下を `provider.http` ログに記録する。

- `LLM image audit before request`
  - `source_path`（一時保存ローカルパス）
  - `url_type`（`data_uri` / `remote_url`）
  - `image_url`（`data:image/...;base64,[omitted]` の要約形）
  - `image_url_length`
  - `local_exists_before`
  - `local_size_before_bytes`
  - `included`
  - `drop_reason`
- `LLM image audit after timeout`（タイムアウト時のみ）
  - `local_exists_after_timeout`
  - `local_size_after_timeout_bytes`

## 拡張性

* ルーティングカテゴリは追加可能（例：SUMMARIZE、EXPORT、INGEST等）
* 辞書はデータ駆動で追加可能（ログから育てる前提）
* 分類器プロンプトは1枚固定し、カテゴリ追加時にのみ更新する
