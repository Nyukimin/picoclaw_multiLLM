# PicoClaw å®Ÿè·µçš„ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å†è¨­è¨ˆææ¡ˆ v2.0

## Context

### å‰å›ææ¡ˆã‹ã‚‰ã®é€²åŒ–

**å‰å›ï¼ˆv1.0ï¼‰**: Clean Architecture / Hexagonal Architecture ã®ç†æƒ³çš„ãª4å±¤æ§‹é€ ã‚’ææ¡ˆ
**ä»Šå›ï¼ˆv2.0ï¼‰**: codebase-map åˆ†æã‚’è¸ã¾ãˆã€ä»¥ä¸‹ã‚’è¿½åŠ ï¼š

1. **å…·ä½“çš„ãªå•é¡Œè§£æ±º**: Agent Loop 1,980è¡Œã®åˆ†è§£ã€æ‰¿èªãƒ•ãƒ­ãƒ¼å®Œæˆã€Auto-Approveå®Ÿè£…
2. **ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°**: æ‰¿èªã‚¸ãƒ§ãƒ–ã®æ°¸ç¶šåŒ–ã¨ç›£æŸ»ãƒ­ã‚°
3. **æ®µéšçš„ç§»è¡Œ**: æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®å…±å­˜æˆ¦ç•¥
4. **æœªå®Œæˆæ©Ÿèƒ½ã®å„ªå…ˆ**: Workerå®Ÿè¡Œå§”è­²ã€MCPçµ±åˆã€Auto-Approve

### ç¾çŠ¶åˆ†æï¼ˆcodebase-map ã‚ˆã‚Šï¼‰

#### ç—›ç‚¹ Top 10

| # | å•é¡Œ | æ·±åˆ»åº¦ | çŠ¶æ…‹ | å½±éŸ¿ |
|---|------|-------|------|------|
| 1 | **Agent Loop è‚¥å¤§åŒ–** (1,980è¡Œ) | é«˜ | ç¶™ç¶š | ä¿å®ˆæ€§æœ€æ‚ªã€ãƒ†ã‚¹ãƒˆå›°é›£ |
| 2 | **Workerå®Ÿè¡Œå§”è­²** æœªå®Ÿè£… | é«˜ | 60%å®Œæˆ | æ‰¿èªå¾Œä½•ã‚‚èµ·ã“ã‚‰ãªã„ |
| 3 | **Auto-Approve** å®Œå…¨æœªå®Ÿè£… | é«˜ | 0% | Phase 4-6 åœæ» |
| 4 | **In-Memory Job Storage** | é«˜ | è¨­è¨ˆå•é¡Œ | å†èµ·å‹•ã§æ‰¿èªçŠ¶æ…‹å–ªå¤± |
| 5 | **MCP Phase 5-C** æœªå®Œæˆ | é«˜ | 50% | Chromeæ“ä½œãŒå‹•ã‹ãªã„ |
| 6 | **ç’°å¢ƒå¤‰æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ** ä¸å‹•ä½œ | ä¸­ | ãƒã‚° | è¨­å®šãŒåŠ¹ã‹ãªã„ |
| 7 | **ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰æ•£åœ¨** | ä¸­ | ç¶™ç¶š | Timezone, Timeoutç­‰ |
| 8 | **ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³** ãªã— | ä¸­ | æ¬ å¦‚ | ãƒ‡ã‚£ã‚¹ã‚¯æº¢ã‚Œãƒªã‚¹ã‚¯ |
| 9 | **API Key Masking** ãªã— | ä½ | æ¬ å¦‚ | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ |
| 10 | **è¨­å®šãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰** ãªã— | ä½ | æ¬ å¦‚ | å†èµ·å‹•å¿…é ˆ |

#### æˆåŠŸã—ã¦ã„ã‚‹ç‚¹ï¼ˆç¶™æ‰¿ã™ã¹ãï¼‰

âœ… **Provider æŠ½è±¡åŒ–**: 4ç¨®é¡ã®LLMï¼ˆOllama/Claude/OpenAI/DeepSeekï¼‰ã‚’çµ±ä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ç®¡ç†
âœ… **Session Management**: æ—¥æ¬¡ã‚«ãƒƒãƒˆã‚ªãƒ¼ãƒãƒ¼ã€JSONæ°¸ç¶šåŒ–
âœ… **Router + Classifier**: 4æ®µéšãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ï¼ˆæ˜ç¤ºã‚³ãƒãƒ³ãƒ‰ â†’ ãƒ«ãƒ¼ãƒ«è¾æ›¸ â†’ åˆ†é¡å™¨ â†’ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
âœ… **Approval Manager**: åŸºæœ¬æ§‹é€ ã¯å®Œæˆï¼ˆå®Ÿè¡ŒãŒæœªå®Ÿè£…ï¼‰

---

## æ–°ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### è¨­è¨ˆåŸå‰‡ï¼ˆv1.0ã‹ã‚‰ç¶™æ‰¿ + è¿½åŠ ï¼‰

1. **Hexagonal Architecture** ï¼ˆãƒãƒ¼ãƒˆï¼†ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ï¼‰
   - ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã¯å¤–éƒ¨ã«ä¾å­˜ã—ãªã„
   - ã‚¤ãƒ³ãƒ•ãƒ©å±¤ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ã«ä¾å­˜

2. **Event Sourcing + CQRS** ï¼ˆæ–°è¦è¿½åŠ ï¼‰
   - æ‰¿èªãƒ•ãƒ­ãƒ¼ã‚’ Event Store ã§æ°¸ç¶šåŒ–
   - ç›£æŸ»ãƒ­ã‚°ã¨ãƒªã‚«ãƒãƒªã‚’å®Ÿç¾

3. **Micro-Kernel Pattern** ï¼ˆæ–°è¦è¿½åŠ ï¼‰
   - ã‚³ã‚¢ã‚’æœ€å°é™ã«ä¿ã¤
   - æ©Ÿèƒ½ã¯ Plugin ã¨ã—ã¦è¿½åŠ 

4. **SOLIDåŸå‰‡** ï¼ˆç¶™æ‰¿ï¼‰
   - å˜ä¸€è²¬ä»»ã€é–‹æ”¾é–‰é–ã€ä¾å­˜æ€§é€†è»¢

5. **å®Ÿç”¨ä¸»ç¾©** ï¼ˆæ–°è¦è¿½åŠ ï¼‰
   - å®Œç’§ã‚ˆã‚Šå‹•ãã‚‚ã®ã‚’å„ªå…ˆ
   - æ®µéšçš„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
   - æ—¢å­˜ã®è‰¯ã„ã‚³ãƒ¼ãƒ‰ã¯æ´»ã‹ã™

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å›³

```mermaid
graph TB
    subgraph "Presentation Layer (Adapters)"
        LINE[LINE Handler]
        Slack[Slack Handler]
        CLI[CLI Handler]
    end

    subgraph "Application Layer (Use Cases + Events)"
        ProcessMsg[ProcessMessage UseCase]
        Orchestrator[MessageOrchestrator]
        ApprovalUC[ManageApproval UseCase]
        EventStore[(Event Store<br/>SQLite)]
    end

    subgraph "Domain Layer (Core Business Logic)"
        Agent[Agent Entity]
        Task[Task VO]
        ApprovalFlow[ApprovalFlow Aggregate]
        AutoApprovePolicy[AutoApprove Policy]
        Events[Domain Events]
    end

    subgraph "Infrastructure Layer"
        Providers[LLM Providers]
        SessionRepo[Session Repository]
        JobRepo[Job Repository<br/>â€»æ–°è¦]
        EventBus[Event Bus]
    end

    LINE --> ProcessMsg
    Slack --> ProcessMsg
    CLI --> ProcessMsg

    ProcessMsg --> Orchestrator
    Orchestrator --> Agent
    Orchestrator --> ApprovalUC
    ApprovalUC --> ApprovalFlow
    ApprovalFlow --> AutoApprovePolicy
    ApprovalFlow -.publish.-> Events
    Events --> EventStore

    Agent -.depends on.-> Providers
    ApprovalFlow -.depends on.-> JobRepo
    Orchestrator --> SessionRepo
    EventStore -.replay.-> ApprovalFlow
```

---

## é‡è¦ãªè¨­è¨ˆæ±ºå®š

### 1. Event Sourcing for Approval Flow

**å•é¡Œ**: In-Memory Job Storage â†’ å†èµ·å‹•ã§æ‰¿èªçŠ¶æ…‹å–ªå¤±

**è§£æ±º**: Event Storeï¼ˆSQLiteï¼‰ã§æ‰¿èªãƒ•ãƒ­ãƒ¼ã‚’æ°¸ç¶šåŒ–

```go
// internal/domain/approval/events.go
type ApprovalEvent interface {
    EventType() string
    AggregateID() string
    Timestamp() time.Time
}

type ApprovalRequested struct {
    JobID     string
    Proposal  Proposal
    CreatedAt time.Time
}

type ApprovalGranted struct {
    JobID      string
    GrantedBy  string
    GrantedAt  time.Time
}

type AutoApprovalGranted struct {
    JobID     string
    Scope     AutoApproveScope
    GrantedAt time.Time
}

type PatchExecutionStarted struct {
    JobID     string
    Patch     string
    StartedAt time.Time
}

type PatchExecutionCompleted struct {
    JobID       string
    Success     bool
    Result      string
    CompletedAt time.Time
}
```

**Event Store å®Ÿè£…**:

```go
// internal/infrastructure/eventstore/sqlite_store.go
type SQLiteEventStore struct {
    db *sql.DB
}

func (s *SQLiteEventStore) Append(event ApprovalEvent) error {
    // INSERT INTO events (aggregate_id, event_type, payload, timestamp)
}

func (s *SQLiteEventStore) GetEventsForJob(jobID string) ([]ApprovalEvent, error) {
    // SELECT * FROM events WHERE aggregate_id = ? ORDER BY timestamp
}

func (s *SQLiteEventStore) Replay(jobID string) (*ApprovalFlow, error) {
    events, _ := s.GetEventsForJob(jobID)
    flow := &ApprovalFlow{}
    for _, event := range events {
        flow.Apply(event)
    }
    return flow, nil
}
```

### 2. Worker Execution Serviceï¼ˆæœªå®Ÿè£…æ©Ÿèƒ½ã®å®Œæˆï¼‰

**å•é¡Œ**: æ‰¿èªå¾Œã®ãƒ‘ãƒƒãƒé©ç”¨ãŒæœªå®Ÿè£…

**è§£æ±º**: WorkerExecutionService ã‚’æ–°è¨­

```go
// internal/application/service/worker_execution.go
type WorkerExecutionService struct {
    eventStore EventStore
    toolRunner *tools.ToolRegistry
    mcpClient  *mcp.Client
}

func (w *WorkerExecutionService) ExecuteProposal(ctx context.Context, jobID string, proposal Proposal) error {
    // 1. Event ç™ºè¡Œ: PatchExecutionStarted
    w.eventStore.Append(PatchExecutionStarted{JobID: jobID, Patch: proposal.Patch})

    // 2. Patch ã‚’è§£æã—ã¦ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—
    commands := ParsePatch(proposal.Patch)

    for _, cmd := range commands {
        if cmd.Type == "chrome" {
            // MCPçµŒç”±ã§Chromeæ“ä½œ
            result, err := w.mcpClient.ExecuteChromeCommand(cmd)
        } else {
            // é€šå¸¸ã®ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œ
            result, err := w.toolRunner.Execute(cmd)
        }
    }

    // 3. Event ç™ºè¡Œ: PatchExecutionCompleted
    w.eventStore.Append(PatchExecutionCompleted{JobID: jobID, Success: true})
}
```

### 3. Auto-Approve Systemï¼ˆå®Œå…¨æ–°è¦å®Ÿè£…ï¼‰

**å•é¡Œ**: Auto-Approve ãŒå®Œå…¨æœªå®Ÿè£…

**è§£æ±º**: Policy-based Auto-Approve with Scope & TTL

```go
// internal/domain/approval/auto_approve.go
type AutoApprovePolicy struct {
    enabled   bool
    scope     Scope
    expiresAt time.Time
}

type Scope struct {
    AllowedRoutes []routing.Route  // e.g., [CODE3]
    AllowedPaths  []string          // e.g., ["*.go", "pkg/**"]
    ExcludeFlags  []string          // e.g., ["uses_browser"]
}

func (p *AutoApprovePolicy) IsApplicable(task Task, proposal Proposal) bool {
    // 1. Enabled ãƒã‚§ãƒƒã‚¯
    if !p.enabled {
        return false
    }

    // 2. TTL ãƒã‚§ãƒƒã‚¯
    if time.Now().After(p.expiresAt) {
        return false
    }

    // 3. Route ãƒã‚§ãƒƒã‚¯
    if !p.scope.MatchesRoute(task.Route()) {
        return false
    }

    // 4. Path ãƒã‚§ãƒƒã‚¯
    if !p.scope.MatchesPaths(proposal.AffectedFiles()) {
        return false
    }

    // 5. Exclude Flags ãƒã‚§ãƒƒã‚¯
    if proposal.HasFlag("uses_browser") && p.scope.ExcludesFlag("uses_browser") {
        return false
    }

    return true
}

func (p *AutoApprovePolicy) Enable(scope Scope, ttl time.Duration) {
    p.enabled = true
    p.scope = scope
    p.expiresAt = time.Now().Add(ttl)
}

func (p *AutoApprovePolicy) Disable() {
    p.enabled = false
}
```

### 4. Agent Loop åˆ†è§£æˆ¦ç•¥

**å•é¡Œ**: 1,980è¡Œã®è‚¥å¤§åŒ–

**è§£æ±º**: è²¬å‹™åˆ¥ã«5ã¤ã®ã‚µãƒ¼ãƒ“ã‚¹ã«åˆ†å‰²

```
agent/loop.go (1,980è¡Œ)
    â†“ åˆ†è§£
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MessageOrchestrator (300è¡Œ)             â”‚ â† ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼èª¿æ•´
â”‚  - processMessage()                      â”‚
â”‚  - handleCommand()                       â”‚
â”‚  - delegateToService()                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â”œâ”€â†’ RoutingService (200è¡Œ)
            â”‚    - decide()
            â”‚    - applyRules()
            â”‚    - classifyWithLLM()
            â”‚
            â”œâ”€â†’ LLMIteratorService (300è¡Œ)
            â”‚    - reflectionLoop()
            â”‚    - callLLM()
            â”‚    - parseResponse()
            â”‚
            â”œâ”€â†’ ApprovalService (250è¡Œ)
            â”‚    - requestApproval()
            â”‚    - checkAutoApprove()
            â”‚    - waitForDecision()
            â”‚
            â”œâ”€â†’ WorkerExecutionService (200è¡Œ)
            â”‚    - executePatch()
            â”‚    - runTools()
            â”‚    - integrateMCP()
            â”‚
            â””â”€â†’ MemoryService (150è¡Œ)
                 - dailyCutover()
                 - saveDailyNote()
                 - resetSessions()
```

**æ®µéšçš„ç§»è¡Œ**:

1. **Week 1**: WorkerExecutionService æŠ½å‡ºï¼ˆæœ€å„ªå…ˆã€æœªå®Ÿè£…æ©Ÿèƒ½å®Œæˆï¼‰
2. **Week 2**: ApprovalService æŠ½å‡ºï¼ˆAuto-Approveè¿½åŠ ï¼‰
3. **Week 3**: RoutingService æŠ½å‡º
4. **Week 4**: LLMIteratorService æŠ½å‡º
5. **Week 5**: MemoryService æŠ½å‡º
6. **Week 6**: MessageOrchestrator æœ€çµ‚çµ±åˆ

### 5. Configuration Management æ”¹å–„

**å•é¡Œ**: ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰æ•£åœ¨ã€ç’°å¢ƒå¤‰æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸å‹•ä½œ

**è§£æ±º**: Layered Configuration with Validation

```go
// internal/infrastructure/config/loader.go
type ConfigLoader struct {
    layers []ConfigLayer
}

type ConfigLayer interface {
    Load() (*Config, error)
    Priority() int
}

// Layer 1: Defaults (lowest priority)
type DefaultConfigLayer struct{}
func (d *DefaultConfigLayer) Load() (*Config, error) {
    return &Config{
        Timezone:        "UTC",          // ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰æ’é™¤
        MCPTimeout:      30 * time.Second,
        OllamaMaxContext: 8192,
        LogRotation:     LogRotationConfig{MaxSize: "100MB", MaxAge: "7d"},
    }, nil
}

// Layer 2: File Config
type FileConfigLayer struct{ path string }
func (f *FileConfigLayer) Load() (*Config, error) {
    // config.yaml ã‚’èª­ã¿è¾¼ã¿
}

// Layer 3: Environment Variables (highest priority)
type EnvConfigLayer struct{}
func (e *EnvConfigLayer) Load() (*Config, error) {
    cfg := &Config{}
    // å…·ä½“çš„ãª env ã‚¿ã‚°ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ’é™¤ï¼‰
    cfg.Providers.Claude.APIKey = os.Getenv("ANTHROPIC_API_KEY")
    cfg.Providers.OpenAI.APIKey = os.Getenv("OPENAI_API_KEY")
    cfg.Providers.DeepSeek.APIKey = os.Getenv("DEEPSEEK_API_KEY")
    // ...
    return cfg, nil
}

// Merge and Validate
func (l *ConfigLoader) LoadAndValidate() (*Config, error) {
    merged := &Config{}
    for _, layer := range l.layers {
        layerCfg, _ := layer.Load()
        merged = MergeConfig(merged, layerCfg)
    }

    // Validation
    if err := ValidateConfig(merged); err != nil {
        return nil, err
    }

    return merged, nil
}
```

### 6. MCP Integration å®Œæˆï¼ˆPhase 5-Cï¼‰

**å•é¡Œ**: MCP Client å®Ÿè£…æ¸ˆã¿ã ãŒ Agent Loop çµ±åˆãªã—

**è§£æ±º**: Chrome Command Detection + MCP Execution

```go
// internal/application/service/worker_execution.go (è¿½åŠ )
func (w *WorkerExecutionService) detectChromeCommands(patch string) []ChromeCommand {
    // Patch ã‚’è§£æã—ã¦ Chrome æ“ä½œã‚’æ¤œå‡º
    // ä¾‹: "ãƒ–ãƒ©ã‚¦ã‚¶ã§ https://example.com ã‚’é–‹ã„ã¦..."

    patterns := []string{
        "ãƒ–ãƒ©ã‚¦ã‚¶ã§.*ã‚’é–‹ã„ã¦",
        "Chrome.*ã§.*ã‚’.*",
        "Webãƒšãƒ¼ã‚¸.*ã«ã‚¢ã‚¯ã‚»ã‚¹",
    }

    commands := []ChromeCommand{}
    for _, pattern := range patterns {
        if matched := regexp.MustCompile(pattern).FindString(patch); matched != "" {
            cmd := ParseChromeCommand(matched)
            commands = append(commands, cmd)
        }
    }

    return commands
}

func (w *WorkerExecutionService) ExecuteProposal(ctx context.Context, jobID string, proposal Proposal) error {
    // Chrome ã‚³ãƒãƒ³ãƒ‰æ¤œå‡º
    chromeCommands := w.detectChromeCommands(proposal.Patch)

    if len(chromeCommands) > 0 {
        // uses_browser ãƒ•ãƒ©ã‚°è¨­å®š
        proposal.SetFlag("uses_browser", true)

        // Auto-Approve åˆ¤å®šï¼ˆChromeæ“ä½œã¯é™¤å¤–ï¼‰
        if autoApprovePolicy.IsApplicable(task, proposal) {
            // Scopeã§ uses_browser ãŒé™¤å¤–ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        }

        // MCP Client çµŒç”±ã§å®Ÿè¡Œ
        for _, cmd := range chromeCommands {
            result, err := w.mcpClient.Execute(cmd)
            if err != nil {
                return err
            }
        }
    }

    // é€šå¸¸ã®ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œ
    // ...
}
```

---

## ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹é€ ï¼ˆå®Ÿè·µçš„ç‰ˆï¼‰

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼

```
picoclaw_multiLLM/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ picoclaw/
â”‚       â”œâ”€â”€ main.go              # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚       â””â”€â”€ wire.go              # ä¾å­˜æ€§æ³¨å…¥ï¼ˆWireï¼‰
â”‚
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ domain/                  # ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ï¼ˆç´”ç²‹ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
â”‚   â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”‚   â”œâ”€â”€ agent.go        # Agent ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
â”‚   â”‚   â”‚   â”œâ”€â”€ role.go         # Role enum
â”‚   â”‚   â”‚   â””â”€â”€ events.go       # Domain Events
â”‚   â”‚   â”œâ”€â”€ task/
â”‚   â”‚   â”‚   â”œâ”€â”€ task.go         # Task å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”‚   â””â”€â”€ job_id.go       # JobID å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”œâ”€â”€ proposal/
â”‚   â”‚   â”‚   â””â”€â”€ proposal.go     # Proposal å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”œâ”€â”€ approval/
â”‚   â”‚   â”‚   â”œâ”€â”€ flow.go         # ApprovalFlow ã‚¢ã‚°ãƒªã‚²ãƒ¼ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ auto_approve.go # AutoApprove Policy â€»æ–°è¦
â”‚   â”‚   â”‚   â”œâ”€â”€ scope.go        # Scope VO â€»æ–°è¦
â”‚   â”‚   â”‚   â””â”€â”€ events.go       # Approval Events â€»æ–°è¦
â”‚   â”‚   â”œâ”€â”€ routing/
â”‚   â”‚   â”‚   â”œâ”€â”€ decision.go     # RoutingDecision
â”‚   â”‚   â”‚   â””â”€â”€ route.go        # Route enum
â”‚   â”‚   â””â”€â”€ session/
â”‚   â”‚       â”œâ”€â”€ session.go      # Session ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
â”‚   â”‚       â””â”€â”€ repository.go   # Repository interface
â”‚   â”‚
â”‚   â”œâ”€â”€ application/             # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
â”‚   â”‚   â”œâ”€â”€ usecase/
â”‚   â”‚   â”‚   â”œâ”€â”€ process_message.go    # ProcessUserMessage
â”‚   â”‚   â”‚   â””â”€â”€ manage_approval.go    # ManageApproval â€»æ”¹å–„
â”‚   â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”‚   â”œâ”€â”€ message_orchestrator.go   # â€»Agent Loop åˆ†è§£
â”‚   â”‚   â”‚   â”œâ”€â”€ routing_service.go        # â€»Agent Loop åˆ†è§£
â”‚   â”‚   â”‚   â”œâ”€â”€ llm_iterator_service.go   # â€»Agent Loop åˆ†è§£
â”‚   â”‚   â”‚   â”œâ”€â”€ approval_service.go       # â€»Auto-Approve è¿½åŠ 
â”‚   â”‚   â”‚   â”œâ”€â”€ worker_execution_service.go # â€»æ–°è¦ï¼ˆWorkerå®Ÿè¡Œï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ memory_service.go         # â€»Agent Loop åˆ†è§£
â”‚   â”‚   â”‚   â””â”€â”€ event_handlers.go
â”‚   â”‚   â””â”€â”€ port/
â”‚   â”‚       â”œâ”€â”€ inbound.go
â”‚   â”‚       â””â”€â”€ outbound.go
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/          # ã‚¤ãƒ³ãƒ•ãƒ©å±¤
â”‚   â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”‚   â”œâ”€â”€ ollama/         # æ—¢å­˜æ´»ç”¨
â”‚   â”‚   â”‚   â”œâ”€â”€ claude/         # æ—¢å­˜æ´»ç”¨
â”‚   â”‚   â”‚   â”œâ”€â”€ openai/         # æ—¢å­˜æ´»ç”¨
â”‚   â”‚   â”‚   â””â”€â”€ deepseek/       # æ—¢å­˜æ´»ç”¨
â”‚   â”‚   â”œâ”€â”€ persistence/
â”‚   â”‚   â”‚   â”œâ”€â”€ eventstore/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ sqlite_store.go       # â€»æ–°è¦ï¼ˆEvent Storeï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ session/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ json_repo.go          # æ—¢å­˜æ´»ç”¨
â”‚   â”‚   â”‚   â””â”€â”€ job/
â”‚   â”‚   â”‚       â””â”€â”€ sqlite_repo.go        # â€»æ–°è¦ï¼ˆJobæ°¸ç¶šåŒ–ï¼‰
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â””â”€â”€ loader.go                 # â€»æ”¹å–„ï¼ˆLayered Configï¼‰
â”‚   â”‚   â””â”€â”€ mcp/
â”‚   â”‚       â””â”€â”€ client.go                 # æ—¢å­˜æ´»ç”¨ + Phase 5-Cå®Œæˆ
â”‚   â”‚
â”‚   â””â”€â”€ adapter/                 # ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼å±¤
â”‚       â”œâ”€â”€ inbound/
â”‚       â”‚   â”œâ”€â”€ line/           # æ—¢å­˜æ´»ç”¨
â”‚       â”‚   â”œâ”€â”€ slack/          # æ—¢å­˜æ´»ç”¨
â”‚       â”‚   â””â”€â”€ cli/            # æ—¢å­˜æ´»ç”¨
â”‚       â””â”€â”€ outbound/
â”‚           â””â”€â”€ notification/
â”‚               â””â”€â”€ sender.go
â”‚
â”œâ”€â”€ pkg/                         # å…¬é–‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
â”‚   â”œâ”€â”€ event/
â”‚   â”‚   â””â”€â”€ bus.go              # Event Bus
â”‚   â””â”€â”€ logger/
â”‚       â”œâ”€â”€ logger.go           # æ—¢å­˜æ´»ç”¨
â”‚       â””â”€â”€ masking.go          # â€»æ–°è¦ï¼ˆAPI Key Maskingï¼‰
â”‚
â”œâ”€â”€ db/                          # â€»æ–°è¦ï¼ˆDatabase Migrationsï¼‰
â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ 001_create_events_table.sql
â”‚   â”‚   â””â”€â”€ 002_create_jobs_table.sql
â”‚   â””â”€â”€ schema.sql
â”‚
â””â”€â”€ config/
    â”œâ”€â”€ config.yaml             # æ—¢å­˜æ”¹å–„
    â””â”€â”€ config.example.yaml
```

---

## ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒï¼ˆEvent Store + Job Repositoryï¼‰

### events ãƒ†ãƒ¼ãƒ–ãƒ«

```sql
CREATE TABLE events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    aggregate_id TEXT NOT NULL,      -- JobID
    aggregate_type TEXT NOT NULL,    -- "ApprovalFlow"
    event_type TEXT NOT NULL,        -- "ApprovalRequested", "ApprovalGranted", etc.
    payload TEXT NOT NULL,           -- JSON
    timestamp DATETIME NOT NULL,
    metadata TEXT,                   -- JSON (user_id, ip_address, etc.)

    INDEX idx_aggregate (aggregate_id, timestamp)
);
```

### jobs ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆRead Model for CQRSï¼‰

```sql
CREATE TABLE jobs (
    job_id TEXT PRIMARY KEY,
    route TEXT NOT NULL,             -- "CODE3"
    status TEXT NOT NULL,            -- "pending", "granted", "denied", "completed"
    proposal_plan TEXT,
    proposal_patch TEXT,
    proposal_risk TEXT,
    cost_hint TEXT,                  -- â€»æ–°è¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    uses_browser BOOLEAN,            -- â€»æ–°è¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    requested_at DATETIME NOT NULL,
    granted_at DATETIME,
    granted_by TEXT,
    executed_at DATETIME,
    execution_result TEXT,

    INDEX idx_status (status)
);
```

### auto_approve_policies ãƒ†ãƒ¼ãƒ–ãƒ«

```sql
CREATE TABLE auto_approve_policies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    enabled BOOLEAN NOT NULL,
    scope_routes TEXT NOT NULL,      -- JSON array: ["CODE3"]
    scope_paths TEXT NOT NULL,       -- JSON array: ["*.go", "pkg/**"]
    exclude_flags TEXT NOT NULL,     -- JSON array: ["uses_browser"]
    expires_at DATETIME NOT NULL,
    created_at DATETIME NOT NULL,
    created_by TEXT NOT NULL,

    INDEX idx_enabled_expires (enabled, expires_at)
);
```

---

## ç§»è¡Œæˆ¦ç•¥ï¼ˆæ®µéšçš„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ï¼‰

### Phase 1: Critical Fixesï¼ˆWeek 1-2ï¼‰

**ç›®æ¨™**: æœªå®Ÿè£…æ©Ÿèƒ½ã®å®Œæˆ

1. **WorkerExecutionService å®Ÿè£…**
   - `internal/application/service/worker_execution_service.go` æ–°è¦ä½œæˆ
   - Patch è§£æ â†’ ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œ â†’ Event è¨˜éŒ²
   - æ—¢å­˜ã® Approval Manager ã¨çµ±åˆ

2. **Event Store å®Ÿè£…**
   - SQLite ãƒ™ãƒ¼ã‚¹ã® Event Store
   - Migration ã‚¹ã‚¯ãƒªãƒ—ãƒˆä½œæˆ
   - ApprovalFlow â†’ Event Sourcing ç§»è¡Œ

3. **MCP Phase 5-C å®Œæˆ**
   - Chrome Command Detection
   - MCP Client çµ±åˆ
   - `uses_browser` ãƒ•ãƒ©ã‚°è¨­å®š

**æ¤œè¨¼**:
```bash
# E2E ãƒ†ã‚¹ãƒˆ: æ‰¿èª â†’ å®Ÿè¡Œã®å®Œå…¨ãƒ•ãƒ­ãƒ¼
go test ./test/e2e/approval_execution_test.go
```

### Phase 2: Auto-Approve Implementationï¼ˆWeek 3-4ï¼‰

**ç›®æ¨™**: Auto-Approve å®Œå…¨å®Ÿè£…

1. **AutoApprovePolicy å®Ÿè£…**
   - `internal/domain/approval/auto_approve.go` æ–°è¦ä½œæˆ
   - Scope, TTL, Exclude Flags
   - DB æ°¸ç¶šåŒ–

2. **ApprovalService æ”¹å–„**
   - Auto-Approve åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯è¿½åŠ 
   - `/auto-approve enable` ã‚³ãƒãƒ³ãƒ‰è¿½åŠ 
   - `/auto-approve disable` ã‚³ãƒãƒ³ãƒ‰è¿½åŠ 
   - `/auto-approve status` ã‚³ãƒãƒ³ãƒ‰è¿½åŠ 

3. **E2E ãƒ†ã‚¹ãƒˆ**
   - Auto-Approve æœ‰åŠ¹ â†’ CODE3 â†’ è‡ªå‹•æ‰¿èª â†’ å®Ÿè¡Œ
   - Chromeæ“ä½œé™¤å¤–ãƒ†ã‚¹ãƒˆ

**æ¤œè¨¼**:
```bash
go test ./test/e2e/auto_approve_test.go
```

### Phase 3: Agent Loop Decompositionï¼ˆWeek 5-8ï¼‰

**ç›®æ¨™**: 1,980è¡Œã‚’5ã‚µãƒ¼ãƒ“ã‚¹ã«åˆ†è§£

**é€±æ¬¡è¨ˆç”»**:
- Week 5: WorkerExecutionService æŠ½å‡ºï¼ˆå®Œäº†æ¸ˆã¿ï¼‰
- Week 6: ApprovalService æŠ½å‡º
- Week 7: RoutingService æŠ½å‡º
- Week 8: LLMIteratorService, MemoryService æŠ½å‡º

**å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³**ï¼ˆä¾‹: RoutingServiceï¼‰:

```go
// Step 1: Extract interface
type RoutingService interface {
    Decide(ctx context.Context, task Task) (RoutingDecision, error)
}

// Step 2: Implement service
type routingService struct {
    router     *Router
    classifier *Classifier
    ruleDictionary *RuleDictionary
}

func (r *routingService) Decide(ctx context.Context, task Task) (RoutingDecision, error) {
    // 1. æ˜ç¤ºã‚³ãƒãƒ³ãƒ‰
    if cmd := parseCommand(task.UserMessage()); cmd != "" {
        return RoutingDecision{Route: cmd, Source: "explicit"}, nil
    }

    // 2. ãƒ«ãƒ¼ãƒ«è¾æ›¸
    if route := r.ruleDictionary.Match(task); route != RouteUnknown {
        return RoutingDecision{Route: route, Source: "rule"}, nil
    }

    // 3. åˆ†é¡å™¨
    decision, err := r.classifier.Classify(ctx, task)
    if err != nil || decision.Confidence < threshold {
        return RoutingDecision{Route: RouteCHAT, Source: "fallback"}, nil
    }

    return decision, nil
}

// Step 3: Replace in AgentLoop
// Before:
//   decision := al.router.Decide(...)
// After:
//   decision := al.routingService.Decide(...)
```

### Phase 4: Configuration & Infrastructureï¼ˆWeek 9-10ï¼‰

**ç›®æ¨™**: è¨­å®šç®¡ç†ã¨ã‚¤ãƒ³ãƒ•ãƒ©æ”¹å–„

1. **Layered Configuration**
   - DefaultConfigLayer, FileConfigLayer, EnvConfigLayer å®Ÿè£…
   - ç’°å¢ƒå¤‰æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‰Šé™¤ï¼ˆå…·ä½“çš„ã‚¿ã‚°ã«ç½®æ›ï¼‰
   - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è¿½åŠ 

2. **Logging æ”¹å–„**
   - API Key Masking å®Ÿè£…
   - Log Rotation å®Ÿè£…ï¼ˆsize-based: 100MB, time-based: 7daysï¼‰

3. **Hot-Reload å¯¾å¿œ**
   - SIGHUP ã‚·ã‚°ãƒŠãƒ«å—ä¿¡ã§è¨­å®šå†èª­ã¿è¾¼ã¿
   - Graceful ãªè¨­å®šå¤‰æ›´

**æ¤œè¨¼**:
```bash
# è¨­å®šæ¤œè¨¼
go test ./internal/infrastructure/config/...

# ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ¤œè¨¼
# ï¼ˆæ‰‹å‹•: 100MBæ›¸ãè¾¼ã¿ â†’ ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ç¢ºèªï¼‰
```

---

## å®Ÿè£…å„ªå…ˆé †ä½

### æœ€å„ªå…ˆï¼ˆPhase 1ï¼‰- Week 1-2

| ã‚¿ã‚¹ã‚¯ | ç†ç”± | å½±éŸ¿ |
|--------|------|------|
| **WorkerExecutionService** | æ‰¿èªãƒ•ãƒ­ãƒ¼60%å®Œæˆ â†’ 100%ã¸ | é«˜ |
| **Event Store** | æ‰¿èªçŠ¶æ…‹ã®æ°¸ç¶šåŒ– | é«˜ |
| **MCP Phase 5-C** | Chromeæ“ä½œçµ±åˆ | é«˜ |

### é«˜å„ªå…ˆï¼ˆPhase 2ï¼‰- Week 3-4

| ã‚¿ã‚¹ã‚¯ | ç†ç”± | å½±éŸ¿ |
|--------|------|------|
| **Auto-Approve** | å®Œå…¨æœªå®Ÿè£… â†’ ä»•æ§˜æ›¸ã®è¦ä»¶æº€ãŸã™ | é«˜ |
| **cost_hint ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰** | Coder3ä»•æ§˜ã§å¿…é ˆ | ä¸­ |

### ä¸­å„ªå…ˆï¼ˆPhase 3ï¼‰- Week 5-8

| ã‚¿ã‚¹ã‚¯ | ç†ç”± | å½±éŸ¿ |
|--------|------|------|
| **Agent Loop åˆ†è§£** | ä¿å®ˆæ€§å‘ä¸Š | ä¸­ |
| **Routing/LLM/Memory Service** | ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š | ä¸­ |

### ä½å„ªå…ˆï¼ˆPhase 4ï¼‰- Week 9-10

| ã‚¿ã‚¹ã‚¯ | ç†ç”± | å½±éŸ¿ |
|--------|------|------|
| **Config æ”¹å–„** | é‹ç”¨æ”¹å–„ | ä½ |
| **Logging æ”¹å–„** | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»é‹ç”¨æ”¹å–„ | ä½ |

---

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰ï¼ˆæ”¹å–„ç‰ˆï¼‰

```
          /\
         /E2E\          â† 15% (ä¸»è¦ã‚·ãƒŠãƒªã‚ª + æ–°æ©Ÿèƒ½)
        /------\
       /Integration\    â† 25% (Event Store, Workerå®Ÿè¡Œ)
      /------------\
     /  Unit Tests  \   â† 60% (Domainå±¤ + Serviceå±¤)
    /----------------\
```

### æ–°è¦ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

#### 1. WorkerExecutionService ãƒ†ã‚¹ãƒˆ

```go
func TestWorkerExecutionService_ExecuteProposal(t *testing.T) {
    // Arrange
    mockEventStore := &MockEventStore{}
    mockToolRunner := &MockToolRunner{}
    mockMCPClient := &MockMCPClient{}

    service := NewWorkerExecutionService(mockEventStore, mockToolRunner, mockMCPClient)

    proposal := Proposal{
        Plan:  "Test plan",
        Patch: "diff --git a/test.go\n+func Test() {}",
        Risk:  "low",
    }

    // Act
    err := service.ExecuteProposal(context.Background(), "job_001", proposal)

    // Assert
    assert.NoError(t, err)
    assert.Equal(t, 2, mockEventStore.AppendCallCount()) // Started + Completed
}
```

#### 2. Auto-Approve ãƒ†ã‚¹ãƒˆ

```go
func TestAutoApprovePolicy_IsApplicable(t *testing.T) {
    // Arrange
    policy := &AutoApprovePolicy{
        enabled: true,
        scope: Scope{
            AllowedRoutes: []Route{RouteCODE3},
            AllowedPaths:  []string{"*.go"},
            ExcludeFlags:  []string{"uses_browser"},
        },
        expiresAt: time.Now().Add(1 * time.Hour),
    }

    task := Task{route: RouteCODE3}
    proposal := Proposal{
        AffectedFiles: []string{"pkg/test.go"},
        Flags:         map[string]bool{},
    }

    // Act
    applicable := policy.IsApplicable(task, proposal)

    // Assert
    assert.True(t, applicable)
}

func TestAutoApprovePolicy_ExcludesBrowserFlag(t *testing.T) {
    // Arrange
    policy := &AutoApprovePolicy{
        enabled: true,
        scope: Scope{
            AllowedRoutes: []Route{RouteCODE3},
            ExcludeFlags:  []string{"uses_browser"},
        },
        expiresAt: time.Now().Add(1 * time.Hour),
    }

    task := Task{route: RouteCODE3}
    proposal := Proposal{
        Flags: map[string]bool{"uses_browser": true},
    }

    // Act
    applicable := policy.IsApplicable(task, proposal)

    // Assert
    assert.False(t, applicable) // uses_browser ãƒ•ãƒ©ã‚°ã§é™¤å¤–
}
```

#### 3. Event Store ãƒ†ã‚¹ãƒˆ

```go
func TestSQLiteEventStore_AppendAndReplay(t *testing.T) {
    // Arrange
    db := setupTestDB(t)
    store := NewSQLiteEventStore(db)

    // Act: Append events
    store.Append(ApprovalRequested{JobID: "job_001", CreatedAt: time.Now()})
    store.Append(ApprovalGranted{JobID: "job_001", GrantedBy: "user123", GrantedAt: time.Now()})

    // Act: Replay
    flow, err := store.Replay("job_001")

    // Assert
    assert.NoError(t, err)
    assert.Equal(t, StatusGranted, flow.Status())
    assert.Equal(t, "user123", flow.GrantedBy())
}
```

---

## FAQ

### Q1: Event Sourcing ã¯éå‰°ã§ã¯ï¼Ÿ

**A**: æ‰¿èªãƒ•ãƒ­ãƒ¼ã«ã¯å¿…é ˆã§ã™ã€‚ç†ç”±ï¼š
- ç›£æŸ»ãƒ­ã‚°ï¼ˆèª°ãŒã€ã„ã¤ã€ä½•ã‚’æ‰¿èªã—ãŸã‹ï¼‰
- ãƒªã‚«ãƒãƒªï¼ˆå†èµ·å‹•å¾Œã‚‚æ‰¿èªçŠ¶æ…‹ã‚’å¾©å…ƒï¼‰
- ãƒ‡ãƒãƒƒã‚°ï¼ˆæ‰¿èªãƒ•ãƒ­ãƒ¼ã®å±¥æ­´ã‚’è¿½è·¡ï¼‰

æœ€å°é™ã®å®Ÿè£…ï¼ˆSQLite + 3ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ãªã®ã§ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¯å°ã•ã„ã€‚

### Q2: æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ã¯ï¼Ÿ

**A**: å®Œå…¨äº’æ›ã‚’ç¶­æŒã—ã¾ã™ï¼š
- å¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆLINE, Slack, CLIï¼‰ã¯å¤‰æ›´ãªã—
- æ—¢å­˜ã®è‰¯ã„ã‚³ãƒ¼ãƒ‰ï¼ˆProvider, SessionManager, Routerï¼‰ã¯æ´»ç”¨
- æ®µéšçš„ç§»è¡Œãªã®ã§ã€é€”ä¸­ã§ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯èƒ½

### Q3: Phase 1-2 ã§æœ€ä½é™å‹•ãã‹ï¼Ÿ

**A**: Yesã€‚Phase 1-2 å®Œäº†ã§ä»¥ä¸‹ãŒå‹•ä½œï¼š
- âœ… åŸºæœ¬çš„ãª Chat/Worker/Coder ãƒ•ãƒ­ãƒ¼
- âœ… æ‰¿èª â†’ å®Ÿè¡Œã®å®Œå…¨ãƒ•ãƒ­ãƒ¼
- âœ… Auto-Approveï¼ˆScope + TTL + Excludeï¼‰
- âœ… MCP Chrome æ“ä½œ

Phase 3-4 ã¯å“è³ªæ”¹å–„ãªã®ã§ã€å¾Œå›ã—ã§ã‚‚å¯ã€‚

### Q4: å®Ÿè£…æœŸé–“ã¯ï¼Ÿ

**A**:
- Phase 1ï¼ˆCritical Fixesï¼‰: 2é€±é–“
- Phase 2ï¼ˆAuto-Approveï¼‰: 2é€±é–“
- Phase 3ï¼ˆAgent Loopåˆ†è§£ï¼‰: 4é€±é–“
- Phase 4ï¼ˆConfig/Infraï¼‰: 2é€±é–“

**åˆè¨ˆ: 10é€±é–“**ï¼ˆå‰å›12é€±é–“ã‹ã‚‰çŸ­ç¸®ï¼‰

### Q5: v1.0ï¼ˆå‰å›ææ¡ˆï¼‰ã¨ã®é•ã„ã¯ï¼Ÿ

**A**:

| é …ç›® | v1.0 | v2.0 |
|------|------|------|
| **è¨­è¨ˆæ€æƒ³** | ç†æƒ³çš„Clean Architecture | å®Ÿè·µçš„Hexagonal + Event Sourcing |
| **å„ªå…ˆé †ä½** | ãƒ•ãƒ«å®Ÿè£…ï¼ˆ12é€±é–“ï¼‰ | æœªå®Œæˆæ©Ÿèƒ½å„ªå…ˆï¼ˆ10é€±é–“ï¼‰|
| **Event Store** | ãªã— | ã‚ã‚Šï¼ˆæ‰¿èªãƒ•ãƒ­ãƒ¼æ°¸ç¶šåŒ–ï¼‰|
| **Auto-Approve** | æ¦‚å¿µã®ã¿ | å®Œå…¨å®Ÿè£…è¨ˆç”» |
| **Agent Loop** | å…¨é¢æ›¸ãæ›ãˆ | æ®µéšçš„åˆ†è§£ |
| **æ—¢å­˜ã‚³ãƒ¼ãƒ‰** | ç½®ãæ›ãˆ | æ´»ç”¨ + æ”¹å–„ |

v2.0 ã¯ **å®Ÿç”¨ä¸»ç¾©**: å®Œç’§ã‚ˆã‚Šå‹•ãã‚‚ã®ã‚’å„ªå…ˆã€‚

---

## ã¾ã¨ã‚

### âœ… ä¸»è¦ãªæ”¹å–„ç‚¹

1. **æœªå®Ÿè£…æ©Ÿèƒ½ã®å®Œæˆ**: Workerå®Ÿè¡Œã€Auto-Approveã€MCPçµ±åˆ
2. **Event Sourcing**: æ‰¿èªãƒ•ãƒ­ãƒ¼ã®æ°¸ç¶šåŒ–ã¨ç›£æŸ»ãƒ­ã‚°
3. **Agent Loop åˆ†è§£**: 1,980è¡Œ â†’ 5ã‚µãƒ¼ãƒ“ã‚¹
4. **å®Ÿç”¨ä¸»ç¾©**: æ—¢å­˜ã®è‰¯ã„ã‚³ãƒ¼ãƒ‰ã‚’æ´»ã‹ã™
5. **æ®µéšçš„ç§»è¡Œ**: Phase 1-2 ã§æœ€ä½é™å‹•ã

### â±ï¸ å®Ÿè£…æœŸé–“

**10é€±é–“**ï¼ˆv1.0 ã‹ã‚‰ 2é€±é–“çŸ­ç¸®ï¼‰
- Phase 1: 2é€±é–“ï¼ˆCritical Fixesï¼‰
- Phase 2: 2é€±é–“ï¼ˆAuto-Approveï¼‰
- Phase 3: 4é€±é–“ï¼ˆAgent Loopåˆ†è§£ï¼‰
- Phase 4: 2é€±é–“ï¼ˆConfig/Infraï¼‰

### ğŸ¯ æœŸå¾…åŠ¹æœ

- **å®Œå…¨æ€§**: æ‰¿èªãƒ•ãƒ­ãƒ¼100%ã€Auto-Approve100%ã€MCPçµ±åˆ100%
- **ä¿å®ˆæ€§**: Agent Loopåˆ†è§£ã«ã‚ˆã‚Šå¤‰æ›´å®¹æ˜“
- **ç›£æŸ»æ€§**: Event Store ã§æ‰¿èªå±¥æ­´è¿½è·¡
- **ä¿¡é ¼æ€§**: å†èµ·å‹•å¾Œã‚‚æ‰¿èªçŠ¶æ…‹å¾©å…ƒ

### ğŸš€ æ¨å¥¨åˆ¤æ–­

**Yes, recommended:**
- âœ… æœªå®Ÿè£…æ©Ÿèƒ½ã‚’å®Œæˆã•ã›ãŸã„ â†’ Phase 1-2 å¿…é ˆ
- âœ… ä¿å®ˆæ€§ã‚’å‘ä¸Šã•ã›ãŸã„ â†’ Phase 3-4 æ¨å¥¨
- âœ… æ®µéšçš„ã«é€²ã‚ãŸã„ â†’ Phase åˆ¥ã«å®Ÿè£…å¯èƒ½

**æ¨å¥¨**: Phase 1 ã‹ã‚‰é–‹å§‹ã—ã€å‹•ä½œç¢ºèªã—ãªãŒã‚‰ Phase 2-4 ã¸é€²ã‚€

---

**ä½œæˆæ—¥**: 2026-03-01
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0
**å‰å›ã¨ã®å·®åˆ†**: Event Sourcingè¿½åŠ ã€æœªå®Ÿè£…æ©Ÿèƒ½å„ªå…ˆã€å®Ÿç”¨ä¸»ç¾©
**æ¬¡å›ãƒ¬ãƒ“ãƒ¥ãƒ¼**: Phase 1 å®Œäº†æ™‚ï¼ˆWeek 2ï¼‰
