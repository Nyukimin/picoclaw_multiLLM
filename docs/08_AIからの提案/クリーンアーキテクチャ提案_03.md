# PicoClaw çµ±åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ v3.0

**ä½œæˆæ—¥**: 2026-03-01
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 3.0ï¼ˆv1.0 + v2.0 çµ±åˆç‰ˆï¼‰
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: æœ€çµ‚ææ¡ˆ
**å‰æ**: ä»•æ§˜æ›¸å®Œå…¨æº–æ‹  + Clean Architecture + Event Sourcing

---

## ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒª

### çµ±åˆã®ç›®çš„

**v1.0ï¼ˆç†æƒ³ï¼‰+ v2.0ï¼ˆå®Ÿç”¨ï¼‰+ ä»•æ§˜æ›¸ï¼ˆè¦ä»¶ï¼‰= v3.0ï¼ˆæœ€é©è§£ï¼‰**

- **v1.0ã®é•·æ‰€**: å®Œç’§ãªå±¤åˆ†é›¢ã€DDDã€è±Šå¯Œãªã‚³ãƒ¼ãƒ‰ä¾‹ã€Wire DI
- **v2.0ã®é•·æ‰€**: Event Sourcingã€æœªå®Œæˆæ©Ÿèƒ½ã®å„ªå…ˆã€æ®µéšçš„ç§»è¡Œ
- **ä»•æ§˜æ›¸ã®è¦ä»¶**: Chat/Worker/Coderå½¹å‰²ã€LINEå…¥å£å›ºå®šã€æ‰¿èªãƒ•ãƒ­ãƒ¼

v3.0 ã¯3ã¤ã‚’çµ±åˆã—ã€**ä»•æ§˜æº–æ‹  + å®Ÿè£…å¯èƒ½ + ä¿å®ˆæ€§**ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

### ä¸»è¦è¨­è¨ˆæ±ºå®š

| è¨­è¨ˆè¦ç´  | v1.0 | v2.0 | v3.0ï¼ˆçµ±åˆï¼‰ |
|---------|------|------|-------------|
| **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£** | Clean Architecture | Hexagonal + Event Sourcing | **ä¸¡æ–¹æ¡ç”¨**ï¼ˆClean + Event Sourcingï¼‰ |
| **Agent Loop** | å…¨é¢æ›¸ãæ›ãˆ | æ®µéšçš„åˆ†è§£ | **æ®µéšçš„åˆ†è§£ + Cleanå±¤æ§‹é€ ** |
| **æ‰¿èªãƒ•ãƒ­ãƒ¼** | Domainå±¤ã§è¨­è¨ˆ | Event Storeæ°¸ç¶šåŒ– | **Domain + Event Storeä¸¡ç«‹** |
| **ä»•æ§˜æº–æ‹ ** | æŠ½è±¡çš„ | å…·ä½“çš„å•é¡Œè§£æ±º | **å®Œå…¨æº–æ‹ ï¼ˆLINEå›ºå®šã€Mioå§”è­²ï¼‰** |
| **å®Ÿè£…æœŸé–“** | 12é€±é–“ | 10é€±é–“ | **8é€±é–“**ï¼ˆå„ªå…ˆé †ä½ã®æœ€é©åŒ–ï¼‰ |

### æœŸå¾…åŠ¹æœ

âœ… **å®Œå…¨æ€§**: ä»•æ§˜100%æº–æ‹ ï¼ˆChat/Worker/Coderã€æ‰¿èªãƒ•ãƒ­ãƒ¼ã€Auto-Approveï¼‰
âœ… **ä¿å®ˆæ€§**: Clean Architecture ã«ã‚ˆã‚‹å¤‰æ›´å½±éŸ¿ã®å±€æ‰€åŒ–
âœ… **ç›£æŸ»æ€§**: Event Sourcing ã«ã‚ˆã‚‹æ‰¿èªå±¥æ­´ã®å®Œå…¨è¿½è·¡
âœ… **æ‹¡å¼µæ€§**: æ–°Agent/Provider/Route ã®è¿½åŠ ãŒæ•°åè¡Œã§å¯èƒ½
âœ… **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: å„å±¤ç‹¬ç«‹ã€ãƒ¢ãƒƒã‚¯ãƒ»ã‚¹ã‚¿ãƒ–ãŒå®¹æ˜“ï¼ˆã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™: Domain 90%ï¼‰

---

## è¨­è¨ˆåŸå‰‡ï¼ˆv1.0 + v2.0 çµ±åˆï¼‰

### 1. Clean Architectureï¼ˆv1.0 ç¶™æ‰¿ï¼‰

```
å¤–å±¤ï¼ˆAdapter/Infrastructureï¼‰â†’ å†…å±¤ï¼ˆApplicationï¼‰â†’ æ ¸ï¼ˆDomainï¼‰
```

**é‡è¦ãƒ«ãƒ¼ãƒ«**:
- Domain å±¤ã¯å¤–éƒ¨ã«ä¾å­˜ã—ãªã„ï¼ˆä¾å­˜æ€§é€†è»¢ï¼‰
- Application å±¤ã¯ Domain ã®ã¿ã«ä¾å­˜
- Adapter/Infrastructure å±¤ã¯ Application/Domain ã«ä¾å­˜å¯

### 2. Event Sourcing + CQRSï¼ˆv2.0 ç¶™æ‰¿ï¼‰

- æ‰¿èªãƒ•ãƒ­ãƒ¼ã‚’ Event Store ã§æ°¸ç¶šåŒ–
- Read Modelï¼ˆjobs ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã‚’ CQRS ã§è‡ªå‹•æ›´æ–°
- ç›£æŸ»ãƒ­ã‚°ã¨ãƒªã‚«ãƒãƒªã‚’å®Ÿç¾

### 3. DDDï¼ˆv1.0 ç¶™æ‰¿ï¼‰

- **ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£**: Agent, Session, ApprovalFlow
- **å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ**: Task, JobID, Proposal, RoutingDecision
- **ã‚¢ã‚°ãƒªã‚²ãƒ¼ãƒˆ**: ApprovalFlowï¼ˆJobID + Proposal + Policy + Status ã‚’ä¸€è²«ç®¡ç†ï¼‰
- **ãƒªãƒã‚¸ãƒˆãƒª**: Domain å±¤ã§ interface å®šç¾©ã€Infrastructure å±¤ã§å®Ÿè£…

### 4. å®Ÿç”¨ä¸»ç¾©ï¼ˆv2.0 ç¶™æ‰¿ï¼‰

- å®Œç’§ã‚ˆã‚Šå‹•ãã‚‚ã®ã‚’å„ªå…ˆ
- æ®µéšçš„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
- æ—¢å­˜ã®è‰¯ã„ã‚³ãƒ¼ãƒ‰ï¼ˆProvideræŠ½è±¡åŒ–ã€SessionManagerã€Routerï¼‰ã¯æ´»ç”¨

### 5. ä»•æ§˜æ›¸æº–æ‹ ï¼ˆæ–°è¦è¿½åŠ ï¼‰

**æœ€å„ªå…ˆ**: `docs/01_æ­£æœ¬ä»•æ§˜/ä»•æ§˜.md` ã®å…¨è¦ä»¶ã‚’æº€ãŸã™

- **LINEå…¥å£**: CHATï¼ˆMioï¼‰å›ºå®š
- **å§”è­²åˆ¤æ–­**: å‰æ®µRouterã§ã¯ãªãã€MioãŒä¼šè©±ä¸­ã«åˆ¤æ–­
- **å½¹å‰²å›ºå®š**: Chat/Worker/Coderï¼ˆæ„›ç§°ãƒ»å®Ÿä½“LLMã¯è¨­å®šã§å·®ã—æ›¿ãˆï¼‰
- **æ‰¿èªãƒ•ãƒ­ãƒ¼**: Coder ã¯ plan/patch ç”Ÿæˆã€Worker ãŒå®Ÿè¡Œ
- **Auto-Approve**: Scope/TTL/Exclude Flags

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å›³ï¼ˆv3.0 çµ±åˆç‰ˆï¼‰

### ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹æˆ

```mermaid
graph TB
    subgraph "Adapter Layer (å¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹)"
        LINE[LINE Webhook]
        Slack[Slack Handler]
        CLI[CLI Handler]
        Notif[Notification Sender]
    end

    subgraph "Application Layer (Use Cases + Orchestration)"
        ProcessMsg[ProcessUserMessage UseCase]
        Orchestrator[MessageOrchestrator]
        ApprovalUC[ManageApproval UseCase]
        HeartbeatSvc[HeartbeatService]
    end

    subgraph "Domain Layer (Pure Business Logic)"
        MioAgent[Mio Agent Entity<br/>â€»Chatå½¹å‰²]
        ShiroAgent[Shiro Agent Entity<br/>â€»Workerå½¹å‰²]
        CoderAgents[Coder Agents<br/>â€»Aka/Ao/Gin]
        Task[Task VO]
        Proposal[Proposal VO]
        ApprovalFlow[ApprovalFlow Aggregate]
        AutoApprovePolicy[AutoApprove Policy]
        Events[Domain Events]
    end

    subgraph "Infrastructure Layer (External Implementation)"
        EventStore[(Event Store<br/>SQLite)]
        Ollama[Ollama Provider<br/>â€»Chat/Worker]
        Claude[Claude Provider<br/>â€»Coder3]
        DeepSeek[DeepSeek Provider<br/>â€»Coder1]
        OpenAI[OpenAI Provider<br/>â€»Coder2]
        SessionRepo[Session Repository]
        JobRepo[Job Repository]
        EventBus[Event Bus]
    end

    LINE --> ProcessMsg
    Slack --> ProcessMsg
    CLI --> ProcessMsg

    ProcessMsg --> Orchestrator
    Orchestrator --> MioAgent
    MioAgent -.å§”è­²åˆ¤æ–­.-> ShiroAgent
    MioAgent -.å§”è­²åˆ¤æ–­.-> CoderAgents
    CoderAgents --> Proposal
    Orchestrator --> ApprovalUC
    ApprovalUC --> ApprovalFlow
    ApprovalFlow --> AutoApprovePolicy
    ApprovalFlow -.publish.-> Events
    Events --> EventStore
    EventStore --> JobRepo

    MioAgent -.ä¾å­˜æ€§é€†è»¢.-> Ollama
    ShiroAgent -.ä¾å­˜æ€§é€†è»¢.-> Ollama
    CoderAgents -.ä¾å­˜æ€§é€†è»¢.-> Claude
    CoderAgents -.ä¾å­˜æ€§é€†è»¢.-> DeepSeek
    CoderAgents -.ä¾å­˜æ€§é€†è»¢.-> OpenAI

    Orchestrator --> SessionRepo
    Orchestrator --> HeartbeatSvc
    ApprovalUC --> Notif
```

### ä»•æ§˜æº–æ‹ ã®è¨­è¨ˆãƒã‚¤ãƒ³ãƒˆ

#### 1. LINEå…¥å£å›ºå®š â†’ CHATï¼ˆMioï¼‰

```go
// internal/adapter/inbound/line/handler.go
func (h *Handler) HandleWebhook(w http.ResponseWriter, r *http.Request) {
    // ä»•æ§˜: LINEå…¥å£ã¯CHATï¼ˆMioï¼‰å›ºå®š
    output, err := h.useCase.Execute(ctx, usecase.Input{
        Message:    message.Text,
        Channel:    "line",
        ForcedRoute: routing.RouteCHAT, // â† LINEå…¥å£ã¯CHATå›ºå®š
        SessionKey: event.Source.UserID,
    })
}
```

#### 2. MioãŒä¼šè©±ä¸­ã«å§”è­²åˆ¤æ–­

```go
// internal/domain/agent/mio.go (Chat Agent)
func (m *MioAgent) ProcessMessage(ctx context.Context, task Task) (Result, error) {
    // 1. ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°åˆ¤æ–­ï¼ˆå‰æ®µRouterã§ã¯ãªãã€Mioè‡ªèº«ãŒåˆ¤æ–­ï¼‰
    decision := m.decideAction(task)

    switch decision.Action {
    case ActionDirectResponse:
        // ç›´æ¥å¿œç­”
        return m.chat(ctx, task)

    case ActionDelegateWorker:
        // Workerå§”è­²
        return m.delegateToWorker(ctx, task, decision.DelegateRoute)

    case ActionDelegateCoder:
        // Coderå§”è­²ï¼ˆæ‰¿èªãƒ•ãƒ­ãƒ¼ä»˜ãï¼‰
        return m.delegateToCoder(ctx, task, decision.DelegateRoute)
    }
}

// Mioã®å§”è­²åˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯
func (m *MioAgent) decideAction(task Task) DelegationDecision {
    // ä»•æ§˜: MioãŒä¼šè©±ä¸­ã«ã€Œç›´ç­”/å§”è­²ã€ã‚’é¸ã¶
    // - æ˜ç¤ºã‚³ãƒãƒ³ãƒ‰ï¼ˆ/code, /analyze, /planç­‰ï¼‰ã‚’å„ªå…ˆ
    // - ãƒ«ãƒ¼ãƒ«è¾æ›¸ã§ãƒãƒƒãƒãƒ³ã‚°
    // - å¿…è¦ãªã‚‰åˆ†é¡å™¨ï¼ˆWorkerï¼‰ã«èã
    // - å®‰å…¨å´ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆCHATï¼‰
}
```

#### 3. Chat/Worker/Coder å½¹å‰²å›ºå®š

```go
// internal/domain/agent/role.go
type Role int

const (
    RoleChat   Role = iota // Mioï¼ˆä¼šè©±LLMã€æœ€çµ‚å¿œç­”ï¼‰
    RoleWorker             // Shiroï¼ˆæ¨è«–ãƒ»åˆ†æãƒ»æ¤œè¨¼ï¼‰
    RoleCoder1             // Akaï¼ˆä»•æ§˜è¨­è¨ˆï¼‰
    RoleCoder2             // Aoï¼ˆå®Ÿè£…ï¼‰
    RoleCoder3             // Ginï¼ˆé«˜å“è³ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°/Claudeï¼‰
)

// ä»•æ§˜: å½¹å‰²åã¯å›ºå®šã€æ„›ç§°ã¨å®Ÿä½“LLMã¯è¨­å®šã§å·®ã—æ›¿ãˆ
type Agent struct {
    id       AgentID
    role     Role        // å›ºå®šï¼ˆChat/Worker/Coder1/2/3ï¼‰
    alias    string      // å·®ã—æ›¿ãˆå¯ï¼ˆMio/Shiro/Aka/Ao/Ginï¼‰
    provider LLMProvider // å·®ã—æ›¿ãˆå¯ï¼ˆOllama/Claude/OpenAI/DeepSeekï¼‰
}
```

---

## ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹é€ ï¼ˆv3.0 æœ€é©åŒ–ç‰ˆï¼‰

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼

```
picoclaw_multiLLM/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ picoclaw/
â”‚       â”œâ”€â”€ main.go              # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚       â””â”€â”€ wire.go              # ä¾å­˜æ€§æ³¨å…¥ï¼ˆWireï¼‰
â”‚
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ domain/                  # ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ï¼ˆç´”ç²‹ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
â”‚   â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”‚   â”œâ”€â”€ agent.go        # Agent ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆåŸºåº•ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ mio.go          # Mioï¼ˆChatï¼‰å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯ â€»æ–°è¦
â”‚   â”‚   â”‚   â”œâ”€â”€ shiro.go        # Shiroï¼ˆWorkerï¼‰å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯ â€»æ–°è¦
â”‚   â”‚   â”‚   â”œâ”€â”€ coder.go        # Coderï¼ˆAka/Ao/Ginï¼‰å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯ â€»æ–°è¦
â”‚   â”‚   â”‚   â”œâ”€â”€ role.go         # Role enum
â”‚   â”‚   â”‚   â”œâ”€â”€ delegation.go   # å§”è­²åˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ â€»æ–°è¦
â”‚   â”‚   â”‚   â””â”€â”€ events.go       # Domain Events
â”‚   â”‚   â”œâ”€â”€ task/
â”‚   â”‚   â”‚   â”œâ”€â”€ task.go         # Task å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”‚   â””â”€â”€ job_id.go       # JobID å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”œâ”€â”€ proposal/
â”‚   â”‚   â”‚   â””â”€â”€ proposal.go     # Proposal å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”œâ”€â”€ approval/
â”‚   â”‚   â”‚   â”œâ”€â”€ flow.go         # ApprovalFlow ã‚¢ã‚°ãƒªã‚²ãƒ¼ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ auto_approve.go # AutoApprove Policy â€»v2.0
â”‚   â”‚   â”‚   â”œâ”€â”€ scope.go        # Scope VO â€»v2.0
â”‚   â”‚   â”‚   â””â”€â”€ events.go       # Approval Events â€»v2.0
â”‚   â”‚   â”œâ”€â”€ routing/
â”‚   â”‚   â”‚   â”œâ”€â”€ decision.go     # RoutingDecision
â”‚   â”‚   â”‚   â”œâ”€â”€ route.go        # Route enum
â”‚   â”‚   â”‚   â””â”€â”€ classifier.go   # Classifier interface
â”‚   â”‚   â””â”€â”€ session/
â”‚   â”‚       â”œâ”€â”€ session.go      # Session ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
â”‚   â”‚       â””â”€â”€ repository.go   # Repository interface
â”‚   â”‚
â”‚   â”œâ”€â”€ application/             # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤
â”‚   â”‚   â”œâ”€â”€ usecase/
â”‚   â”‚   â”‚   â”œâ”€â”€ process_message.go    # ProcessUserMessage
â”‚   â”‚   â”‚   â””â”€â”€ manage_approval.go    # ManageApproval
â”‚   â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”‚   â”œâ”€â”€ message_orchestrator.go   # â€»Agent Loopåˆ†è§£
â”‚   â”‚   â”‚   â”œâ”€â”€ routing_service.go        # â€»Agent Loopåˆ†è§£
â”‚   â”‚   â”‚   â”œâ”€â”€ approval_service.go       # â€»Auto-Approveè¿½åŠ 
â”‚   â”‚   â”‚   â”œâ”€â”€ worker_execution_service.go # â€»v2.0ï¼ˆWorkerå®Ÿè¡Œï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ heartbeat_service.go      # â€»v1.0
â”‚   â”‚   â”‚   â””â”€â”€ event_handlers.go
â”‚   â”‚   â””â”€â”€ port/
â”‚   â”‚       â”œâ”€â”€ inbound.go
â”‚   â”‚       â””â”€â”€ outbound.go
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/          # ã‚¤ãƒ³ãƒ•ãƒ©å±¤
â”‚   â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”‚   â”œâ”€â”€ ollama/         # æ—¢å­˜æ´»ç”¨ï¼ˆChat/Workerï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ claude/         # æ—¢å­˜æ´»ç”¨ï¼ˆCoder3ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ openai/         # æ—¢å­˜æ´»ç”¨ï¼ˆCoder2ï¼‰
â”‚   â”‚   â”‚   â””â”€â”€ deepseek/       # æ—¢å­˜æ´»ç”¨ï¼ˆCoder1ï¼‰
â”‚   â”‚   â”œâ”€â”€ persistence/
â”‚   â”‚   â”‚   â”œâ”€â”€ eventstore/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ sqlite_store.go       # â€»v2.0ï¼ˆEvent Storeï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ session/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ json_repo.go          # æ—¢å­˜æ´»ç”¨
â”‚   â”‚   â”‚   â””â”€â”€ job/
â”‚   â”‚   â”‚       â””â”€â”€ sqlite_repo.go        # â€»v2.0ï¼ˆJobæ°¸ç¶šåŒ–ï¼‰
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â””â”€â”€ loader.go                 # â€»v2.0ï¼ˆLayered Configï¼‰
â”‚   â”‚   â””â”€â”€ mcp/
â”‚   â”‚       â””â”€â”€ client.go                 # æ—¢å­˜æ´»ç”¨
â”‚   â”‚
â”‚   â””â”€â”€ adapter/                 # ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼å±¤
â”‚       â”œâ”€â”€ inbound/
â”‚       â”‚   â”œâ”€â”€ line/           # â€»LINEå…¥å£CHATå›ºå®š
â”‚       â”‚   â”œâ”€â”€ slack/
â”‚       â”‚   â””â”€â”€ cli/
â”‚       â””â”€â”€ outbound/
â”‚           â””â”€â”€ notification/
â”‚               â””â”€â”€ sender.go
â”‚
â”œâ”€â”€ pkg/                         # å…¬é–‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
â”‚   â”œâ”€â”€ event/
â”‚   â”‚   â””â”€â”€ bus.go              # Event Bus â€»v1.0
â”‚   â””â”€â”€ logger/
â”‚       â”œâ”€â”€ logger.go
â”‚       â””â”€â”€ masking.go          # â€»v2.0ï¼ˆAPI Key Maskingï¼‰
â”‚
â”œâ”€â”€ db/                          # â€»v2.0ï¼ˆDatabase Migrationsï¼‰
â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ 001_create_events_table.sql
â”‚   â”‚   â”œâ”€â”€ 002_create_jobs_table.sql
â”‚   â”‚   â””â”€â”€ 003_create_auto_approve_policies_table.sql
â”‚   â””â”€â”€ schema.sql
â”‚
â”œâ”€â”€ test/                        # â€»v1.0ï¼ˆE2E ãƒ†ã‚¹ãƒˆï¼‰
â”‚   â””â”€â”€ e2e/
â”‚       â”œâ”€â”€ basic_flow_test.go
â”‚       â”œâ”€â”€ code3_approval_test.go
â”‚       â””â”€â”€ auto_approve_test.go
â”‚
â””â”€â”€ config/
    â”œâ”€â”€ config.yaml
    â””â”€â”€ config.example.yaml
```

---

## é‡è¦ãªè¨­è¨ˆæ±ºå®šï¼ˆv3.0 çµ±åˆç‰ˆï¼‰

### 1. Mioï¼ˆChat Agentï¼‰ã®å§”è­²åˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯

**ä»•æ§˜è¦ä»¶**: å‰æ®µRouterã§ã¯ãªãã€MioãŒä¼šè©±ä¸­ã«å§”è­²åˆ¤æ–­

```go
// internal/domain/agent/mio.go
package agent

import (
    "context"
    "github.com/Nyukimin/picoclaw_multiLLM/internal/domain/routing"
    "github.com/Nyukimin/picoclaw_multiLLM/internal/domain/task"
)

// MioAgent ã¯ Chat å½¹å‰²ï¼ˆæœ€çµ‚å¿œç­”ã‚’ç”Ÿæˆï¼‰
type MioAgent struct {
    Agent                           // åŸºåº•ã‚¯ãƒ©ã‚¹
    routingService *routing.Service // å§”è­²åˆ¤æ–­ã‚µãƒ¼ãƒ“ã‚¹
}

// DelegationDecision ã¯å§”è­²åˆ¤æ–­ã®çµæœ
type DelegationDecision struct {
    Action        DelegationAction
    DelegateRoute routing.Route // Worker/Coder ã¸ã®å§”è­²å…ˆ
    Reason        string
}

type DelegationAction int

const (
    ActionDirectResponse DelegationAction = iota // ç›´æ¥å¿œç­”
    ActionDelegateWorker                         // Workerå§”è­²
    ActionDelegateCoder                          // Coderå§”è­²ï¼ˆæ‰¿èªãƒ•ãƒ­ãƒ¼ä»˜ãï¼‰
)

// ProcessMessage ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ï¼ˆä»•æ§˜æº–æ‹ ã®å§”è­²åˆ¤æ–­ï¼‰
func (m *MioAgent) ProcessMessage(ctx context.Context, t task.Task) (Result, error) {
    // 1. å§”è­²åˆ¤æ–­ï¼ˆä»•æ§˜: MioãŒä¼šè©±ä¸­ã«åˆ¤æ–­ï¼‰
    decision := m.decideAction(ctx, t)

    // 2. Domain Event ç™ºè¡Œ
    publishEvent(TaskStarted{
        TaskID:    t.JobID(),
        AgentID:   m.id,
        Decision:  decision,
        Timestamp: time.Now(),
    })

    // 3. Action ã«å¿œã˜ã¦å‡¦ç†
    switch decision.Action {
    case ActionDirectResponse:
        // ç›´æ¥å¿œç­”ï¼ˆChat LLMã§å›ç­”ï¼‰
        return m.chat(ctx, t)

    case ActionDelegateWorker:
        // Workerå§”è­²ï¼ˆæ‰¿èªãªã—ã€å³å®Ÿè¡Œï¼‰
        return m.delegateToWorker(ctx, t, decision.DelegateRoute)

    case ActionDelegateCoder:
        // Coderå§”è­²ï¼ˆæ‰¿èªãƒ•ãƒ­ãƒ¼ä»˜ãï¼‰
        return m.delegateToCoder(ctx, t, decision.DelegateRoute)
    }

    return Result{}, nil
}

// decideAction ã¯å§”è­²åˆ¤æ–­ï¼ˆä»•æ§˜ã®å„ªå…ˆé †ä½ã«å¾“ã†ï¼‰
func (m *MioAgent) decideAction(ctx context.Context, t task.Task) DelegationDecision {
    // å„ªå…ˆé †ä½ï¼ˆä»•æ§˜æº–æ‹ ï¼‰:
    // 1. æ˜ç¤ºã‚³ãƒãƒ³ãƒ‰
    // 2. ãƒ«ãƒ¼ãƒ«è¾æ›¸ï¼ˆå¼·è¨¼æ‹ ï¼‰
    // 3. åˆ†é¡å™¨ï¼ˆæ¨è«–LLMï¼‰ã‚’1å›ã ã‘
    // 4. å®‰å…¨å´ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆCHATï¼‰

    // 1. æ˜ç¤ºã‚³ãƒãƒ³ãƒ‰ãƒã‚§ãƒƒã‚¯
    if cmd := parseExplicitCommand(t.UserMessage()); cmd != "" {
        return m.decisionFromCommand(cmd)
    }

    // 2. ãƒ«ãƒ¼ãƒ«è¾æ›¸ãƒã‚§ãƒƒã‚¯
    if route := m.routingService.MatchRuleDictionary(t); route != routing.RouteUnknown {
        return m.decisionFromRoute(route, "rule_dictionary")
    }

    // 3. åˆ†é¡å™¨ï¼ˆWorkerå§”è­²ã—ã¦åˆ¤æ–­ã‚’èãï¼‰
    decision, err := m.routingService.ClassifyWithWorker(ctx, t)
    if err == nil && decision.Confidence >= threshold {
        return m.decisionFromRoute(decision.Route, "classifier")
    }

    // 4. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆCHAT = ç›´æ¥å¿œç­”ï¼‰
    return DelegationDecision{
        Action: ActionDirectResponse,
        Reason: "fallback_to_chat",
    }
}

// delegateToWorker ã¯ Worker ã¸ã®å§”è­²ï¼ˆæ‰¿èªãªã—ï¼‰
func (m *MioAgent) delegateToWorker(ctx context.Context, t task.Task, route routing.Route) (Result, error) {
    // Shiroï¼ˆWorkerï¼‰ã«å§”è­²
    workerAgent := m.getWorkerAgent() // DI ã§æ³¨å…¥
    workerResult, err := workerAgent.ProcessTask(ctx, t.WithRoute(route))
    if err != nil {
        return Result{}, err
    }

    // MioãŒæœ€çµ‚æ•´å½¢ï¼ˆä»•æ§˜: æœ€çµ‚å¿œç­”ã¯å¿…ãšä¼šè©±LLMãŒç”Ÿæˆï¼‰
    return m.finalizeResponse(ctx, workerResult)
}

// delegateToCoder ã¯ Coder ã¸ã®å§”è­²ï¼ˆæ‰¿èªãƒ•ãƒ­ãƒ¼ä»˜ãï¼‰
func (m *MioAgent) delegateToCoder(ctx context.Context, t task.Task, route routing.Route) (Result, error) {
    // Coderï¼ˆAka/Ao/Ginï¼‰ã«å§”è­²
    coderAgent := m.getCoderAgent(route) // DI ã§æ³¨å…¥
    proposal, err := coderAgent.GenerateProposal(ctx, t)
    if err != nil {
        return Result{}, err
    }

    // æ‰¿èªãƒ•ãƒ­ãƒ¼ï¼ˆApprovalService çµŒç”±ï¼‰
    // â€»å¾Œè¿°ã® ApprovalFlow ã§å‡¦ç†

    return Result{}, nil
}
```

### 2. ApprovalFlowï¼ˆv1.0 DDD + v2.0 Event Sourcingï¼‰

```go
// internal/domain/approval/flow.go
package approval

import (
    "time"
    "github.com/Nyukimin/picoclaw_multiLLM/internal/domain/task"
    "github.com/Nyukimin/picoclaw_multiLLM/internal/domain/proposal"
)

// ApprovalFlow ã¯æ‰¿èªãƒ•ãƒ­ãƒ¼ã®ã‚¢ã‚°ãƒªã‚²ãƒ¼ãƒˆãƒ«ãƒ¼ãƒˆï¼ˆv1.0 DDDï¼‰
// Event Sourcing ã§æ°¸ç¶šåŒ–ï¼ˆv2.0ï¼‰
type ApprovalFlow struct {
    jobID     task.JobID
    proposal  proposal.Proposal
    policy    Policy        // Manual or Auto
    status    Status        // Pending, Granted, Denied
    scope     Scope         // Auto-Approve scopeï¼ˆPolicy=Auto ã®å ´åˆã®ã¿ï¼‰
    expiresAt time.Time     // Auto-Approve æœ‰åŠ¹æœŸé™
    grantedBy string
    grantedAt time.Time
}

// NewFlow ã¯æ–°ã—ã„æ‰¿èªãƒ•ãƒ­ãƒ¼ã‚’ç”Ÿæˆ
func NewFlow(jobID task.JobID, prop proposal.Proposal, policy Policy) *ApprovalFlow {
    flow := &ApprovalFlow{
        jobID:    jobID,
        proposal: prop,
        policy:   policy,
        status:   StatusPending,
    }

    // Domain Event ç™ºè¡Œï¼ˆv2.0 Event Sourcingï¼‰
    publishEvent(ApprovalRequested{
        JobID:     jobID,
        Plan:      prop.Plan(),
        Patch:     prop.Patch(),
        Risk:      prop.Risk(),
        CostHint:  prop.CostHint(),
        CreatedAt: time.Now(),
        Route:     prop.Route(),
    })

    return flow
}

// Approve ã¯æ‰¿èªã‚’å®Ÿè¡Œ
func (f *ApprovalFlow) Approve(grantedBy string) error {
    if f.status != StatusPending {
        return ErrAlreadyProcessed
    }

    f.status = StatusGranted
    f.grantedBy = grantedBy
    f.grantedAt = time.Now()

    // Domain Event ç™ºè¡Œï¼ˆv2.0ï¼‰
    publishEvent(ApprovalGranted{
        JobID:      f.jobID,
        GrantedBy:  grantedBy,
        GrantedAt:  f.grantedAt,
        ApproverID: grantedBy,
    })

    return nil
}

// IsAutoApprovable ã¯ Auto-Approve å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆv2.0ï¼‰
func (f *ApprovalFlow) IsAutoApprovable(t task.Task) bool {
    if f.policy != PolicyAuto {
        return false
    }

    if time.Now().After(f.expiresAt) {
        return false
    }

    // Scope ãƒãƒƒãƒãƒã‚§ãƒƒã‚¯ï¼ˆv2.0 Scope è¨­è¨ˆï¼‰
    return f.scope.Matches(t)
}

// AutoApprove ã¯è‡ªå‹•æ‰¿èªã‚’å®Ÿè¡Œï¼ˆv2.0ï¼‰
func (f *ApprovalFlow) AutoApprove(policyID int) error {
    if f.policy != PolicyAuto {
        return ErrNotAutoApproveFlow
    }

    if time.Now().After(f.expiresAt) {
        return ErrAutoApproveExpired
    }

    f.status = StatusGranted
    f.grantedBy = fmt.Sprintf("auto:%d", policyID)
    f.grantedAt = time.Now()

    // Domain Event ç™ºè¡Œ
    publishEvent(AutoApprovalGranted{
        JobID:     f.jobID,
        PolicyID:  policyID,
        GrantedAt: f.grantedAt,
        Reason:    "Auto-approved by policy",
    })

    return nil
}
```

### 3. WorkerExecutionServiceï¼ˆv2.0ï¼‰+ Domainå±¤çµ±åˆ

```go
// internal/application/service/worker_execution.go
package service

import (
    "context"
    "github.com/Nyukimin/picoclaw_multiLLM/internal/domain/approval"
    "github.com/Nyukimin/picoclaw_multiLLM/internal/infrastructure/eventstore"
    "github.com/Nyukimin/picoclaw_multiLLM/pkg/tools"
    "github.com/Nyukimin/picoclaw_multiLLM/pkg/mcp"
)

// WorkerExecutionService handles execution of approved proposals
type WorkerExecutionService struct {
    eventStore *eventstore.SQLiteEventStore
    toolRunner *tools.ToolRegistry
    mcpClient  *mcp.Client
    analyzer   *PatchAnalyzer // v2.0 è¿½åŠ 
}

// ExecuteProposal executes an approved proposal
func (w *WorkerExecutionService) ExecuteProposal(ctx context.Context, jobID string) error {
    // 1. Event Store ã‹ã‚‰ã‚¸ãƒ§ãƒ–å–å¾—
    job, err := w.eventStore.GetJob(jobID)
    if err != nil {
        return fmt.Errorf("get job: %w", err)
    }

    if job.Status != "granted" {
        return fmt.Errorf("job %s is not granted", jobID)
    }

    // 2. PatchExecutionStarted Event ç™ºè¡Œ
    w.eventStore.Append(approval.PatchExecutionStarted{
        JobID:     jobID,
        Patch:     ptrToString(job.ProposalPatch),
        StartedAt: time.Now(),
    })

    // 3. Patchè§£æï¼ˆv2.0 PatchAnalyzerï¼‰
    metadata := w.analyzer.Analyze(ptrToString(job.ProposalPatch))

    var result strings.Builder
    var executionError error

    // 4. Chromeæ“ä½œæ¤œå‡ºãƒ»å®Ÿè¡Œï¼ˆMCPï¼‰
    if metadata.UsesBrowser && w.mcpClient != nil {
        chromeCommands := w.detectChromeCommands(ptrToString(job.ProposalPatch))
        for _, cmd := range chromeCommands {
            mcpResult, err := w.mcpClient.CallTool(ctx, cmd.Type, cmd.Args)
            if err != nil {
                executionError = err
                break
            }
            result.WriteString(fmt.Sprintf("Chrome: %s\n", extractText(mcpResult)))
        }
    }

    // 5. ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œå®Ÿè¡Œï¼ˆToolRegistryï¼‰
    if executionError == nil {
        fileOps := w.parseFileOperations(ptrToString(job.ProposalPatch))
        for _, op := range fileOps {
            toolResult := w.toolRunner.Execute(ctx, op.Tool, op.Args)
            if toolResult.IsError {
                executionError = fmt.Errorf("tool failed: %s", toolResult.ForLLM)
                break
            }
            result.WriteString(fmt.Sprintf("Tool %s: OK\n", op.Tool))
        }
    }

    // 6. PatchExecutionCompleted Event ç™ºè¡Œ
    w.eventStore.Append(approval.PatchExecutionCompleted{
        JobID:       jobID,
        Success:     executionError == nil,
        Result:      result.String(),
        ErrorMsg:    errToString(executionError),
        CompletedAt: time.Now(),
    })

    return executionError
}
```

### 4. Wire ã«ã‚ˆã‚‹ä¾å­˜æ€§æ³¨å…¥ï¼ˆv1.0ï¼‰

```go
// cmd/picoclaw/wire.go
//go:build wireinject
// +build wireinject

package main

import (
    "github.com/google/wire"
    // ... imports ...
)

// InitializeApp ã¯ä¾å­˜æ€§ã‚’è§£æ±ºã—ã¦ App ã‚’ç”Ÿæˆï¼ˆv1.0ï¼‰
func InitializeApp(cfg *Config) (*App, error) {
    wire.Build(
        // Infrastructure Layer
        ollama.NewProvider,     // Chat/Worker ç”¨
        claude.NewProvider,     // Coder3 ç”¨
        deepseek.NewProvider,   // Coder1 ç”¨
        openai.NewProvider,     // Coder2 ç”¨
        eventstore.NewSQLiteEventStore, // v2.0 Event Store
        memory.NewSessionRepository,
        event.NewBus,

        // Domain Layer
        provideMioAgent,        // Mioï¼ˆChatï¼‰â€»ä»•æ§˜æº–æ‹ 
        provideShiroAgent,      // Shiroï¼ˆWorkerï¼‰â€»ä»•æ§˜æº–æ‹ 
        provideCoderAgents,     // Aka/Ao/Ginï¼ˆCoderï¼‰â€»ä»•æ§˜æº–æ‹ 
        provideRouter,

        // Application Layer
        service.NewMessageOrchestrator,
        service.NewApprovalService,
        service.NewWorkerExecutionService, // v2.0
        service.NewHeartbeatService,       // v1.0
        usecase.NewProcessUserMessage,

        // Adapter Layer
        line.NewHandler,        // â€»LINEå…¥å£CHATå›ºå®š

        // App
        NewApp,
    )
    return &App{}, nil
}

// provideMioAgent ã¯ Mioï¼ˆChatï¼‰ã‚’ç”Ÿæˆï¼ˆä»•æ§˜æº–æ‹ ï¼‰
func provideMioAgent(ollamaProvider LLMProvider, routingSvc *routing.Service) *agent.MioAgent {
    return agent.NewMioAgent(
        agent.AgentID("mio"),
        agent.RoleChat,
        "Mio",             // æ„›ç§°ï¼ˆè¨­å®šã§å·®ã—æ›¿ãˆå¯ï¼‰
        ollamaProvider,    // å®Ÿä½“LLMï¼ˆè¨­å®šã§å·®ã—æ›¿ãˆå¯ï¼‰
        routingSvc,
    )
}

// provideShiroAgent ã¯ Shiroï¼ˆWorkerï¼‰ã‚’ç”Ÿæˆï¼ˆä»•æ§˜æº–æ‹ ï¼‰
func provideShiroAgent(ollamaProvider LLMProvider) *agent.ShiroAgent {
    return agent.NewShiroAgent(
        agent.AgentID("shiro"),
        agent.RoleWorker,
        "Shiro",
        ollamaProvider,
    )
}

// provideCoderAgents ã¯ Coderï¼ˆAka/Ao/Ginï¼‰ã‚’ç”Ÿæˆï¼ˆä»•æ§˜æº–æ‹ ï¼‰
func provideCoderAgents(
    deepseekProvider LLMProvider,
    openaiProvider LLMProvider,
    claudeProvider LLMProvider,
) []*agent.CoderAgent {
    return []*agent.CoderAgent{
        agent.NewCoderAgent(agent.AgentID("aka"), agent.RoleCoder1, "Aka", deepseekProvider),
        agent.NewCoderAgent(agent.AgentID("ao"),  agent.RoleCoder2, "Ao",  openaiProvider),
        agent.NewCoderAgent(agent.AgentID("gin"), agent.RoleCoder3, "Gin", claudeProvider),
    }
}
```

---

## ç§»è¡Œæˆ¦ç•¥ï¼ˆv3.0 æœ€é©åŒ–ç‰ˆï¼‰

### å®Ÿè£…æœŸé–“: 8é€±é–“ï¼ˆv1.0: 12é€±é–“ã€v2.0: 10é€±é–“ â†’ v3.0: 8é€±é–“ï¼‰

**çŸ­ç¸®ç†ç”±**:
- v1.0 ã®è©³ç´°è¨­è¨ˆã‚’æ´»ç”¨ï¼ˆãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆå‰Šæ¸›ï¼‰
- v2.0 ã®å„ªå…ˆé †ä½ã‚’é©ç”¨ï¼ˆæœªå®Œæˆæ©Ÿèƒ½å„ªå…ˆï¼‰
- æ—¢å­˜ã®è‰¯ã„ã‚³ãƒ¼ãƒ‰ï¼ˆProviderã€SessionManagerï¼‰ã‚’æ´»ç”¨

### Phase 1: Domainå±¤ + Event Storeï¼ˆ2é€±é–“ï¼‰

**Week 1: Domainå±¤å®Ÿè£…**

å®Ÿè£…å¯¾è±¡:
- `internal/domain/agent/` - MioAgent, ShiroAgent, CoderAgentï¼ˆä»•æ§˜æº–æ‹ ï¼‰
- `internal/domain/task/` - Task, JobID
- `internal/domain/proposal/` - Proposal
- `internal/domain/approval/` - ApprovalFlow, AutoApprovePolicy, Scope
- `internal/domain/routing/` - Route, RoutingDecision

æˆæœç‰©:
- ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤å®Œå…¨å®Ÿè£…ï¼ˆv1.0 è¨­è¨ˆ + ä»•æ§˜æº–æ‹ ï¼‰
- ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆï¼ˆã‚«ãƒãƒ¬ãƒƒã‚¸ 90%+ï¼‰

æ¤œè¨¼:
```bash
go test -cover ./internal/domain/...
```

**Week 2: Event Storeå®Ÿè£…**

å®Ÿè£…å¯¾è±¡:
- `internal/infrastructure/eventstore/sqlite_store.go` - Event Store
- `db/migrations/` - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
- `internal/domain/approval/events.go` - Domain Events

æˆæœç‰©:
- Event Store å®Œå…¨å®Ÿè£…ï¼ˆv2.0 è¨­è¨ˆï¼‰
- Read Modelï¼ˆjobs ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰CQRS è‡ªå‹•æ›´æ–°
- çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆDomain + Event Storeï¼‰

æ¤œè¨¼:
```bash
go test ./internal/infrastructure/eventstore/...
```

### Phase 2: Applicationå±¤ + Infrastructureå±¤ï¼ˆ3é€±é–“ï¼‰

**Week 3: Infrastructureå±¤ï¼ˆLLM Providersï¼‰**

å®Ÿè£…å¯¾è±¡:
- `internal/infrastructure/llm/ollama/` - Ollama Providerï¼ˆæ—¢å­˜æ´»ç”¨ï¼‰
- `internal/infrastructure/llm/claude/` - Claude Providerï¼ˆæ—¢å­˜æ´»ç”¨ï¼‰
- `internal/infrastructure/llm/openai/` - OpenAI Providerï¼ˆæ—¢å­˜æ´»ç”¨ï¼‰
- `internal/infrastructure/llm/deepseek/` - DeepSeek Providerï¼ˆæ—¢å­˜æ´»ç”¨ï¼‰

æˆæœç‰©:
- æ—¢å­˜ Provider ã® Clean Architecture é©åˆ
- ä¾å­˜æ€§é€†è»¢ï¼ˆDomainå±¤ã® interface å®Ÿè£…ï¼‰

**Week 4-5: Applicationå±¤ï¼ˆUse Cases + Servicesï¼‰**

å®Ÿè£…å¯¾è±¡:
- `internal/application/usecase/process_message.go`
- `internal/application/service/message_orchestrator.go`
- `internal/application/service/approval_service.go`
- `internal/application/service/worker_execution_service.go` - v2.0
- `internal/application/service/heartbeat_service.go` - v1.0

æˆæœç‰©:
- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤å®Œå…¨å®Ÿè£…
- E2E ãƒ†ã‚¹ãƒˆï¼ˆåŸºæœ¬ãƒ•ãƒ­ãƒ¼ã€CODE3 æ‰¿èªãƒ•ãƒ­ãƒ¼ï¼‰

æ¤œè¨¼:
```bash
go test ./test/e2e/...
```

### Phase 3: Adapterå±¤ + Wire DIï¼ˆ2é€±é–“ï¼‰

**Week 6-7: Adapterå±¤**

å®Ÿè£…å¯¾è±¡:
- `internal/adapter/inbound/line/` - LINE Handlerï¼ˆCHATå›ºå®šï¼‰
- `internal/adapter/inbound/slack/` - Slack Handler
- `internal/adapter/inbound/cli/` - CLI Handler
- `internal/adapter/outbound/notification/` - é€šçŸ¥é€ä¿¡
- `cmd/picoclaw/wire.go` - Wire ã«ã‚ˆã‚‹ DI

æˆæœç‰©:
- ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼å±¤å®Œå…¨å®Ÿè£…
- Wire ã«ã‚ˆã‚‹ä¾å­˜æ€§æ³¨å…¥
- E2E ãƒ†ã‚¹ãƒˆï¼ˆå…¨ã‚·ãƒŠãƒªã‚ªï¼‰

æ¤œè¨¼:
```bash
# Wire ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
cd cmd/picoclaw && go run github.com/google/wire/cmd/wire

# E2E ãƒ†ã‚¹ãƒˆ
go test ./test/e2e/...
```

### Phase 4: æœ¬ç•ªç§»è¡Œï¼ˆ1é€±é–“ï¼‰

**Week 8: ãƒ†ã‚¹ãƒˆç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤ + æœ¬ç•ªç§»è¡Œ**

å®Ÿæ–½å†…å®¹:
1. ãƒ†ã‚¹ãƒˆç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤
2. åŸºæœ¬ãƒ•ãƒ­ãƒ¼ã®å‹•ä½œç¢ºèª
3. CODE3 æ‰¿èªãƒ•ãƒ­ãƒ¼ã®å‹•ä½œç¢ºèª
4. Auto-Approve ãƒ•ãƒ­ãƒ¼ã®å‹•ä½œç¢ºèª
5. æ€§èƒ½ãƒ†ã‚¹ãƒˆï¼ˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ï¼‰
6. æœ¬ç•ªç§»è¡Œï¼ˆæ®µéšçš„ãƒ­ãƒ¼ãƒ«ã‚¢ã‚¦ãƒˆ: 10% â†’ 50% â†’ 100%ï¼‰

æ¤œè¨¼é …ç›®:
- [ ] å…¨E2Eãƒ†ã‚¹ãƒˆæˆåŠŸ
- [ ] ä»•æ§˜100%æº–æ‹ ï¼ˆChat/Worker/Coderã€LINEå›ºå®šã€æ‰¿èªãƒ•ãƒ­ãƒ¼ï¼‰
- [ ] æ€§èƒ½åŠ£åŒ– 10% ä»¥å†…
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ <10MBï¼ˆä»•æ§˜è¦ä»¶ï¼‰
- [ ] Event Store å‹•ä½œç¢ºèªï¼ˆå†èµ·å‹•å¾Œã‚‚æ‰¿èªçŠ¶æ…‹å¾©å…ƒï¼‰

---

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ï¼ˆv1.0 + v2.0 çµ±åˆï¼‰

### ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰

```
          /\
         /E2E\          â† 15% (ä¸»è¦ã‚·ãƒŠãƒªã‚ª + æ‰¿èªãƒ•ãƒ­ãƒ¼ + Auto-Approve)
        /------\
       /Integration\    â† 25% (Event Store + Domain + Infrastructure)
      /------------\
     /  Unit Tests  \   â† 60% (Domainå±¤ + Applicationå±¤)
    /----------------\
```

### é‡è¦ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

#### 1. Mioå§”è­²åˆ¤æ–­ãƒ†ã‚¹ãƒˆï¼ˆä»•æ§˜æº–æ‹ ï¼‰

```go
func TestMioAgent_DecideAction_ExplicitCommand(t *testing.T) {
    // Arrange
    mio := NewMioAgent(...)
    task := task.NewTask("/code ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æ©Ÿèƒ½ã‚’è¿½åŠ ")

    // Act
    decision := mio.decideAction(context.Background(), task)

    // Assert
    assert.Equal(t, ActionDelegateCoder, decision.Action)
    assert.Equal(t, routing.RouteCODE3, decision.DelegateRoute)
}

func TestMioAgent_DecideAction_Fallback(t *testing.T) {
    // Arrange
    mio := NewMioAgent(...)
    task := task.NewTask("ä»Šæ—¥ã®å¤©æ°—ã¯ï¼Ÿ") // åˆ†é¡å™¨ã§ã‚‚åˆ¤å®šä¸èƒ½

    // Act
    decision := mio.decideAction(context.Background(), task)

    // Assert
    assert.Equal(t, ActionDirectResponse, decision.Action) // CHAT ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
}
```

#### 2. ApprovalFlow + Event Sourcing ãƒ†ã‚¹ãƒˆ

```go
func TestApprovalFlow_EventSourcing_Replay(t *testing.T) {
    // Arrange
    store := setupTestEventStore(t)
    jobID := task.NewJobID()

    // Act: ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²
    flow := approval.NewFlow(jobID, proposal, approval.PolicyManual)
    flow.Approve("user123")

    // ã‚¤ãƒ™ãƒ³ãƒˆã‚’ Event Store ã«ä¿å­˜
    events := collectDomainEvents()
    for _, event := range events {
        store.Append(event)
    }

    // Act: Replayï¼ˆå†èµ·å‹•ã‚’æƒ³å®šï¼‰
    replayedFlow, err := store.Replay(jobID.String())

    // Assert
    assert.NoError(t, err)
    assert.Equal(t, approval.StatusGranted, replayedFlow.Status())
    assert.Equal(t, "user123", replayedFlow.GrantedBy())
}
```

#### 3. E2E ãƒ†ã‚¹ãƒˆï¼ˆLINEå…¥å£CHATå›ºå®šï¼‰

```go
func TestE2E_LINE_ChatFixed(t *testing.T) {
    // 1. ãƒ†ã‚¹ãƒˆç”¨Appèµ·å‹•
    app := setupTestApp(t)
    defer app.Shutdown()

    // 2. LINEçµŒç”±ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
    jobID, err := app.SendLINEMessage(context.Background(), "ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦")
    assert.NoError(t, err)

    // 3. ä»•æ§˜ç¢ºèª: LINEå…¥å£ã¯CHATï¼ˆMioï¼‰å›ºå®š
    session := app.GetSession(jobID)
    assert.Equal(t, routing.RouteCHAT, session.InitialRoute)

    // 4. Mioâ†’Coderå§”è­²ã‚’ç¢ºèª
    assert.Eventually(t, func() bool {
        status := app.GetJobStatus(jobID)
        return status.DelegatedTo == "gin" // CODE3 = Ginï¼ˆCoder3ï¼‰
    }, 5*time.Second, 100*time.Millisecond)
}
```

---

## v3.0 ã®å·®åˆ¥åŒ–ãƒã‚¤ãƒ³ãƒˆ

### v1.0 ã¨ã®é•ã„

| é …ç›® | v1.0 | v3.0 |
|------|------|------|
| **ä»•æ§˜æº–æ‹ ** | æŠ½è±¡çš„ï¼ˆChat/Worker/Coderã¯ä¾‹ï¼‰ | **å®Œå…¨æº–æ‹ **ï¼ˆLINEå›ºå®šã€Mioå§”è­²ï¼‰ |
| **Domainå±¤** | AgentåŸºåº•ã‚¯ãƒ©ã‚¹ã®ã¿ | **MioAgent/ShiroAgent/CoderAgent åˆ†é›¢** |
| **Event Sourcing** | ãªã— | **ã‚ã‚Š**ï¼ˆv2.0ç¶™æ‰¿ï¼‰ |
| **å®Ÿè£…æœŸé–“** | 12é€±é–“ | **8é€±é–“**ï¼ˆå„ªå…ˆé †ä½æœ€é©åŒ–ï¼‰ |

### v2.0 ã¨ã®é•ã„

| é …ç›® | v2.0 | v3.0 |
|------|------|------|
| **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£** | Hexagonal + Event Sourcing | **Clean + Hexagonal + Event Sourcing** |
| **Domainå±¤** | è»½é‡ï¼ˆæ¦‚å¿µã®ã¿ï¼‰ | **å®Œå…¨å®Ÿè£…**ï¼ˆv1.0ã®è©³ç´°è¨­è¨ˆï¼‰ |
| **Wire DI** | ãªã— | **ã‚ã‚Š**ï¼ˆv1.0ç¶™æ‰¿ï¼‰ |
| **ãƒ†ã‚¹ãƒˆæˆ¦ç•¥** | ç°¡ç´  | **è©³ç´°**ï¼ˆv1.0ã®ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰ï¼‰ |

### ä»•æ§˜æ›¸ã¨ã®æ•´åˆæ€§

| ä»•æ§˜è¦ä»¶ | v1.0 | v2.0 | v3.0 |
|---------|------|------|------|
| **LINEå…¥å£CHATå›ºå®š** | âŒ æœªè€ƒæ…® | âŒ æœªè€ƒæ…® | âœ… **å®Œå…¨å¯¾å¿œ** |
| **Mioå§”è­²åˆ¤æ–­** | âŒ æœªè€ƒæ…® | âŒ æœªè€ƒæ…® | âœ… **å®Œå…¨å¯¾å¿œ** |
| **Chat/Worker/Coderå›ºå®š** | â–³ æŠ½è±¡çš„ | â–³ æŠ½è±¡çš„ | âœ… **å®Œå…¨å¯¾å¿œ** |
| **æ‰¿èªãƒ•ãƒ­ãƒ¼** | â—‹ Domainå±¤è¨­è¨ˆ | â—‹ Event Store | âœ… **ä¸¡æ–¹çµ±åˆ** |
| **Auto-Approve** | â–³ æ¦‚å¿µã®ã¿ | â—‹ å®Œå…¨å®Ÿè£…è¨ˆç”» | âœ… **å®Œå…¨å®Ÿè£…** |

---

## ã¾ã¨ã‚

### âœ… v3.0 ã®å¼·ã¿

1. **ä»•æ§˜100%æº–æ‹ **: LINEå›ºå®šã€Mioå§”è­²ã€Chat/Worker/Coderå½¹å‰²
2. **æœ€è‰¯ã®è¨­è¨ˆ**: Clean Architectureï¼ˆv1.0ï¼‰+ Event Sourcingï¼ˆv2.0ï¼‰
3. **æœ€çŸ­å®Ÿè£…**: 8é€±é–“ï¼ˆv1.0: 12é€±é–“ã€v2.0: 10é€±é–“ï¼‰
4. **å®Œå…¨ãªç›£æŸ»**: Event Store ã«ã‚ˆã‚‹æ‰¿èªå±¥æ­´ã®æ°¸ç¶šåŒ–
5. **é«˜ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: å„å±¤ç‹¬ç«‹ã€DDDã€Wire DI

### â±ï¸ å®Ÿè£…æœŸé–“

**8é€±é–“**ï¼ˆPhase 1-4ï¼‰

- Phase 1: Domainå±¤ + Event Storeï¼ˆ2é€±é–“ï¼‰
- Phase 2: Applicationå±¤ + Infrastructureå±¤ï¼ˆ3é€±é–“ï¼‰
- Phase 3: Adapterå±¤ + Wire DIï¼ˆ2é€±é–“ï¼‰
- Phase 4: æœ¬ç•ªç§»è¡Œï¼ˆ1é€±é–“ï¼‰

### ğŸ¯ æœŸå¾…åŠ¹æœ

- **å®Œå…¨æ€§**: ä»•æ§˜100%ã€æ‰¿èªãƒ•ãƒ­ãƒ¼100%ã€Auto-Approve100%
- **ä¿å®ˆæ€§**: Clean Architecture ã«ã‚ˆã‚‹å¤‰æ›´å½±éŸ¿ã®å±€æ‰€åŒ–
- **ç›£æŸ»æ€§**: Event Store ã§æ‰¿èªå±¥æ­´ã®å®Œå…¨è¿½è·¡
- **æ‹¡å¼µæ€§**: æ–°Agent/Provider/Route ã®è¿½åŠ ãŒå®¹æ˜“
- **ä¿¡é ¼æ€§**: å†èµ·å‹•å¾Œã‚‚æ‰¿èªçŠ¶æ…‹å¾©å…ƒ

### ğŸš€ æ¨å¥¨åˆ¤æ–­

**Yes, strongly recommended:**

v3.0 ã¯ v1.0ï¼ˆç†æƒ³ï¼‰+ v2.0ï¼ˆå®Ÿç”¨ï¼‰+ ä»•æ§˜æ›¸ï¼ˆè¦ä»¶ï¼‰ã® **æœ€è‰¯ã®çµ±åˆ**ã§ã™ã€‚

- âœ… ä»•æ§˜å®Œå…¨æº–æ‹ 
- âœ… Clean Architecture + Event Sourcing
- âœ… æœ€çŸ­å®Ÿè£…æœŸé–“ï¼ˆ8é€±é–“ï¼‰
- âœ… æ®µéšçš„ç§»è¡Œå¯èƒ½

**æ¨å¥¨**: Phase 1ï¼ˆ2é€±é–“ï¼‰ã‹ã‚‰é–‹å§‹ã—ã€Domainå±¤ + Event Store ã®åŠ¹æœã‚’æ¤œè¨¼ã—ã¦ã‹ã‚‰ Phase 2-4 ã¸é€²ã‚€

---

**ä½œæˆæ—¥**: 2026-03-01
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 3.0ï¼ˆçµ±åˆç‰ˆï¼‰
**å‰æ**: v1.0 + v2.0 + ä»•æ§˜æ›¸ã®çµ±åˆ
**æ¬¡å›ãƒ¬ãƒ“ãƒ¥ãƒ¼**: Phase 1 å®Œäº†æ™‚ï¼ˆWeek 2ï¼‰
