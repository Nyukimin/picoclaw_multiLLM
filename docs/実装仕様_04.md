# 実装仕様_04（Go版）：Worker雛形（入力 -> LLM呼び出し -> JSON抽出/検証）

> アーカイブ扱い: 本ファイルは互換参照用（更新停止）。内容は v2 へ再配置済みです。  
> 参照: `docs/実装仕様_v2_04_IO契約.md` / `docs/実装仕様_v2_05_ワーカー.md` / 正本 `docs/実装仕様_v2_統合版.md`

このファイルは `pkg/workers` のコピペ雛形。
依存追加は不要（標準ライブラリ中心）。

---

## 1) `pkg/workers/types.go`

```go
package workers

type Route string

const (
	RouteChat     Route = "CHAT"
	RoutePlan     Route = "PLAN"
	RouteAnalyze  Route = "ANALYZE"
	RouteOps      Route = "OPS"
	RouteResearch Route = "RESEARCH"
	RouteCode     Route = "CODE"
)

type Risk string

const (
	RiskLow    Risk = "low"
	RiskMedium Risk = "medium"
	RiskHigh   Risk = "high"
)

type WorkerInput struct {
	Route   Route `json:"route"`
	Session struct {
		SessionID string `json:"session_id"`
		Channel   string `json:"channel"`
		TargetOS  string `json:"target_os"`
	} `json:"session"`
	UserText string `json:"user_text"`
	Context  struct {
		ShortMemory string `json:"short_memory"`
		RecentTurns []struct {
			Role string `json:"role"`
			Text string `json:"text"`
		} `json:"recent_turns"`
	} `json:"context"`
	Flags struct {
		LocalOnly       bool   `json:"local_only"`
		PrevPrimaryRoute Route `json:"prev_primary_route,omitempty"`
	} `json:"flags"`
	Limits struct {
		MaxResultChars int `json:"max_result_chars"`
		MaxQuestions   int `json:"max_questions,omitempty"`
		MaxNextActions int `json:"max_next_actions,omitempty"`
	} `json:"limits"`
}

type WorkerOutput struct {
	Result           any      `json:"result"`
	NeedsNextLoop    bool     `json:"needs_next_loop"`
	Why              string   `json:"why"`
	NextActions      []string `json:"next_actions"`
	QuestionsForUser []string `json:"questions_for_user"`
	Confidence       float64  `json:"confidence"`
	Risk             Risk     `json:"risk"`
	Fit              *bool    `json:"fit,omitempty"`
	SuggestedRoute   Route    `json:"suggested_route,omitempty"`
}
```

---

## 2) `pkg/llm/client.go`

```go
package llm

import "context"

type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type GenerateOptions struct {
	Model       string
	Messages    []Message
	TimeoutMs   int
	Temperature float64
}

type Client interface {
	Generate(ctx context.Context, opts GenerateOptions) (string, error)
}
```

---

## 3) `pkg/workers/runner.go`

```go
package workers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/sipeed/picoclaw/pkg/llm"
)

type RunWorkerOptions struct {
	Input                  WorkerInput
	Client                 llm.Client
	Model                  string
	TimeoutMs              int
	SystemPrompt           string
	UserPrompt             string
	FallbackSuggestedRoute Route
}

func extractFirstJSON(text string) (string, error) {
	// fenced json
	if i := strings.Index(strings.ToLower(text), "```json"); i >= 0 {
		j := strings.Index(text[i+7:], "```")
		if j >= 0 {
			return strings.TrimSpace(text[i+7 : i+7+j]), nil
		}
	}
	// generic fenced
	if i := strings.Index(text, "```"); i >= 0 {
		j := strings.Index(text[i+3:], "```")
		if j >= 0 {
			return strings.TrimSpace(text[i+3 : i+3+j]), nil
		}
	}
	// bracket scan
	start := strings.IndexAny(text, "{[")
	if start < 0 {
		return "", errors.New("json not found")
	}
	open := text[start]
	close := byte('}')
	if open == '[' {
		close = ']'
	}
	depth := 0
	for i := start; i < len(text); i++ {
		if text[i] == open {
			depth++
		}
		if text[i] == close {
			depth--
			if depth == 0 {
				return strings.TrimSpace(text[start : i+1]), nil
			}
		}
	}
	return "", errors.New("unterminated json")
}

func clamp01(v float64) float64 {
	if v < 0 {
		return 0
	}
	if v > 1 {
		return 1
	}
	return v
}

func validateAndNormalize(input WorkerInput, out WorkerOutput, fallback Route) WorkerOutput {
	if out.Why == "" {
		out.Why = "worker output normalized"
	}
	if len(out.NextActions) > 3 {
		out.NextActions = out.NextActions[:3]
	}
	if len(out.QuestionsForUser) > 3 {
		out.QuestionsForUser = out.QuestionsForUser[:3]
	}
	out.Confidence = clamp01(out.Confidence)
	if out.Risk == "" {
		out.Risk = RiskMedium
	}
	if out.SuggestedRoute == "" {
		out.SuggestedRoute = fallback
	}
	return out
}

func failOutput(suggested Route, why string) WorkerOutput {
	fit := true
	return WorkerOutput{
		Result:           map[string]any{"error": why},
		NeedsNextLoop:    false,
		Why:              why,
		NextActions:      []string{},
		QuestionsForUser: []string{},
		Confidence:       0,
		Risk:             RiskMedium,
		Fit:              &fit,
		SuggestedRoute:   suggested,
	}
}

func BuildWorkerUserPrompt(input WorkerInput) string {
	b, _ := json.MarshalIndent(input, "", "  ")
	return "次の WorkerInput(JSON) を処理し、JSONだけを返してください。\n\n" + string(b)
}

func RunWorkerLLM(ctx context.Context, opts RunWorkerOptions) WorkerOutput {
	suggested := opts.FallbackSuggestedRoute
	if suggested == "" {
		suggested = opts.Input.Route
	}

	raw, err := opts.Client.Generate(ctx, llm.GenerateOptions{
		Model: opts.Model,
		Messages: []llm.Message{
			{Role: "system", Content: opts.SystemPrompt},
			{Role: "user", Content: opts.UserPrompt},
		},
		TimeoutMs: opts.TimeoutMs,
	})
	if err != nil {
		return failOutput(suggested, fmt.Sprintf("llm call failed: %v", err))
	}

	jsonText, err := extractFirstJSON(raw)
	if err != nil {
		return failOutput(suggested, "json extraction failed")
	}

	var out WorkerOutput
	if err := json.Unmarshal([]byte(jsonText), &out); err != nil {
		return failOutput(suggested, "json parse failed")
	}

	return validateAndNormalize(opts.Input, out, suggested)
}
```

---

## 4) `pkg/workers/plan_worker.go`

```go
package workers

import (
	"context"

	"github.com/sipeed/picoclaw/pkg/llm"
)

const planSystemPrompt = `あなたは planWorker。最終回答は作らず、素材のみ返す。JSONのみ出力。`

func PlanWorker(ctx context.Context, client llm.Client, input WorkerInput, model string, timeoutMs int) WorkerOutput {
	return RunWorkerLLM(ctx, RunWorkerOptions{
		Input:        input,
		Client:       client,
		Model:        model,
		TimeoutMs:    timeoutMs,
		SystemPrompt: planSystemPrompt,
		UserPrompt:   BuildWorkerUserPrompt(input),
	})
}
```

---

## 5) `pkg/workers/code_worker.go`

```go
package workers

import (
	"context"

	"github.com/sipeed/picoclaw/pkg/llm"
)

const codeSystemPrompt = `あなたは codeWorker。差分または修正案をJSONで返す。JSON以外は禁止。`

func CodeWorker(ctx context.Context, client llm.Client, input WorkerInput, model string, timeoutMs int) WorkerOutput {
	if input.Flags.LocalOnly {
		return failOutput(RouteCode, "local_only is enabled; cloud code worker is forbidden")
	}
	return RunWorkerLLM(ctx, RunWorkerOptions{
		Input:                  input,
		Client:                 client,
		Model:                  model,
		TimeoutMs:              timeoutMs,
		SystemPrompt:           codeSystemPrompt,
		UserPrompt:             BuildWorkerUserPrompt(input),
		FallbackSuggestedRoute: RouteCode,
	})
}
```

---

## 6) 失敗時ルール

* LLM呼び出し失敗
* JSON抽出失敗
* JSONパース失敗

上記はすべて `NeedsNextLoop=false` で返し、LoopControllerは再実行しない。
